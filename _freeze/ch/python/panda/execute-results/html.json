{
  "hash": "05ac992df323d493db7598384400ec4d",
  "result": {
    "markdown": "---\ntitle: \"Panda Dataframe, scypy, numpy, etc.\"\nabstract: \"Pydantic\"\n---\n\n\n\n\n# Dynamic dtype\n\nData typing in python: It is dynamic in python. But we can put some hints to help users with their input. But still, it can be problematic. See below:\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef insert_patient_data(name: str, age: int):\n  print(name)\n  print(age)\n  print(\"inserted into the DB\")\n\ninsert_patient_data(\"Rashed\", \"thirty\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nRashed\nthirty\ninserted into the DB\n```\n:::\n:::\n\n\nYou see, nobody is stopping the user to put age as a string. A better way would be to keep a check on the data type using loop. If the data type doesn't match, we will raise an error.\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef insert_patient_data(name: str, age: int):\n  if type(name)==str and type(age)==int:\n    print(name)\n    print(age)\n    print(\"inserted into the DB\")\n  else:\n    raise TypeError(\"Incorrect data type\")\n\ninsert_patient_data(\"Rashed\", 30)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nRashed\n30\ninserted into the DB\n```\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\ninsert_patient_data(\"Rashed\", \"thirty\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nTypeError: Incorrect data type\n```\n:::\n:::\n\n\nBut this way is not scalable.\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef insert_patient_data(name: str, age: int):\n  if type(name)==str and type(age)==int:\n    print(name)\n    print(age)\n    print(\"inserted into the DB\")\n  else:\n    raise TypeError(\"Incorrect data type\")\n\ndef update_patient_data(name: str, age: int):\n  if type(name)==str and type(age)==int:\n    print(name)\n    print(age)\n    print(\"Updated\")\n  else:\n    raise TypeError(\"Incorrect data type\")\n\ninsert_patient_data(\"Rashed\", 30)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nRashed\n30\ninserted into the DB\n```\n:::\n\n```{.python .cell-code}\nupdate_patient_data(\"Rashed\", 30)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nRashed\n30\nUpdated\n```\n:::\n:::\n\n\nYou see the issue with scalability? How many times will we do it if we have more functions using these variables? Data validation is also very important for us for better control. In the above example, we could put `-10` as age, it would pass the data type check, there is no stopping. But is it meaningful? So, we could say `age` can not be less than 0. How to do it?\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef insert_patient_data(name: str, age: int):\n  if type(name)==str and type(age)==int:\n    if age < 0:\n      raise ValueError(\"Age cannot be less than 0\")\n    else:\n      print(name)\n      print(age)\n      print(\"Inserted into the DB\")\n  else:\n    raise TypeError(\"Incorrect data type\")\n```\n:::\n\n\nNow, let's check.\n\n\n::: {.cell}\n\n```{.python .cell-code}\ninsert_patient_data(\"Rashed\", 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nRashed\n10\nInserted into the DB\n```\n:::\n\n```{.python .cell-code}\ninsert_patient_data(\"Rashed\", -10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nValueError: Age cannot be less than 0\n```\n:::\n\n```{.python .cell-code}\ninsert_patient_data(\"Rashed\", \"10\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nTypeError: Incorrect data type\n```\n:::\n:::\n\n\nHere comes `Pydantic` to help us checking for\n\n- Data type, and\n- Data validation\n\nAnd it does so in 3 steps:  \n- 1. **Define a Pydantic model (class)** representing the **ideal schema**. This includes the expected fields, their data types and any validation constraint (e.g. `lt=0` for negative numbers) \n- 2. **Instantiate the model with raw input data** or make a Pydantic object (usually a dictionary or JSON-like structure) \n  - Pydantic will automatically **validate** the data and **coerce** it into the correct Python types (if possible)\n  - If the data doesn't meet the model's criteria, Pydantic raise a `ValidationError`. \n- 3. Pass the validated model object to functions or use it throughout your codebase. - This ensures that every part of your program works with **clean, type-safe, and logically valid data**.\n\nLet's use it now. But let's make the example more realistic. We will make a dataframe with the required fields using pandas first. Then we will insert a patient info into that dataframe if the patient is new. If not, we will update information for that patient.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom pydantic import BaseModel, ValidationError\nimport pandas as pd\n\n# ---------------------\n# 1. Define the model\n# ---------------------\nclass Patient(BaseModel):\n    name: str\n    age: int\n    weight: float\n\n# ---------------------\n# 2. In-memory database\n# ---------------------\n# Create a DataFrame to store patient records\ndb = pd.DataFrame({\n    'name': pd.Series(dtype='str'),\n    'age': pd.Series(dtype='int'),\n    'weight': pd.Series(dtype='float')\n})\n\n# ---------------------\n# 3. Insert function\n# ---------------------\ndef insert_patient_data(patient: Patient):\n    global db\n    # Check if patient already exists by name\n    if db['name'].eq(patient.name).any():\n        print(f\"Patient '{patient.name}' already exists. Use update instead.\")\n        return\n    \n    # Append new patient\n    db = pd.concat([db, pd.DataFrame([patient.model_dump()])], ignore_index=True)\n    print(f\"Inserted patient: {patient.name}\")\n\n# ---------------------\n# 4. Update function\n# ---------------------\ndef update_patient_data(patient: Patient):\n    global db\n    # Find index of the patient by name\n    idx = db.index[db['name'] == patient.name].tolist()\n    if not idx:\n        print(f\"Patient '{patient.name}' not found. Use insert instead.\")\n        return\n    \n    # Update the record\n    db.loc[idx[0], ['age', 'weight']] = patient.age, patient.weight\n    print(f\"Updated patient: {patient.name}\")\n\n# ---------------------\n# 5. Test the system\n# ---------------------\n# Initial insert\npatient_info = {'name': 'Rashed', 'age': 29, 'weight': '55'}\ntry:\n    patient1 = Patient(**patient_info) #unpacking using 2 star signs\n    insert_patient_data(patient1)\nexcept ValidationError as e:\n    print(\"Validation Error:\", e)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nInserted patient: Rashed\n```\n:::\n\n```{.python .cell-code}\n# Try to insert again (should warn)\ninsert_patient_data(patient1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nPatient 'Rashed' already exists. Use update instead.\n```\n:::\n\n```{.python .cell-code}\n# Update patient\nupdated_info = {'name': 'Rashed', 'age': 30, 'weight': 57.5}\ntry:\n    patient1_updated = Patient(**updated_info)\n    update_patient_data(patient1_updated)\nexcept ValidationError as e:\n    print(\"Validation Error:\", e)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nUpdated patient: Rashed\n```\n:::\n\n```{.python .cell-code}\n# Show database\nprint(\"\\nCurrent Database:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n\nCurrent Database:\n```\n:::\n\n```{.python .cell-code}\nprint(db)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n     name  age  weight\n0  Rashed   30    57.5\n```\n:::\n:::\n\n\nDid you notice something? We put `'weight': '55'` and PyDantic coerced it to float smartly.\n\nBut we have another practical issue remaining. Names are not reliable identifier, multiple patients could have the same name. So, we need to handle it correctly using a patient id.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom pydantic import BaseModel, ValidationError\nimport pandas as pd\n\n# ---------------------\n# 1. Patient model with manual ID\n# ---------------------\nclass Patient(BaseModel):\n    patient_id: str\n    name: str\n    age: int\n    weight: float\n\n# ---------------------\n# 2. In-memory DB\n# ---------------------\ndb = pd.DataFrame({\n    'patient_id': pd.Series(dtype='str'),\n    'name': pd.Series(dtype='str'),\n    'age': pd.Series(dtype='int'),\n    'weight': pd.Series(dtype='float')\n})\n\n# ---------------------\n# 3. Insert function\n# ---------------------\ndef insert_patient_data(patient: Patient):\n    global db\n    if db['patient_id'].eq(patient.patient_id).any():\n        print(f\"Patient ID '{patient.patient_id}' already exists. Use update instead.\")\n        return\n    new_row = pd.DataFrame([patient.model_dump()])\n    db = pd.concat([db, new_row], ignore_index=True)\n    print(f\"Inserted patient: {patient.name} with ID: {patient.patient_id}\")\n\n# ---------------------\n# 4. Update function\n# ---------------------\ndef update_patient_data(patient: Patient):\n    global db\n    idx = db.index[db['patient_id'] == patient.patient_id].tolist()\n    if not idx:\n        print(f\"Patient ID '{patient.patient_id}' not found. Use insert instead.\")\n        return\n    db.loc[idx[0], ['name', 'age', 'weight']] = patient.name, patient.age, patient.weight\n    print(f\"Updated patient: {patient.name} with ID: {patient.patient_id}\")\n\n# ---------------------\n# 5. Test it\n# ---------------------\ntry:\n    # Add 2 patients manually\n    patient1 = Patient(patient_id='P001', name='Rashed', age=29, weight=55)\n    patient2 = Patient(patient_id='P002', name='Rashed', age=40, weight=70)\n\n    insert_patient_data(patient1)\n    insert_patient_data(patient2)\n\n    # Attempt duplicate insert\n    insert_patient_data(patient1)\n\n    # Update patient1\n    patient1_updated = Patient(patient_id='P001', name='Rashed', age=30, weight=56.5)\n    update_patient_data(patient1_updated)\n\nexcept ValidationError as e:\n    print(\"Validation Error:\", e)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nInserted patient: Rashed with ID: P001\nInserted patient: Rashed with ID: P002\nPatient ID 'P001' already exists. Use update instead.\nUpdated patient: Rashed with ID: P001\n```\n:::\n\n```{.python .cell-code}\n# ---------------------\n# 6. Show DB\n# ---------------------\nprint(\"\\nCurrent Database:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n\nCurrent Database:\n```\n:::\n\n```{.python .cell-code}\nprint(db)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n  patient_id    name  age  weight\n0       P001  Rashed   30    56.5\n1       P002  Rashed   40    70.0\n```\n:::\n:::\n\n\nLet's make a bit more complex model. We are going to add more fields having more than one entry. So, pandas dataframe is not a good choice. We will use json data format instead.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom pydantic import BaseModel, ValidationError\nfrom typing import List, Dict\nimport json\n\n# ---------------------\n# 1. Patient model\n# ---------------------\nclass Patient(BaseModel):\n    patient_id: str\n    name: str\n    age: int\n    weight: float\n    married: bool\n    allergies: List[str]\n    contact_info: Dict[str, str]\n\n# ---------------------\n# 2. In-memory \"DB\"\n# ---------------------\ndb: List[Patient] = []\n\n# ---------------------\n# 3. Insert function\n# ---------------------\ndef insert_patient_data(patient: Patient):\n    global db\n    if any(p.patient_id == patient.patient_id for p in db):\n        print(f\"Patient ID '{patient.patient_id}' already exists. Use update instead.\")\n        return\n    db.append(patient)\n    print(f\"Inserted patient: {patient.name} with ID: {patient.patient_id}\")\n\n# ---------------------\n# 4. Update function\n# ---------------------\ndef update_patient_data(patient: Patient):\n    global db\n    for idx, p in enumerate(db):\n        if p.patient_id == patient.patient_id:\n            db[idx] = patient\n            print(f\"Updated patient: {patient.name} with ID: {patient.patient_id}\")\n            return\n    print(f\"Patient ID '{patient.patient_id}' not found. Use insert instead.\")\n\n# ---------------------\n# 5. Save/Load to/from JSON\n# ---------------------\ndef save_db_to_json(filepath=\"patients.json\"):\n    with open(filepath, 'w') as f:\n        json.dump([p.model_dump() for p in db], f, indent=2)\n    print(\"Database saved to JSON.\")\n\ndef load_db_from_json(filepath=\"patients.json\"):\n    global db\n    try:\n        with open(filepath, 'r') as f:\n            data = json.load(f)\n            db = [Patient(**p) for p in data]\n        print(\"Database loaded from JSON.\")\n    except FileNotFoundError:\n        print(\"No existing database found.\")\n    except ValidationError as e:\n        print(\"Validation error while loading:\", e)\n\n# ---------------------\n# 6. Test it\n# ---------------------\ntry:\n    load_db_from_json()\n\n    patient1 = Patient(\n        patient_id='P001',\n        name='Rashed',\n        age=29,\n        weight=55,\n        married=True,\n        allergies=['Dust', 'Pollen'],\n        contact_info={'phone': '+492648973', 'email': 'abcrashed@gmail.com'}\n    )\n\n    patient2 = Patient(\n        patient_id='P002',\n        name='Rashed',\n        age=40,\n        weight=70,\n        married=True,\n        allergies=['Pollen'],\n        contact_info={'phone': '+49663882', 'email': 'rashed@gmail.com'}\n    )\n\n    insert_patient_data(patient1)\n    insert_patient_data(patient2)\n    insert_patient_data(patient1)  # Duplicate test\n\n    # Update\n    patient1_updated = Patient(\n        patient_id='P001',\n        name='Rashed',\n        age=30,\n        weight=56.7,\n        married=True,\n        allergies=['Dust', 'Pollen'],\n        contact_info={'phone': '+492648973', 'email': 'abcrashed@gmail.com'}\n    )\n    update_patient_data(patient1_updated)\n\n    save_db_to_json()\n\nexcept ValidationError as e:\n    print(\"Validation Error:\", e)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nDatabase loaded from JSON.\nPatient ID 'P001' already exists. Use update instead.\nPatient ID 'P002' already exists. Use update instead.\nPatient ID 'P001' already exists. Use update instead.\nUpdated patient: Rashed with ID: P001\nDatabase saved to JSON.\n```\n:::\n\n```{.python .cell-code}\n# ---------------------\n# 7. Show database\n# ---------------------\nprint(\"\\nCurrent Database (in-memory):\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n\nCurrent Database (in-memory):\n```\n:::\n\n```{.python .cell-code}\nfor patient in db:\n    print(patient.model_dump())\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n{'patient_id': 'P001', 'name': 'Rashed', 'age': 30, 'weight': 56.7, 'married': True, 'allergies': ['Dust', 'Pollen'], 'contact_info': {'phone': '+492648973', 'email': 'abcrashed@gmail.com'}}\n{'patient_id': 'P002', 'name': 'Rashed', 'age': 40, 'weight': 70.0, 'married': True, 'allergies': ['Pollen'], 'contact_info': {'phone': '+49663882', 'email': 'rashed@gmail.com'}}\n```\n:::\n:::\n\n\nWhy did not we use `list` and `dict` though? Because, we could make sure that the fields are list and string, but we could not check the data types inside those list or dict. That's why we used 2-step validation using `List[str]` and `Dict[str, str]`.\n\nWe could make our model more flexible. For example, not every patient will have allergies, but that field is required now! Let's work around that.\n",
    "supporting": [
      "panda_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}