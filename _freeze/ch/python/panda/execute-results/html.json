{
  "hash": "faac750fc8ae9b20f8597d0021180060",
  "result": {
    "markdown": "---\ntitle: \"Panda Dataframe, scypy, numpy, data typing, etc.\"\nabstract: \"Pydantic\"\n---\n\n\n\n\n# Dynamic data type\n\nData typing in python: It is dynamic in python. But we can put some hints to help users with their input. But still, it can be problematic. See below:\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef insert_patient_data(name: str, age: int):\n  print(name)\n  print(age)\n  print(\"inserted into the DB\")\n\ninsert_patient_data(\"Rashed\", \"thirty\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nRashed\nthirty\ninserted into the DB\n```\n:::\n:::\n\n\nYou see, nobody is stopping the user to put age as a string. A better way would be to keep a check on the data type using loop. If the data type doesn't match, we will raise an error.\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef insert_patient_data(name: str, age: int):\n  if type(name)==str and type(age)==int:\n    print(name)\n    print(age)\n    print(\"inserted into the DB\")\n  else:\n    raise TypeError(\"Incorrect data type\")\n\ninsert_patient_data(\"Rashed\", 30)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nRashed\n30\ninserted into the DB\n```\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\ninsert_patient_data(\"Rashed\", \"thirty\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nTypeError: Incorrect data type\n```\n:::\n:::\n\n\nWe see a data type error here, so our system works to catch it.\n\nBut this way is not scalable. Let's work around it.\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef insert_patient_data(name: str, age: int):\n  if type(name)==str and type(age)==int:\n    print(name)\n    print(age)\n    print(\"inserted into the DB\")\n  else:\n    raise TypeError(\"Incorrect data type\")\n\ndef update_patient_data(name: str, age: int):\n  if type(name)==str and type(age)==int:\n    print(name)\n    print(age)\n    print(\"Updated\")\n  else:\n    raise TypeError(\"Incorrect data type\")\n\ninsert_patient_data(\"Rashed\", 30)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nRashed\n30\ninserted into the DB\n```\n:::\n\n```{.python .cell-code}\nupdate_patient_data(\"Rashed\", 29)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nRashed\n29\nUpdated\n```\n:::\n:::\n\n\nYou see the issue with scalability? How many times will we do it if we have more functions using these variables? Data validation is also very important for us for better control. In the above example, we could put `-10` as age, it would pass the data type check, there is no stopping. But is it meaningful? So, we could say `age` can not be less than 0. How to do it?\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef insert_patient_data(name: str, age: int):\n  if type(name)==str and type(age)==int:\n    if age < 0:\n      raise ValueError(\"Age cannot be less than 0\")\n    else:\n      print(name)\n      print(age)\n      print(\"Inserted into the DB\")\n  else:\n    raise TypeError(\"Incorrect data type\")\n```\n:::\n\n\nNow, let's check.\n\n\n::: {.cell}\n\n```{.python .cell-code}\ninsert_patient_data(\"Rashed\", 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nRashed\n10\nInserted into the DB\n```\n:::\n\n```{.python .cell-code}\ninsert_patient_data(\"Rashed\", -10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nValueError: Age cannot be less than 0\n```\n:::\n\n```{.python .cell-code}\ninsert_patient_data(\"Rashed\", \"10\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nTypeError: Incorrect data type\n```\n:::\n:::\n\n\nHere comes `Pydantic` to help us checking for \n\n- Data type, and\n- Data validation\n\nAnd it does so in 3 steps:  \n\n- 1. **Define a Pydantic model (class)** representing the **ideal schema**. This includes the expected fields, their data types and any validation constraint (e.g. `lt=0` for negative numbers)  \n- 2. **Instantiate the model with raw input data** or make a Pydantic object (usually a dictionary or JSON-like structure) \n  - Pydantic will automatically **validate** the data and **coerce** it into the correct Python types (if possible)  \n  - If the data doesn't meet the model's criteria, Pydantic raise a `ValidationError`.  \n- 3. Pass the validated model object to functions or use it throughout your codebase. \n  - This ensures that every part of your program works with **clean, type-safe, and logically valid data**.\n\nLet's use it now. But let's make the example more realistic. We will make a dataframe with the required fields using pandas first. Then we will insert a patient info into that dataframe if the patient is new. If not, we will update information for that patient.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom pydantic import BaseModel, ValidationError\nimport pandas as pd\n\n# ---------------------\n# 1. Define the model\n# ---------------------\nclass Patient(BaseModel):\n    name: str\n    age: int\n    weight: float\n\n# ---------------------\n# 2. In-memory database\n# ---------------------\n# Create a DataFrame to store patient records\ndb = pd.DataFrame({\n    'name': pd.Series(dtype='str'),\n    'age': pd.Series(dtype='int'),\n    'weight': pd.Series(dtype='float')\n})\n\n# ---------------------\n# 3. Insert function\n# ---------------------\ndef insert_patient_data(patient: Patient):\n    global db\n    # Check if patient already exists by name\n    if db['name'].eq(patient.name).any():\n        print(f\"Patient '{patient.name}' already exists. Use update instead.\")\n        return\n    \n    # Append new patient\n    db = pd.concat([db, pd.DataFrame([patient.model_dump()])], ignore_index=True)\n    print(f\"Inserted patient: {patient.name}\")\n\n# ---------------------\n# 4. Update function\n# ---------------------\ndef update_patient_data(patient: Patient):\n    global db\n    # Find index of the patient by name\n    idx = db.index[db['name'] == patient.name].tolist()\n    if not idx:\n        print(f\"Patient '{patient.name}' not found. Use insert instead.\")\n        return\n    \n    # Update the record\n    db.loc[idx[0], ['age', 'weight']] = patient.age, patient.weight\n    print(f\"Updated patient: {patient.name}\")\n\n# ---------------------\n# 5. Test the system\n# ---------------------\n# Initial insert\npatient_info = {'name': 'Rashed', 'age': 29, 'weight': '55'}\ntry:\n    patient1 = Patient(**patient_info) #unpacking using 2 star signs\n    insert_patient_data(patient1)\nexcept ValidationError as e:\n    print(\"Validation Error:\", e)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nInserted patient: Rashed\n```\n:::\n\n```{.python .cell-code}\n# Try to insert again (should warn)\ninsert_patient_data(patient1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nPatient 'Rashed' already exists. Use update instead.\n```\n:::\n\n```{.python .cell-code}\n# Update patient\nupdated_info = {'name': 'Rashed', 'age': 30, 'weight': 57.5}\ntry:\n    patient1_updated = Patient(**updated_info)\n    update_patient_data(patient1_updated)\nexcept ValidationError as e:\n    print(\"Validation Error:\", e)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nUpdated patient: Rashed\n```\n:::\n\n```{.python .cell-code}\n# Show database\nprint(\"\\nCurrent Database:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n\nCurrent Database:\n```\n:::\n\n```{.python .cell-code}\nprint(db)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n     name  age  weight\n0  Rashed   30    57.5\n```\n:::\n:::\n\n\nDid you notice something? We put `'weight': '55'` and PyDantic coerced it to float smartly.\n\nBut we have another practical issue remaining. Names are not reliable identifier, multiple patients could have the same name. So, we need to handle it correctly using a patient id.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom pydantic import BaseModel, ValidationError\nimport pandas as pd\n\n# ---------------------\n# 1. Patient model with manual ID\n# ---------------------\nclass Patient(BaseModel):\n    patient_id: str\n    name: str\n    age: int\n    weight: float\n\n# ---------------------\n# 2. In-memory DB\n# ---------------------\ndb = pd.DataFrame({\n    'patient_id': pd.Series(dtype='str'),\n    'name': pd.Series(dtype='str'),\n    'age': pd.Series(dtype='int'),\n    'weight': pd.Series(dtype='float')\n})\n\n# ---------------------\n# 3. Insert function\n# ---------------------\ndef insert_patient_data(patient: Patient):\n    global db\n    if db['patient_id'].eq(patient.patient_id).any():\n        print(f\"Patient ID '{patient.patient_id}' already exists. Use update instead.\")\n        return\n    new_row = pd.DataFrame([patient.model_dump()])\n    db = pd.concat([db, new_row], ignore_index=True)\n    print(f\"Inserted patient: {patient.name} with ID: {patient.patient_id}\")\n\n# ---------------------\n# 4. Update function\n# ---------------------\ndef update_patient_data(patient: Patient):\n    global db\n    idx = db.index[db['patient_id'] == patient.patient_id].tolist()\n    if not idx:\n        print(f\"Patient ID '{patient.patient_id}' not found. Use insert instead.\")\n        return\n    db.loc[idx[0], ['name', 'age', 'weight']] = patient.name, patient.age, patient.weight\n    print(f\"Updated patient: {patient.name} with ID: {patient.patient_id}\")\n\n# ---------------------\n# 5. Test it\n# ---------------------\ntry:\n    # Add 2 patients manually\n    patient1 = Patient(patient_id='P001', name='Rashed', age=29, weight=55)\n    patient2 = Patient(patient_id='P002', name='Rashed', age=40, weight=70)\n\n    insert_patient_data(patient1)\n    insert_patient_data(patient2)\n\n    # Attempt duplicate insert\n    insert_patient_data(patient1)\n\n    # Update patient1\n    patient1_updated = Patient(patient_id='P001', name='Rashed', age=30, weight=56.5)\n    update_patient_data(patient1_updated)\n\nexcept ValidationError as e:\n    print(\"Validation Error:\", e)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nInserted patient: Rashed with ID: P001\nInserted patient: Rashed with ID: P002\nPatient ID 'P001' already exists. Use update instead.\nUpdated patient: Rashed with ID: P001\n```\n:::\n\n```{.python .cell-code}\n# ---------------------\n# 6. Show DB\n# ---------------------\nprint(\"\\nCurrent Database:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n\nCurrent Database:\n```\n:::\n\n```{.python .cell-code}\nprint(db)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n  patient_id    name  age  weight\n0       P001  Rashed   30    56.5\n1       P002  Rashed   40    70.0\n```\n:::\n:::\n\n\nLet's make a bit more complex model. We are going to add more fields having more than one entry. So, pandas dataframe is not a good choice. We will use json data format instead.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom pydantic import BaseModel, ValidationError\nfrom typing import List, Dict\nimport json\n\n# ---------------------\n# 1. Patient model\n# ---------------------\nclass Patient(BaseModel):\n    patient_id: str\n    name: str\n    age: int\n    weight: float\n    married: bool\n    allergies: List[str]\n    contact_info: Dict[str, str]\n\n# ---------------------\n# 2. In-memory \"DB\"\n# ---------------------\ndb: List[Patient] = []\n\n# ---------------------\n# 3. Insert function\n# ---------------------\ndef insert_patient_data(patient: Patient):\n    global db\n    if any(p.patient_id == patient.patient_id for p in db):\n        print(f\"Patient ID '{patient.patient_id}' already exists. Use update instead.\")\n        return\n    db.append(patient)\n    print(f\"Inserted patient: {patient.name} with ID: {patient.patient_id}\")\n\n# ---------------------\n# 4. Update function\n# ---------------------\ndef update_patient_data(patient: Patient):\n    global db\n    for idx, p in enumerate(db):\n        if p.patient_id == patient.patient_id:\n            db[idx] = patient\n            print(f\"Updated patient: {patient.name} with ID: {patient.patient_id}\")\n            return\n    print(f\"Patient ID '{patient.patient_id}' not found. Use insert instead.\")\n\n# ---------------------\n# 5. Save/Load to/from JSON\n# ---------------------\ndef save_db_to_json(filepath=\"patients.json\"):\n    with open(filepath, 'w') as f:\n        json.dump([p.model_dump() for p in db], f, indent=2)\n    print(\"Database saved to JSON.\")\n\ndef load_db_from_json(filepath=\"patients.json\"):\n    global db\n    try:\n        with open(filepath, 'r') as f:\n            data = json.load(f)\n            db = [Patient(**p) for p in data]\n        print(\"Database loaded from JSON.\")\n    except FileNotFoundError:\n        print(\"No existing database found.\")\n    except ValidationError as e:\n        print(\"Validation error while loading:\", e)\n\n# ---------------------\n# 6. Test it\n# ---------------------\ntry:\n    load_db_from_json()\n\n    patient1 = Patient(\n        patient_id='P001',\n        name='Rashed',\n        age=29,\n        weight=55,\n        married=True,\n        allergies=['Dust', 'Pollen'],\n        contact_info={'phone': '+492648973', 'email': 'abcrashed@gmail.com'}\n    )\n\n    patient2 = Patient(\n        patient_id='P002',\n        name='Rashed',\n        age=40,\n        weight=70,\n        married=True,\n        allergies=['Pollen'],\n        contact_info={'phone': '+49663882', 'email': 'rashed@gmail.com'}\n    )\n\n    insert_patient_data(patient1)\n    insert_patient_data(patient2)\n    insert_patient_data(patient1)  # Duplicate test\n\n    # Update\n    patient1_updated = Patient(\n        patient_id='P001',\n        name='Rashed',\n        age=30,\n        weight=56.7,\n        married=True,\n        allergies=['Dust', 'Pollen'],\n        contact_info={'phone': '+492648973', 'email': 'abcrashed@gmail.com'}\n    )\n    update_patient_data(patient1_updated)\n\n    save_db_to_json()\n\nexcept ValidationError as e:\n    print(\"Validation Error:\", e)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nDatabase loaded from JSON.\nPatient ID 'P001' already exists. Use update instead.\nPatient ID 'P002' already exists. Use update instead.\nPatient ID 'P001' already exists. Use update instead.\nUpdated patient: Rashed with ID: P001\nDatabase saved to JSON.\n```\n:::\n\n```{.python .cell-code}\n# ---------------------\n# 7. Show database\n# ---------------------\nprint(\"\\nCurrent Database (in-memory):\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n\nCurrent Database (in-memory):\n```\n:::\n\n```{.python .cell-code}\nfor patient in db:\n    print(patient.model_dump())\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n{'patient_id': 'P001', 'name': 'Rashed', 'age': 30, 'weight': 56.7, 'married': True, 'allergies': ['Dust', 'Pollen'], 'contact_info': {'phone': '+492648973', 'email': 'abcrashed@gmail.com'}}\n{'patient_id': 'P002', 'name': 'Rashed', 'age': 40, 'weight': 70.0, 'married': True, 'allergies': ['Pollen'], 'contact_info': {'phone': '+49663882', 'email': 'rashed@gmail.com'}}\n```\n:::\n:::\n\n\nWhy did not we use `list` and `dict` though? Because, we could make sure that the fields are list and string, but we could not check the data types inside those list or dict. That's why we used 2-step validation using `List[str]` and `Dict[str, str]`.\n\nWe could make our model more flexible. For example, not every patient will have allergies, but that field is required now! Let's work around that.\n\n## Making Fields Optional and Adding Validation\n\nIn real-world applications, not all fields are required. Let's make our model more realistic by adding optional fields and custom validation:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom pydantic import BaseModel, ValidationError, Field, validator\nfrom typing import List, Dict, Optional\nimport json\nfrom datetime import datetime\n\n# ---------------------\n# 1. Enhanced Patient model with optional fields and validation\n# ---------------------\nclass Patient(BaseModel):\n    patient_id: str = Field(..., min_length=4, max_length=10, description=\"Unique patient identifier\")\n    name: str = Field(..., min_length=2, max_length=50, description=\"Patient full name\")\n    age: int = Field(..., ge=0, le=150, description=\"Patient age in years\")\n    weight: float = Field(..., gt=0, le=500, description=\"Patient weight in kg\")\n    height: Optional[float] = Field(None, gt=0, le=300, description=\"Patient height in cm\")\n    married: bool = False  # Default value\n    allergies: Optional[List[str]] = Field(default=[], description=\"List of known allergies\")\n    contact_info: Dict[str, str] = Field(default_factory=dict, description=\"Contact information\")\n    emergency_contact: Optional[Dict[str, str]] = None\n    blood_type: Optional[str] = Field(None, regex=r'^(A|B|AB|O)[+-]\n, description=\"Blood type (e.g., A+, O-, AB+)\")\n    \n    # Custom validator for name formatting\n    @validator('name')\n    def name_must_not_be_empty_or_just_spaces(cls, v):\n        if not v.strip():\n            raise ValueError('Name cannot be empty or just spaces')\n        return v.strip().title()  # Capitalize properly\n    \n    # Custom validator for phone number in contact_info\n    @validator('contact_info')\n    def validate_contact_info(cls, v):\n        if 'phone' in v:\n            phone = v['phone']\n            # Simple phone validation (starts with + and has digits)\n            if not phone.startswith('+') or not phone[1:].replace('-', '').replace(' ', '').isdigit():\n                raise ValueError('Phone number must start with + and contain valid digits')\n        return v\n    \n    # Calculate BMI if height is provided\n    def calculate_bmi(self) -> Optional[float]:\n        if self.height:\n            height_m = self.height / 100  # Convert cm to meters\n            return round(self.weight / (height_m ** 2), 2)\n        return None\n    \n    # Check if patient is adult\n    def is_adult(self) -> bool:\n        return self.age >= 18\n    \n    # Get formatted patient info\n    def get_summary(self) -> str:\n        bmi = self.calculate_bmi()\n        bmi_str = f\", BMI: {bmi}\" if bmi else \"\"\n        allergies_str = f\", Allergies: {', '.join(self.allergies)}\" if self.allergies else \", No known allergies\"\n        return f\"{self.name} (ID: {self.patient_id}), Age: {self.age}, Weight: {self.weight}kg{bmi_str}{allergies_str}\"\n\n# ---------------------\n# 2. Enhanced database operations\n# ---------------------\ndb: List[Patient] = []\n\ndef insert_patient_data(patient: Patient):\n    global db\n    if any(p.patient_id == patient.patient_id for p in db):\n        print(f\"❌ Patient ID '{patient.patient_id}' already exists. Use update instead.\")\n        return False\n    db.append(patient)\n    print(f\"✅ Inserted patient: {patient.get_summary()}\")\n    return True\n\ndef update_patient_data(patient: Patient):\n    global db\n    for idx, p in enumerate(db):\n        if p.patient_id == patient.patient_id:\n            db[idx] = patient\n            print(f\"✅ Updated patient: {patient.get_summary()}\")\n            return True\n    print(f\"❌ Patient ID '{patient.patient_id}' not found. Use insert instead.\")\n    return False\n\ndef find_patient_by_id(patient_id: str) -> Optional[Patient]:\n    for patient in db:\n        if patient.patient_id == patient_id:\n            return patient\n    return None\n\ndef list_all_patients():\n    if not db:\n        print(\"📭 No patients in database.\")\n        return\n    \n    print(f\"\\n👥 All Patients ({len(db)} total):\")\n    print(\"-\" * 80)\n    for patient in db:\n        print(f\"🏥 {patient.get_summary()}\")\n        if patient.blood_type:\n            print(f\"   🩸 Blood Type: {patient.blood_type}\")\n        if patient.contact_info:\n            contact_str = \", \".join([f\"{k}: {v}\" for k, v in patient.contact_info.items()])\n            print(f\"   📞 Contact: {contact_str}\")\n        print()\n\ndef get_patients_by_age_range(min_age: int, max_age: int) -> List[Patient]:\n    return [p for p in db if min_age <= p.age <= max_age]\n\ndef get_patients_with_allergies() -> List[Patient]:\n    return [p for p in db if p.allergies]\n\n# ---------------------\n# 3. Test the enhanced system\n# ---------------------\nprint(\"🏥 Testing Enhanced Patient Management System\")\nprint(\"=\" * 50)\n\ntry:\n    # Test 1: Valid patient with all fields\n    print(\"\\n🧪 Test 1: Complete patient record\")\n    patient1 = Patient(\n        patient_id='P001',\n        name='   rashed uzzaman   ',  # Will be cleaned and capitalized\n        age=29,\n        weight=65.5,\n        height=175,\n        married=True,\n        allergies=['Dust', 'Pollen', 'Cats'],\n        contact_info={'phone': '+49-123-456789', 'email': 'rashed@email.com'},\n        emergency_contact={'name': 'Jane Doe', 'phone': '+49-987-654321'},\n        blood_type='O+'\n    )\n    insert_patient_data(patient1)\n    print(f\"   BMI: {patient1.calculate_bmi()}\")\n    print(f\"   Adult: {patient1.is_adult()}\")\n    \n    # Test 2: Minimal patient record (using defaults)\n    print(\"\\n🧪 Test 2: Minimal patient record\")\n    patient2 = Patient(\n        patient_id='P002',\n        name='Alice Johnson',\n        age=35,\n        weight=58.2\n    )\n    insert_patient_data(patient2)\n    \n    # Test 3: Child patient\n    print(\"\\n🧪 Test 3: Child patient\")\n    patient3 = Patient(\n        patient_id='P003',\n        name='Bobby Smith',\n        age=12,\n        weight=40.0,\n        height=150,\n        allergies=['Peanuts'],\n        contact_info={'phone': '+49-555-123456'},\n        blood_type='A-'\n    )\n    insert_patient_data(patient3)\n    print(f\"   Adult: {patient3.is_adult()}\")\n    \n    # Test 4: Try to insert duplicate\n    print(\"\\n🧪 Test 4: Duplicate insertion attempt\")\n    insert_patient_data(patient1)\n    \n    # Test 5: Update patient\n    print(\"\\n🧪 Test 5: Update patient weight\")\n    patient1_updated = Patient(\n        patient_id='P001',\n        name='Rashed Uzzaman',\n        age=30,  # Birthday!\n        weight=67.0,  # Gained weight\n        height=175,\n        married=True,\n        allergies=['Dust', 'Pollen'],  # No longer allergic to cats!\n        contact_info={'phone': '+49-123-456789', 'email': 'rashed.new@email.com'},\n        blood_type='O+'\n    )\n    update_patient_data(patient1_updated)\n    \nexcept ValidationError as e:\n    print(f\"❌ Validation Error: {e}\")\n\n# Display all patients\nlist_all_patients()\n\n# Query examples\nprint(\"\\n🔍 Query Examples:\")\nprint(\"-\" * 30)\nadults = [p for p in db if p.is_adult()]\nprint(f\"👨‍👩‍👧‍👦 Adult patients: {len(adults)}\")\n\npatients_with_allergies = get_patients_with_allergies()\nprint(f\"🤧 Patients with allergies: {len(patients_with_allergies)}\")\nfor p in patients_with_allergies:\n    print(f\"   - {p.name}: {', '.join(p.allergies)}\")\n\nyoung_adults = get_patients_by_age_range(18, 30)\nprint(f\"🧑 Young adults (18-30): {len(young_adults)}\")\nfor p in young_adults:\n    print(f\"   - {p.name} ({p.age} years old)\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nunterminated string literal (detected at line 19) (<string>, line 19)\n```\n:::\n:::\n\n\n## Advanced Validation with Custom Validators\n\nNow let's see what happens when we try to insert invalid data. Pydantic will catch these errors and give us helpful messages:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nprint(\"\\n🚨 Testing Validation Errors\")\nprint(\"=\" * 40)\n\n# Test invalid data scenarios\ntest_cases = [\n    {\n        'name': 'Invalid Age Test',\n        'data': {'patient_id': 'P999', 'name': 'Test Patient', 'age': -5, 'weight': 70},\n        'expected_error': 'Age cannot be negative'\n    },\n    {\n        'name': 'Invalid Weight Test', \n        'data': {'patient_id': 'P998', 'name': 'Test Patient', 'age': 25, 'weight': 0},\n        'expected_error': 'Weight must be greater than 0'\n    },\n    {\n        'name': 'Invalid Blood Type Test',\n        'data': {'patient_id': 'P997', 'name': 'Test Patient', 'age': 25, 'weight': 70, 'blood_type': 'XYZ'},\n        'expected_error': 'Invalid blood type format'\n    },\n    {\n        'name': 'Invalid Phone Number Test',\n        'data': {'patient_id': 'P996', 'name': 'Test Patient', 'age': 25, 'weight': 70, 'contact_info': {'phone': 'invalid-phone'}},\n        'expected_error': 'Invalid phone number format'\n    },\n    {\n        'name': 'Empty Name Test',\n        'data': {'patient_id': 'P995', 'name': '   ', 'age': 25, 'weight': 70},\n        'expected_error': 'Name cannot be empty'\n    }\n]\n\nfor test in test_cases:\n    print(f\"\\n🧪 {test['name']}:\")\n    try:\n        invalid_patient = Patient(**test['data'])\n        print(f\"   ⚠️ Unexpectedly succeeded: {invalid_patient.name}\")\n    except ValidationError as e:\n        print(f\"   ✅ Correctly caught error: {str(e).split('\\n')[0]}\")\n    except Exception as e:\n        print(f\"   ❌ Unexpected error type: {type(e).__name__}: {e}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nf-string expression part cannot include a backslash (<string>, line 39)\n```\n:::\n:::\n\n\n## Real-World Data Processing with Pydantic\n\nLet's simulate reading patient data from a CSV file and using Pydantic to validate and clean it:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport csv\nfrom io import StringIO\n\n# Simulate CSV data (in real world, you'd read from a file)\ncsv_data = \"\"\"patient_id,name,age,weight,height,married,allergies,phone,email,blood_type\nP101,john doe,25,70.5,180,true,\"Dust,Pollen\",+49-111-222333,john@email.com,A+\nP102,JANE SMITH,35,65.0,,false,Peanuts,+49-444-555666,jane@email.com,O-\nP103,bob wilson,17,55.2,165,false,,+49-777-888999,bob@email.com,\nP104,invalid patient,-5,0,200,maybe,Bad Data,invalid-phone,not-an-email,XYZ\nP105,mary johnson,45,72.3,168,true,\"Shellfish,Latex\",+49-123-987654,mary@email.com,B+\n\"\"\"\n\ndef process_csv_data(csv_content: str):\n    \"\"\"Process CSV data and create Patient objects with validation\"\"\"\n    successful_patients = []\n    failed_records = []\n    \n    csv_reader = csv.DictReader(StringIO(csv_content))\n    \n    for row_num, row in enumerate(csv_reader, 1):\n        try:\n            # Clean and prepare data\n            processed_row = {\n                'patient_id': row['patient_id'].strip(),\n                'name': row['name'].strip(),\n                'age': int(row['age']),\n                'weight': float(row['weight']),\n                'married': row['married'].lower() in ['true', '1', 'yes'],\n            }\n            \n            # Handle optional fields\n            if row['height'].strip():\n                processed_row['height'] = float(row['height'])\n            \n            # Process allergies (split by comma if present)\n            if row['allergies'].strip():\n                processed_row['allergies'] = [a.strip() for a in row['allergies'].split(',')]\n            \n            # Build contact info\n            contact_info = {}\n            if row['phone'].strip():\n                contact_info['phone'] = row['phone'].strip()\n            if row['email'].strip():\n                contact_info['email'] = row['email'].strip()\n            if contact_info:\n                processed_row['contact_info'] = contact_info\n            \n            # Blood type\n            if row['blood_type'].strip():\n                processed_row['blood_type'] = row['blood_type'].strip()\n            \n            # Create Patient object (this will validate everything)\n            patient = Patient(**processed_row)\n            successful_patients.append(patient)\n            print(f\"✅ Row {row_num}: Successfully processed {patient.name}\")\n            \n        except ValidationError as e:\n            error_msg = str(e).split('\\n')[0]  # Get first error line\n            failed_records.append({'row': row_num, 'data': row, 'error': error_msg})\n            print(f\"❌ Row {row_num}: Validation failed - {error_msg}\")\n        except Exception as e:\n            failed_records.append({'row': row_num, 'data': row, 'error': str(e)})\n            print(f\"❌ Row {row_num}: Processing failed - {e}\")\n    \n    return successful_patients, failed_records\n\nprint(\"\\n📊 Processing CSV Data with Pydantic Validation\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n\n📊 Processing CSV Data with Pydantic Validation\n```\n:::\n\n```{.python .cell-code}\nprint(\"=\" * 55)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n=======================================================\n```\n:::\n\n```{.python .cell-code}\nsuccessful, failed = process_csv_data(csv_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n✅ Row 1: Successfully processed john doe\n✅ Row 2: Successfully processed JANE SMITH\n❌ Row 3: Validation failed - 1 validation error for Patient\n✅ Row 4: Successfully processed invalid patient\n✅ Row 5: Successfully processed mary johnson\n```\n:::\n\n```{.python .cell-code}\nprint(f\"\\n📈 Summary:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n\n📈 Summary:\n```\n:::\n\n```{.python .cell-code}\nprint(f\"✅ Successfully processed: {len(successful)} patients\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n✅ Successfully processed: 4 patients\n```\n:::\n\n```{.python .cell-code}\nprint(f\"❌ Failed to process: {len(failed)} records\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n❌ Failed to process: 1 records\n```\n:::\n\n```{.python .cell-code}\nif successful:\n    print(f\"\\n👥 Successfully Imported Patients:\")\n    for patient in successful:\n        print(f\"   🏥 {patient.get_summary()}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nAttributeError: 'Patient' object has no attribute 'get_summary'\n```\n:::\n\n```{.python .cell-code}\nif failed:\n    print(f\"\\n⚠️ Failed Records (need manual review):\")\n    for failure in failed:\n        print(f\"   Row {failure['row']}: {failure['data']['name']} - {failure['error']}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n\n⚠️ Failed Records (need manual review):\n   Row 3: bob wilson - 1 validation error for Patient\n```\n:::\n:::\n\n\n## Saving and Loading with JSON Schema\n\nPydantic can also generate JSON schemas and work seamlessly with JSON data:\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport json\nfrom datetime import datetime\n\n# Generate JSON schema for our Patient model\npatient_schema = Patient.model_json_schema()\n\nprint(\"📋 Patient Model JSON Schema:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n📋 Patient Model JSON Schema:\n```\n:::\n\n```{.python .cell-code}\nprint(\"=\" * 35)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n===================================\n```\n:::\n\n```{.python .cell-code}\nprint(json.dumps(patient_schema, indent=2)[:500] + \"...\\n(truncated)\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n{\n  \"properties\": {\n    \"patient_id\": {\n      \"title\": \"Patient Id\",\n      \"type\": \"string\"\n    },\n    \"name\": {\n      \"title\": \"Name\",\n      \"type\": \"string\"\n    },\n    \"age\": {\n      \"title\": \"Age\",\n      \"type\": \"integer\"\n    },\n    \"weight\": {\n      \"title\": \"Weight\",\n      \"type\": \"number\"\n    },\n    \"married\": {\n      \"title\": \"Married\",\n      \"type\": \"boolean\"\n    },\n    \"allergies\": {\n      \"items\": {\n        \"type\": \"string\"\n      },\n      \"title\": \"Allergies\",\n      \"type\": \"array\"\n   ...\n(truncated)\n```\n:::\n\n```{.python .cell-code}\n# Save all our patients to JSON with timestamp\ndef save_patients_with_metadata(filename: str = \"patients_database.json\"):\n    data = {\n        'timestamp': datetime.now().isoformat(),\n        'total_patients': len(db),\n        'schema_version': '1.0',\n        'patients': [patient.model_dump() for patient in db]\n    }\n    \n    with open(filename, 'w') as f:\n        json.dump(data, f, indent=2)\n    \n    print(f\"💾 Saved {len(db)} patients to {filename}\")\n    return filename\n\n# Load patients from JSON with validation\ndef load_patients_with_validation(filename: str = \"patients_database.json\"):\n    global db\n    try:\n        with open(filename, 'r') as f:\n            data = json.load(f)\n        \n        print(f\"📖 Loading database from {filename}\")\n        print(f\"   📅 Saved on: {data['timestamp']}\")\n        print(f\"   👥 Expected patients: {data['total_patients']}\")\n        \n        # Validate and load each patient\n        loaded_patients = []\n        for patient_data in data['patients']:\n            try:\n                patient = Patient(**patient_data)\n                loaded_patients.append(patient)\n            except ValidationError as e:\n                print(f\"   ❌ Failed to load patient {patient_data.get('name', 'Unknown')}: {e}\")\n        \n        db = loaded_patients\n        print(f\"   ✅ Successfully loaded {len(db)} patients\")\n        \n    except FileNotFoundError:\n        print(f\"❌ File {filename} not found\")\n    except json.JSONDecodeError as e:\n        print(f\"❌ Invalid JSON in {filename}: {e}\")\n    except Exception as e:\n        print(f\"❌ Error loading database: {e}\")\n\n# Save current database\nfilename = save_patients_with_metadata()\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n💾 Saved 2 patients to patients_database.json\n```\n:::\n\n```{.python .cell-code}\n# Clear database and reload to test\noriginal_db = db.copy()\ndb = []\nprint(f\"\\n🗑️ Cleared database (now has {len(db)} patients)\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n\n🗑️ Cleared database (now has 0 patients)\n```\n:::\n\n```{.python .cell-code}\n# Reload\nload_patients_with_validation(filename)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n📖 Loading database from patients_database.json\n   📅 Saved on: 2025-09-26T21:19:32.325143\n   👥 Expected patients: 2\n   ✅ Successfully loaded 2 patients\n```\n:::\n\n```{.python .cell-code}\nprint(f\"🔄 Reloaded database (now has {len(db)} patients)\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n🔄 Reloaded database (now has 2 patients)\n```\n:::\n\n```{.python .cell-code}\n# Verify data integrity\nprint(f\"\\n🔍 Data Integrity Check:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n\n🔍 Data Integrity Check:\n```\n:::\n\n```{.python .cell-code}\nif len(original_db) == len(db):\n    print(\"✅ Patient count matches\")\n    for orig, loaded in zip(original_db, db):\n        if orig.model_dump() == loaded.model_dump():\n            print(f\"   ✅ {orig.name} data matches perfectly\")\n        else:\n            print(f\"   ❌ {orig.name} data mismatch detected\")\nelse:\n    print(f\"❌ Patient count mismatch: original {len(original_db)}, loaded {len(db)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n✅ Patient count matches\n   ✅ Rashed data matches perfectly\n   ✅ Rashed data matches perfectly\n```\n:::\n:::\n\n\n## Summary: The Power of Pydantic\n\nThroughout this journey, we've seen how Pydantic transforms our approach to data handling:\n\n### 🎯 **Key Benefits We've Demonstrated:**\n\n1.  **🛡️ Automatic Validation**: No more manual type checking - Pydantic does it automatically\n2.  **🔄 Type Coercion**: Smart conversion of compatible types (string \"55\" → float 55.0)\n3.  **📝 Clear Error Messages**: Helpful validation errors that pinpoint exactly what's wrong\n4.  **🎨 Clean Code**: Models serve as documentation and enforce data contracts\n5.  **🔧 Flexibility**: Optional fields, default values, and custom validators\n6.  **🌐 JSON Integration**: Seamless serialization/deserialization with validation\n7.  **📊 Real-world Ready**: Handles complex data scenarios like CSV imports\n\n### 🚀 **From Simple to Sophisticated:**\n\n-   Started with basic type hints (limited enforcement)\n-   Added manual validation (not scalable)\n-   Introduced Pydantic models (automatic validation)\n-   Enhanced with optional fields and custom validators\n-   Integrated with real data processing (CSV, JSON)\n-   Built a complete data management system\n\n### 💡 **When to Use Pydantic:**\n\n-   **API Development**: Validate request/response data\n-   **Data Processing**: Clean and validate CSV/JSON imports\n-   **Configuration Management**: Validate application settings\n-   **Database Models**: Ensure data integrity before persistence\n-   **Microservices**: Validate inter-service communication\n\nPydantic transforms unreliable, error-prone data handling into robust, self-documenting, and maintainable code. It's not just about validation - it's about building confidence in your data throughout your entire application! 🎉\n",
    "supporting": [
      "panda_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}