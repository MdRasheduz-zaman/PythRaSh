{
  "hash": "e8cd842947d497351c51a57b4ea18903",
  "result": {
    "markdown": "---\ntitle: \"Basic R\"\nabstract: \"Data types, variables, vectors, data frame, functions\"\n---\n\n```{=html}\n<style>\n  .content {\n    text-align: justify !important;\n  }\n  p {\n    text-align: justify !important;\n  }\n  .quarto-body {\n    text-align: justify !important;\n  }\n</style>\n```\n\n\n\n\n# L2: Data Representation\n\n## Using R as a Calculator\n\nLet's do some basic calculation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n5+3\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 8\n```\n:::\n\n```{.r .cell-code}\n3+2\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 5\n```\n:::\n\n```{.r .cell-code}\n3-2\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 1\n```\n:::\n\n```{.r .cell-code}\n3*2\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 6\n```\n:::\n\n```{.r .cell-code}\n3/2 #normal division\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 1.5\n```\n:::\n\n```{.r .cell-code}\n7 %/% 2 #integer division, only the quotient\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 3\n```\n:::\n\n```{.r .cell-code}\n5 %% 3 #modulus division, the remainder\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 2\n```\n:::\n\n```{.r .cell-code}\n(10-5)*(2+4) #use of parentheses\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 30\n```\n:::\n\n```{.r .cell-code}\n10-5*2+4 #Noticed BODMAS?\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 4\n```\n:::\n\n```{.r .cell-code}\n(10-5)*(2+4) #Noticed BODMAS\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 30\n```\n:::\n\n```{.r .cell-code}\n7/(1+3); 7/1+3 #multi-line codes, separated with semi-colon\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 1.75\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 10\n```\n:::\n\n```{.r .cell-code}\n1+2; log(1); 1/10 #more multi-line codes\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 3\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 0\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 0.1\n```\n:::\n:::\n\n\n## Variables\n\nVariables are variable. We have freedom to name them as we wish. But make any variable name meaningful and identifiable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 5 #assign value 5 to a \nb = 10\na\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 5\n```\n:::\n\n```{.r .cell-code}\nb\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 10\n```\n:::\n\n```{.r .cell-code}\na <- a + 10\nb = b + 15\na\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 15\n```\n:::\n\n```{.r .cell-code}\na^2 #a squared\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 225\n```\n:::\n\n```{.r .cell-code}\na**2 #a squared again, in a different way.\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 225\n```\n:::\n\n```{.r .cell-code}\na^3 #a qubed\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 3375\n```\n:::\n:::\n\n\n::: callout-note\n`<-` and `=` are used to assign values. It is not mathematical equality. `b <- b + 15` might make better sense than `b = b + 15`.\n:::\n\n### Integer and Modulus division again\n\nDo some more practice.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n7/3\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 2.333333\n```\n:::\n\n```{.r .cell-code}\n7%/%3\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 2\n```\n:::\n\n```{.r .cell-code}\n7%%3\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 1\n```\n:::\n:::\n\n\n## Rounding\n\nSome important functions we apply on numerical values\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 9/4\nfloor(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 2\n```\n:::\n\n```{.r .cell-code}\nceiling(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nround(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 2\n```\n:::\n\n```{.r .cell-code}\nround(x, 2) #round till 2 decimal points\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 2.25\n```\n:::\n:::\n\n\n## Logical Operations\n\nGet to know TRUE/FALSE in R.\n\n\n::: {.cell}\n\n```{.r .cell-code}\na = 5\nb = 7\nc = 10\nd = 3\na == b #is a equal to b? Ans: No/FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\na != b #is a not equal to b? Ans: Yes/TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\na > b #is a greater than b? Ans: FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\na < b #is a less than b? Ans: TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\na >= b #is a greater than or equal to b? Ans: FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\na <= b #is a less than or equal to b? Ans: TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\na < b | d > b #is a less than b OR d greater than b?\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n#It's answer will be TRUE OR FALSE --> So, TRUE\na < b & c > d #is a less than b AND a greater than b? It's answer will be TRUE AND TRUE --> So, TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\na < b & d > c #is a less than b AND a greater than b? It's answer will be TRUE AND FALSE --> So, FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] FALSE\n```\n:::\n:::\n\n\n## Help and Documentation\n\nBut how to know more about a function? The package/library developer have written helpful documentation for us.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?log\nexample(log)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n\nlog> log(exp(3))\n[1] 3\n\nlog> log10(1e7) # = 7\n[1] 7\n\nlog> x <- 10^-(1+2*1:9)\n\nlog> cbind(deparse.level=2, # to get nice column names\nlog+       x, log(1+x), log1p(x), exp(x)-1, expm1(x))\n          x   log(1 + x)     log1p(x)   exp(x) - 1     expm1(x)\n [1,] 1e-03 9.995003e-04 9.995003e-04 1.000500e-03 1.000500e-03\n [2,] 1e-05 9.999950e-06 9.999950e-06 1.000005e-05 1.000005e-05\n [3,] 1e-07 1.000000e-07 1.000000e-07 1.000000e-07 1.000000e-07\n [4,] 1e-09 1.000000e-09 1.000000e-09 1.000000e-09 1.000000e-09\n [5,] 1e-11 1.000000e-11 1.000000e-11 1.000000e-11 1.000000e-11\n [6,] 1e-13 9.992007e-14 1.000000e-13 9.992007e-14 1.000000e-13\n [7,] 1e-15 1.110223e-15 1.000000e-15 1.110223e-15 1.000000e-15\n [8,] 1e-17 0.000000e+00 1.000000e-17 0.000000e+00 1.000000e-17\n [9,] 1e-19 0.000000e+00 1.000000e-19 0.000000e+00 1.000000e-19\n```\n:::\n\n```{.r .cell-code}\n?log()\n```\n:::\n\n\n## Working with Vectors\n\nWhat is a vector? See the example and think.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 2, 3, 4, 5) #c means concatenate\nz <- 1:5 #consecutively, from 1 through 5. A short-hand notation using :\ny <- c(3, 6, 9, 12, 15, 20)\nlength(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 5\n```\n:::\n\n```{.r .cell-code}\nmode(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"numeric\"\n```\n:::\n\n```{.r .cell-code}\nis(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"numeric\" \"vector\" \n```\n:::\n\n```{.r .cell-code}\nx[1] #first entry in vector y\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 1\n```\n:::\n\n```{.r .cell-code}\nx[2:5] #2nd to 5th entries in vector y\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 2 3 4 5\n```\n:::\n\n```{.r .cell-code}\nDNA <- c(\"A\", \"T\", \"G\", \"C\") #character vector. Notice the quotation marks.\ndec <- c(10.0, 20.5, 30, 60, 80.9, 90, 100.7, 50, 40, 45, 48, 56, 55) #vector of floats. All numbers became floats, it's called coercion\ndec[c(1:3, 7:length(dec))] #1st to 3rd and then 7th till the end of vector `dec`. Output as a vector.\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n [1]  10.0  20.5  30.0 100.7  50.0  40.0  45.0  48.0  56.0  55.0\n```\n:::\n:::\n\n\n### Vector Operations\n\nNotice the element-wise or index-wise mathematical operations (`+`, `/`, `log2()`, `round()`, etc.). Noticed?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:10\ny <- 2:11\n#x and y are of same length\nx + y\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n [1]  3  5  7  9 11 13 15 17 19 21\n```\n:::\n\n```{.r .cell-code}\ny / x\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n [1] 2.000000 1.500000 1.333333 1.250000 1.200000 1.166667 1.142857 1.125000\n [9] 1.111111 1.100000\n```\n:::\n\n```{.r .cell-code}\nlog2(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n [1] 0.000000 1.000000 1.584963 2.000000 2.321928 2.584963 2.807355 3.000000\n [9] 3.169925 3.321928\n```\n:::\n\n```{.r .cell-code}\nround(log2(x), 1) #log2 of all the values of `x`, 1 digit after decimal to round.\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n [1] 0.0 1.0 1.6 2.0 2.3 2.6 2.8 3.0 3.2 3.3\n```\n:::\n\n```{.r .cell-code}\nround(log2(x), 3) #same logic\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n [1] 0.000 1.000 1.585 2.000 2.322 2.585 2.807 3.000 3.170 3.322\n```\n:::\n:::\n\n\n::: callout-note\nNested functions work inside out. Think again about `round(log2(x), 1)` and you will see it. At first, it is making `log2` of vector `x` and then it is rounding the log2 values to one digit after decimal. Got it?\n:::\n\n## Data Frame\n\nNow, it's time to use vectors to make data sets.....\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames <- c(\"Mina\", \"Raju\", \"Mithu\", \"Lali\")\ngender <- c(\"Female\", \"Male\", \"Female\", \"Female\")\nage <- c(15, 12, 2, 3)\nis_human <- c(TRUE, TRUE, FALSE, FALSE)\ncartoon <- data.frame(names, gender, age, is_human)\nwrite.table(cartoon, \"cartoon.csv\", sep = \",\", col.names = TRUE)\ndf <- read.table(\"cartoon.csv\", header = TRUE, sep = \",\")\ndim(df) #`dim` means dimension. so, rows * columns\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 4 4\n```\n:::\n\n```{.r .cell-code}\nstr(df) #structure of `df`\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n'data.frame':\t4 obs. of  4 variables:\n $ names   : chr  \"Mina\" \"Raju\" \"Mithu\" \"Lali\"\n $ gender  : chr  \"Female\" \"Male\" \"Female\" \"Female\"\n $ age     : int  15 12 2 3\n $ is_human: logi  TRUE TRUE FALSE FALSE\n```\n:::\n:::\n\n\nWe made the vectors first, and the used them to make the `cartton` data frame or table. We learned how to export the data frame using write.table function. Also, we learned to import or read back the table using `read.table` function. What are the `sep`, `col.names`, `header` arguments there? Why do we need them? Think. Try thinking of different properties of a data set.\n\n### Gene Expression Table\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngene_expr <- data.frame(\n  genes = c(\"TP53\", \"BRCA1\", \"MYC\", \"EGFR\", \"GAPDH\", \"CDC2\"),\n  sample1 = c(8.2, 6.1, 9.5, 7.0, 10.0, 12),\n  Sample2 = c(5.9, 3.9, 7.2, 4.8, 7.9, 9),\n  Sample3 = c(8.25, 6.15, 9.6, 7.1, 10.1, 11.9),\n  pathways = c(\"Apoptosis\", \"DNA Repair\", \"Cell Cycle\", \"Signaling\", \"Housekeeping\", \"Cell Division\")\n)\nwrite.table(gene_expr, \"gene_expr.csv\", sep = \",\", col.names = TRUE)\ngene_set <- read.table(\"gene_expr.csv\", header = TRUE, sep = \",\")\n```\n:::\n\n\n::: callout-note\nHere, we directly used the vectors as different columns while making the data frame. Did you notice that? Also, the syntax is different here. We can't assign the vectors with the assignment operator (means we can't use `<-` sign. We have to use the `=` sign). Try using the `<-` sign. Did you notice the column names?\n:::\n\n## Homeworks\n\n1. Compute the difference between this year (2025) and the year you started at the university and divide this by the difference between this year and the year you were born. Multiply this with 100 to get the percentage of your life you have spent at the university.\n\n2. Make different kinds of variables and vectors with the data types we learned together.\n\n3. What are the properties of a data frame?\n\n  Hint: Open an excel/csv/txt file you have and try to \"generalize\".\n\n4. Can you make logical questions on the 2 small data sets we used? Try. It will help you understanding the logical operations we tried on variables. Now we are going to apply them on vectors (columns) on the data sets. For example, in the `cartoon` data set, we can ask/try to subset the data set filtering for females only, or for both females and age greater than 2 years.\n\n5. If you are writing or practicing coding in R, write comment for each line on what it is doing. It will help to chunk it better into your brain.\n\n6. Push the script and/or your answers to the questions (with your solutions) to one of your GitHub repo (and send me the repo link).\n\n### Deadline\n\n**Friday, 10pm BD Time.**\n\n# L3: Data Transformation\n\nFirstly, how did you solve the problems?\n\nGive me your personal Mindmap. Please, send it in the chat!\n\n## Getting Started\n\n### Installation of R Markdown\n\nWe will use `rmarkdown` to have the flexibility of writing codes like the one you are reading now. If you haven't installed the `rmarkdown` package yet, you can do so with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Install rmarkdown package\n#install.packages(\"rmarkdown\")\nlibrary(rmarkdown)\n# Other useful packages we might use\n#install.packages(\"dplyr\")    # Data manipulation\nlibrary(dplyr)\n#install.packages(\"readr\")    # Reading CSV files\nlibrary(readr)\n```\n:::\n\n\nRemove the hash sign before the `install.packages(\"rmarkdown\")`, `install.packages(\"dplyr\")`, `install.packages(\"readr\")` if the library loading fails. That means the package is not there to be loaded. We need to download/install first.\n\n::: callout-note\n[Do you remember this book by Hadley Wickham?](https://r4ds.had.co.nz). Try to follow it to get the hold on the basic R syntax and lexicon.\n:::\n\n### Basic Setup for Today's Session\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Clear environment\nrm(list = ls())\n\n# Check working directory\ngetwd()\n\n# Set working directory if needed\n# setwd(\"path/to/your/directory\")  # Uncomment and modify as needed\n```\n:::\n\n\n### Building on Last HW:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncartoon <- data.frame(\n  names = c(\"Mina\", \"Raju\", \"Mithu\", \"Lali\"),\n  gender = c(\"Female\", \"Male\", \"Female\", \"Female\"),\n  age = c(15, 12, 2, 3),\n  is_human = c(TRUE, TRUE, FALSE, FALSE)\n)\ncartoon\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n  names gender age is_human\n1  Mina Female  15     TRUE\n2  Raju   Male  12     TRUE\n3 Mithu Female   2    FALSE\n4  Lali Female   3    FALSE\n```\n:::\n\n```{.r .cell-code}\ndim(cartoon)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 4 4\n```\n:::\n\n```{.r .cell-code}\nstr(cartoon)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n'data.frame':\t4 obs. of  4 variables:\n $ names   : chr  \"Mina\" \"Raju\" \"Mithu\" \"Lali\"\n $ gender  : chr  \"Female\" \"Male\" \"Female\" \"Female\"\n $ age     : num  15 12 2 3\n $ is_human: logi  TRUE TRUE FALSE FALSE\n```\n:::\n\n```{.r .cell-code}\nlength(cartoon$names)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 4\n```\n:::\n\n```{.r .cell-code}\n##subseting\ncartoon[1:2, 2:3] #row 1-2, column 2-3\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n  gender age\n1 Female  15\n2   Male  12\n```\n:::\n\n```{.r .cell-code}\ncartoon[c(1, 3), c(1:3)] #row 1-3, column 1-3\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n  names gender age\n1  Mina Female  15\n3 Mithu Female   2\n```\n:::\n\n```{.r .cell-code}\n#condition for selecting only male characters\nmale_df <- cartoon[cartoon$gender == \"Male\", ]\nmale_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n  names gender age is_human\n2  Raju   Male  12     TRUE\n```\n:::\n\n```{.r .cell-code}\n#condition for selecting female characters with age more than 2 years\nfemale_age <- cartoon[cartoon$gender == \"Female\" & cartoon$age > 2, ]\nfemale_age\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n  names gender age is_human\n1  Mina Female  15     TRUE\n4  Lali Female   3    FALSE\n```\n:::\n\n```{.r .cell-code}\nsum(female_age$age) #sum of age of female_age dataset\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 18\n```\n:::\n\n```{.r .cell-code}\nsd(cartoon$age) #standard deviation of age of main cartoon dataset\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 6.480741\n```\n:::\n\n```{.r .cell-code}\nmean(cartoon$age) #mean of age of main cartoon dataset\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 8\n```\n:::\n:::\n\n\n[Check your colleague's repo for the Q3](https://github.com/atiyashehreen/hw_repo3/blob/main/propertiesofdataframe.txt).\n\n**Logical Operators**\n\n| Operator | Meaning          | Example          |\n|----------|------------------|------------------|\n| `==`     | Equal to         | `x == 5`         |\n| `!=`     | Not equal        | `x != 5`         |\n| `<`      | Less than        | `x < 5`          |\n| `>`      | Greater than     | `x > 5`          |\n| `<=`     | Less or equal    | `x <= 5`         |\n| `>=`     | Greater or equal | `x >= 5`         |\n| `!`      | Not              | `!(x < 5)`       |\n| `|`      | OR               | `x < 5 | x > 10` |\n| `&`      | AND              | `x > 5 & x < 10` |\n\n### Preamble on random variables (RV):\n\nRV is so fundamental of an idea to interpret and do better in any kind of data analyses. But what is it? Let's imagine this scenario first. You got 30 mice to do an experiment to check anti-diabetic effect of a plant extract. You randomly assigned them into 3 groups. `control`, `treat1` (meaning insulin receivers), and `treat2` (meaning your plant extract receivers). Then you kept testing and measuring. You have mean glucose level of every mouse and show whether the mean value of `treat1` is equal to `treat2` or not. So, are you done? Not really. Be fastidious about the mice. What if you got some other 30 mice? Are they the same? Will their mean glucose level be the same? No, right. We would end up with different mean value. We call this type of quantities RV. Mean, Standard deviation, median, variance, etc. all are RVs. Do you see the logic? That's why we put this constraint and look for p-value, confidence interval (or CI), etc. by (null) hypothesis testing and sample distribution analyses. We will get into these stuffs later. But let's check what I meant. Also ponder about `sample` vs `population`.\n\nLet's download the data first.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Download small example dataset\ndownload.file(\"https://raw.githubusercontent.com/genomicsclass/dagdata/master/inst/extdata/femaleControlsPopulation.csv\",\n              destfile = \"mice.csv\")\n\n# Load data\nmice <- read.csv(\"mice.csv\")\n```\n:::\n\n\nLet's check now.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncontrol <- sample(mice$Bodyweight,12)\nmean(control)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 23.64417\n```\n:::\n\n```{.r .cell-code}\ncontrol1 <- sample(mice$Bodyweight,12)\nmean(control1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 23.06\n```\n:::\n\n```{.r .cell-code}\ncontrol2 <- sample(mice$Bodyweight,12)\nmean(control2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 23.005\n```\n:::\n:::\n\n\nDo you see the difference in the mean value now?\n\n### Basic Stuffs: Atomic Vector\n\n\n::: {.cell}\n\n```{.r .cell-code}\natomic_vec <- c(Human=0.5, Mouse=0.33)\n```\n:::\n\n\nIt is fast, but has limited access methods.\n\nHow to access elements here?\n\n\n::: {.cell}\n\n```{.r .cell-code}\natomic_vec[\"Human\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nHuman \n  0.5 \n```\n:::\n\n```{.r .cell-code}\natomic_vec[\"Mouse\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nMouse \n 0.33 \n```\n:::\n:::\n\n\n### Basic Stuffs: Matrices\n\nMatrices are essential for biologists working with expression data, distance matrices, and other numerical data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a gene expression matrix: rows=genes, columns=samples\nexpr_matrix <- matrix(\n  c(12.3, 8.7, 15.2, 6.8,\n    9.5, 11.2, 13.7, 7.4,\n    5.6, 6.8, 7.9, 6.5),\n  nrow = 3, ncol = 4, byrow = TRUE\n)\n\n# Add dimension names\nrownames(expr_matrix) <- c(\"BRCA1\", \"TP53\", \"GAPDH\")\ncolnames(expr_matrix) <- c(\"Control_1\", \"Control_2\", \"Treatment_1\", \"Treatment_2\")\nexpr_matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n      Control_1 Control_2 Treatment_1 Treatment_2\nBRCA1      12.3       8.7        15.2         6.8\nTP53        9.5      11.2        13.7         7.4\nGAPDH       5.6       6.8         7.9         6.5\n```\n:::\n\n```{.r .cell-code}\n# Matrix dimensions\ndim(expr_matrix)       # Returns rows and columns\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 3 4\n```\n:::\n\n```{.r .cell-code}\nnrow(expr_matrix)      # Number of rows\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nncol(expr_matrix)      # Number of columns\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 4\n```\n:::\n\n```{.r .cell-code}\n# Matrix subsetting\nexpr_matrix[2, ]       # One gene, all samples\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n  Control_1   Control_2 Treatment_1 Treatment_2 \n        9.5        11.2        13.7         7.4 \n```\n:::\n\n```{.r .cell-code}\nexpr_matrix[, 3:4]     # All genes, treatment samples only\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n      Treatment_1 Treatment_2\nBRCA1        15.2         6.8\nTP53         13.7         7.4\nGAPDH         7.9         6.5\n```\n:::\n\n```{.r .cell-code}\nexpr_matrix[\"TP53\", c(\"Control_1\", \"Treatment_1\")]  # Specific gene and samples\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n  Control_1 Treatment_1 \n        9.5        13.7 \n```\n:::\n\n```{.r .cell-code}\n# Matrix calculations (useful for bioinformatics)\n# Mean expression per gene\ngene_means <- rowMeans(expr_matrix)\ngene_means\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nBRCA1  TP53 GAPDH \n10.75 10.45  6.70 \n```\n:::\n\n```{.r .cell-code}\n# Mean expression per sample\nsample_means <- colMeans(expr_matrix)\nsample_means\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n  Control_1   Control_2 Treatment_1 Treatment_2 \n   9.133333    8.900000   12.266667    6.900000 \n```\n:::\n\n```{.r .cell-code}\n# Calculate fold change (Treatment vs Control)\ncontrol_means <- rowMeans(expr_matrix[, 1:2])\ntreatment_means <- rowMeans(expr_matrix[, 3:4])\nfold_change <- treatment_means / control_means\nfold_change\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n   BRCA1     TP53    GAPDH \n1.047619 1.019324 1.161290 \n```\n:::\n\n```{.r .cell-code}\n# Matrix visualization\n# Heatmap of expression data\nheatmap(expr_matrix, \n        Colv = NA,         # Don't cluster columns\n        scale = \"row\",     # Scale by row (gene)\n        col = heat.colors(16),\n        main = \"Gene Expression Heatmap\")\n```\n\n::: {.cell-output-display}\n![](firststeps_files/figure-html/matrices-1.png){width=1650}\n:::\n:::\n\n\n#### More Matrix Practice:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Create a simple Gene Expression matrix (RNA-seq style)\n\nGene_Expression <- matrix(c(\n  5.2, 3.1, 8.5,   # Sample 1\n  6.0, 2.8, 7.9    # Sample 2\n), nrow = 2, byrow = TRUE)\n\nrownames(Gene_Expression) <- c(\"Sample_1\", \"Sample_2\")\ncolnames(Gene_Expression) <- c(\"GeneA\", \"GeneB\", \"GeneC\")\n\nprint(\"Gene Expression Matrix:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"Gene Expression Matrix:\"\n```\n:::\n\n```{.r .cell-code}\nprint(Gene_Expression)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n         GeneA GeneB GeneC\nSample_1   5.2   3.1   8.5\nSample_2   6.0   2.8   7.9\n```\n:::\n\n```{.r .cell-code}\n#1. Transpose: Genes become rows, Samples become columns\n\nGene_Expression_T <- t(Gene_Expression)\nprint(\"Transpose of Gene Expression Matrix:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"Transpose of Gene Expression Matrix:\"\n```\n:::\n\n```{.r .cell-code}\nprint(Gene_Expression_T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n      Sample_1 Sample_2\nGeneA      5.2      6.0\nGeneB      3.1      2.8\nGeneC      8.5      7.9\n```\n:::\n\n```{.r .cell-code}\n#2. Matrix multiplication\n# Suppose each gene has an associated \"gene weight\" (e.g., biological importance)\n\nGene_Weights <- matrix(c(0.8, 1.2, 1.0), nrow = 3, byrow = TRUE)\nrownames(Gene_Weights) <- c(\"GeneA\", \"GeneB\", \"GeneC\")\ncolnames(Gene_Weights) <- c(\"Weight\")\n\nTotal_Weighted_Expression <- Gene_Expression %*% Gene_Weights\nprint(\"Total Weighted Expression per Sample:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"Total Weighted Expression per Sample:\"\n```\n:::\n\n```{.r .cell-code}\nprint(Total_Weighted_Expression)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n         Weight\nSample_1  16.38\nSample_2  16.06\n```\n:::\n\n```{.r .cell-code}\n# 3. Matrix addition\n# Hypothetically increase expression by 1 TPM everywhere (technical adjustment)\n\nAdjusted_Expression <- Gene_Expression + 1\nprint(\"Expression Matrix after adding 1 TPM:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"Expression Matrix after adding 1 TPM:\"\n```\n:::\n\n```{.r .cell-code}\nprint(Adjusted_Expression)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n         GeneA GeneB GeneC\nSample_1   6.2   4.1   9.5\nSample_2   7.0   3.8   8.9\n```\n:::\n\n```{.r .cell-code}\n# 4. Identity matrix \nI <- diag(3)\nrownames(I) <- c(\"GeneA\", \"GeneB\", \"GeneC\")\ncolnames(I) <- c(\"GeneA\", \"GeneB\", \"GeneC\")\n\nprint(\"Identity Matrix (for genes):\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"Identity Matrix (for genes):\"\n```\n:::\n\n```{.r .cell-code}\nprint(I)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n      GeneA GeneB GeneC\nGeneA     1     0     0\nGeneB     0     1     0\nGeneC     0     0     1\n```\n:::\n\n```{.r .cell-code}\n# Multiplying Gene Expression by Identity\nIdentity_Check <- Gene_Expression %*% I\nprint(\"Gene Expression multiplied by Identity Matrix:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"Gene Expression multiplied by Identity Matrix:\"\n```\n:::\n\n```{.r .cell-code}\nprint(Identity_Check)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n         GeneA GeneB GeneC\nSample_1   5.2   3.1   8.5\nSample_2   6.0   2.8   7.9\n```\n:::\n\n```{.r .cell-code}\n# 5. Scalar multiplication \n# Suppose you want to simulate doubling expression values\n\nDoubled_Expression <- 2 * Gene_Expression\nprint(\"Doubled Gene Expression:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"Doubled Gene Expression:\"\n```\n:::\n\n```{.r .cell-code}\nprint(Doubled_Expression)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n         GeneA GeneB GeneC\nSample_1  10.4   6.2  17.0\nSample_2  12.0   5.6  15.8\n```\n:::\n\n```{.r .cell-code}\n# 6. Summations \n\n# Total expression per sample\nTotal_Expression_Per_Sample <- rowSums(Gene_Expression)\nprint(\"Total Expression per Sample:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"Total Expression per Sample:\"\n```\n:::\n\n```{.r .cell-code}\nprint(Total_Expression_Per_Sample)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nSample_1 Sample_2 \n    16.8     16.7 \n```\n:::\n\n```{.r .cell-code}\n# Total expression per gene\nTotal_Expression_Per_Gene <- colSums(Gene_Expression)\nprint(\"Total Expression per Gene:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"Total Expression per Gene:\"\n```\n:::\n\n```{.r .cell-code}\nprint(Total_Expression_Per_Gene)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nGeneA GeneB GeneC \n 11.2   5.9  16.4 \n```\n:::\n\n```{.r .cell-code}\n# 7. Simple plots \n\n# Barplot: Total expression per sample\nbarplot(Total_Expression_Per_Sample, main=\"Total Expression per Sample\", ylab=\"TPM\", col=c(\"skyblue\", \"salmon\"))\n```\n\n::: {.cell-output-display}\n![](firststeps_files/figure-html/more-mat-practice-1.png){width=1650}\n:::\n\n```{.r .cell-code}\n# Barplot: Total expression per gene\nbarplot(Total_Expression_Per_Gene, main=\"Total Expression per Gene\", ylab=\"TPM\", col=c(\"lightgreen\", \"orange\", \"violet\"))\n```\n\n::: {.cell-output-display}\n![](firststeps_files/figure-html/more-mat-practice-2.png){width=1650}\n:::\n\n```{.r .cell-code}\n# Heatmap: Expression matrix\nheatmap(Gene_Expression, Rowv=NA, Colv=NA, col=heat.colors(256), scale=\"column\", main=\"Gene Expression Heatmap\")\n```\n\n::: {.cell-output-display}\n![](firststeps_files/figure-html/more-mat-practice-3.png){width=1650}\n:::\n:::\n\n\nAnother Example: You have counts of cells in different organs for two animal species.\n\nYou also have a matrix with average cell sizes (micrometer, ÂµmÂ²) for each organ.\n\nYou can then multiply count Ã— size to get total cell area for each species in each organ.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a matrix: Cell counts\nCell_Counts <- matrix(c(500, 600, 300, 400, 700, 800), nrow = 2, byrow = TRUE)\nrownames(Cell_Counts) <- c(\"Mouse\", \"Rat\")\ncolnames(Cell_Counts) <- c(\"Heart\", \"Liver\", \"Brain\")\n\nprint(\"Cell Counts Matrix:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"Cell Counts Matrix:\"\n```\n:::\n\n```{.r .cell-code}\nprint(Cell_Counts)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n      Heart Liver Brain\nMouse   500   600   300\nRat     400   700   800\n```\n:::\n\n```{.r .cell-code}\n# Create a matrix: Average cell size in ÂµmÂ²\nCell_Size <- matrix(c(50, 200, 150), nrow = 3, byrow = TRUE)\nrownames(Cell_Size) <- c(\"Heart\", \"Liver\", \"Brain\")\ncolnames(Cell_Size) <- c(\"Avg_Cell_Size\")\n\nprint(\"Cell Size Matrix (ÂµmÂ²):\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"Cell Size Matrix (ÂµmÂ²):\"\n```\n:::\n\n```{.r .cell-code}\nprint(Cell_Size)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n      Avg_Cell_Size\nHeart            50\nLiver           200\nBrain           150\n```\n:::\n\n```{.r .cell-code}\n# 1. Transpose of Cell Counts\nCell_Counts_T <- t(Cell_Counts)\nprint(\"Transpose of Cell Counts:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"Transpose of Cell Counts:\"\n```\n:::\n\n```{.r .cell-code}\nprint(Cell_Counts_T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n      Mouse Rat\nHeart   500 400\nLiver   600 700\nBrain   300 800\n```\n:::\n\n```{.r .cell-code}\n# 2. Matrix multiplication: Total cell area\n# (2x3) %*% (3x1) => (2x1)\nTotal_Cell_Area <- Cell_Counts %*% Cell_Size\ncolnames(Total_Cell_Area) <- \"Cell_area\"\nprint(\"Total Cell Area (Counts Ã— Size) (ÂµmÂ²):\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"Total Cell Area (Counts Ã— Size) (ÂµmÂ²):\"\n```\n:::\n\n```{.r .cell-code}\nprint(Total_Cell_Area)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n      Cell_area\nMouse    190000\nRat      280000\n```\n:::\n\n```{.r .cell-code}\n# 3. Matrix addition: Add 10 cells artificially to all counts (for example)\nAdded_Cells <- Cell_Counts + 10\nprint(\"Cell Counts after adding 10 artificial cells:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"Cell Counts after adding 10 artificial cells:\"\n```\n:::\n\n```{.r .cell-code}\nprint(Added_Cells)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n      Heart Liver Brain\nMouse   510   610   310\nRat     410   710   810\n```\n:::\n\n```{.r .cell-code}\n# 4. Identity matrix\nI <- diag(3)\nrownames(I) <- c(\"Heart\", \"Liver\", \"Brain\")\ncolnames(I) <- c(\"Heart\", \"Liver\", \"Brain\")\n\nprint(\"Identity Matrix:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"Identity Matrix:\"\n```\n:::\n\n```{.r .cell-code}\nprint(I)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n      Heart Liver Brain\nHeart     1     0     0\nLiver     0     1     0\nBrain     0     0     1\n```\n:::\n\n```{.r .cell-code}\n# 5. Multiplying Cell Counts by Identity Matrix (no real change but shows dimension rules)\nCheck_Identity <- Cell_Counts %*% I\nprint(\"Cell Counts multiplied by Identity Matrix:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"Cell Counts multiplied by Identity Matrix:\"\n```\n:::\n\n```{.r .cell-code}\nprint(Check_Identity)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n      Heart Liver Brain\nMouse   500   600   300\nRat     400   700   800\n```\n:::\n\n```{.r .cell-code}\n# 6. Scalar multiplication: double the counts (hypothetical growth)\nDouble_Cell_Counts <- 2 * Cell_Counts\nprint(\"Doubled Cell Counts:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"Doubled Cell Counts:\"\n```\n:::\n\n```{.r .cell-code}\nprint(Double_Cell_Counts)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n      Heart Liver Brain\nMouse  1000  1200   600\nRat     800  1400  1600\n```\n:::\n\n```{.r .cell-code}\n# Total number of cells per animal (row sums)\nTotal_Cells_Per_Species <- rowSums(Cell_Counts)\nprint(\"Total number of cells per species:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"Total number of cells per species:\"\n```\n:::\n\n```{.r .cell-code}\nprint(Total_Cells_Per_Species)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nMouse   Rat \n 1400  1900 \n```\n:::\n\n```{.r .cell-code}\n# Total number of cells per organ (column sums)\nTotal_Cells_Per_Organ <- colSums(Cell_Counts)\nprint(\"Total number of cells per organ:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"Total number of cells per organ:\"\n```\n:::\n\n```{.r .cell-code}\nprint(Total_Cells_Per_Organ)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nHeart Liver Brain \n  900  1300  1100 \n```\n:::\n\n```{.r .cell-code}\n# --- Simple plots ---\n\n# Bar plot of total cells per species\nbarplot(Total_Cells_Per_Species, main=\"Total Cell Counts per Species\", ylab=\"Number of Cells\", col=c(\"lightblue\", \"lightgreen\"))\n```\n\n::: {.cell-output-display}\n![](firststeps_files/figure-html/mat-prac-2-1.png){width=1650}\n:::\n\n```{.r .cell-code}\n# Bar plot of total cells per organ\nbarplot(Total_Cells_Per_Organ, main=\"Total Cell Counts per Organ\", ylab=\"Number of Cells\", col=c(\"pink\", \"lightyellow\", \"lightgray\"))\n```\n\n::: {.cell-output-display}\n![](firststeps_files/figure-html/mat-prac-2-2.png){width=1650}\n:::\n\n```{.r .cell-code}\n# Heatmap of the original Cell Counts matrix\nheatmap(Cell_Counts, Rowv=NA, Colv=NA, col=heat.colors(256), scale=\"column\", main=\"Heatmap of Cell Counts\")\n```\n\n::: {.cell-output-display}\n![](firststeps_files/figure-html/mat-prac-2-3.png){width=1650}\n:::\n:::\n\n\n| Operation             | Explanation                   | R Function/Example                 |\n|:-------------------|:--------------------------|:------------------------|\n| Matrix Creation       | Create gene expression matrix | `matrix()`                         |\n| Transpose             | Flip genes and samples        | `t(Gene_Expression)`               |\n| Matrix Multiplication | Calculate weighted sums       | `Gene_Expression %*% Gene_Weights` |\n| Matrix Addition       | Adjust counts                 | `Gene_Expression + 1`              |\n| Identity Matrix       | Special neutral matrix        | `diag(3)`                          |\n| Scalar Multiplication | Simulate overall increase     | `2 * Gene_Expression`              |\n| Row/Column Summation  | Total per sample/gene         | `rowSums()`, `colSums()`           |\n| Plotting              | Visualize expression patterns | `barplot()`, `heatmap()`           |\n\n### Basic Stuffs: List\n\nLists are the most flexible data structure in R - they can hold any combination of data types, including other lists! This makes them essential for biological data analysis where we often deal with mixed data types.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# A list storing different types of genomic data\ngenomics_data <- list(\n  gene_names = c(\"TP53\", \"BRCA1\", \"MYC\"),               # Character vector\n  expression = matrix(c(1.2, 3.4, 5.6, 7.8, 9.1, 2.3), nrow=3),    # Numeric matrix\n  is_cancer_gene = c(TRUE, TRUE, FALSE),                 # Logical vector\n  metadata = list(                                       # Nested list!\n    lab = \"CRG\",\n    date = \"2023-05-01\"\n  )\n)\n```\n:::\n\n\nHow to Access Elements of a List?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Method 1: Double brackets [[ ]] for single element\ngenomics_data[[1]]  # Returns gene_names vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"TP53\"  \"BRCA1\" \"MYC\"  \n```\n:::\n\n```{.r .cell-code}\n# Method 2: $ operator with names (when elements are named)\ngenomics_data$expression  # Returns the matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n     [,1] [,2]\n[1,]  1.2  7.8\n[2,]  3.4  9.1\n[3,]  5.6  2.3\n```\n:::\n\n```{.r .cell-code}\n# Method 3: Single bracket [ ] returns a sublist\ngenomics_data[1:2]  # Returns list with first two elements\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n$gene_names\n[1] \"TP53\"  \"BRCA1\" \"MYC\"  \n\n$expression\n     [,1] [,2]\n[1,]  1.2  7.8\n[2,]  3.4  9.1\n[3,]  5.6  2.3\n```\n:::\n:::\n\n\nKey Difference from Vectors:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Compare to your prop.table() example:\natomic_vec[\"Human\"]    # Returns named numeric (vector)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nHuman \n  0.5 \n```\n:::\n\n```{.r .cell-code}\natomic_vec[\"Mouse\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nMouse \n 0.33 \n```\n:::\n\n```{.r .cell-code}\ngenomics_data[1] # Returns list containing the vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n$gene_names\n[1] \"TP53\"  \"BRCA1\" \"MYC\"  \n```\n:::\n:::\n\n\nWhy Biologists Need Lists?\\\n`lm()`, `prcomp()` functions, RNAseq analysis packages produces list. So, we need to learn how to handle lists.\n\nSee these examples:\n\nA. Storing BLAST results\n\n\n::: {.cell}\n\n```{.r .cell-code}\nblast_hits <- list(\n  query_id = \"GeneX\",\n  hit_ids = c(\"NP_123\", \"NP_456\"),\n  e_values = c(1e-50, 3e-12),\n  alignment = matrix(c(\"ATG...\", \"CTA...\"), ncol=1))\n```\n:::\n\n\nB. Handling Mixed Data\n\n\n::: {.cell}\n\n```{.r .cell-code}\npatient_data <- list(\n  id = \"P1001\",\n  tests = data.frame(\n    test = c(\"WBC\", \"RBC\"),\n    value = c(4.5, 5.1)\n  ),\n  has_mutation = TRUE\n)\n```\n:::\n\n\nCommon List Operations\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Add new element\ngenomics_data$sequencer <- \"Illumina\"\n\n# Remove element\ngenomics_data$is_cancer_gene <- NULL\n\n# Check structure (critical for complex lists)\nstr(genomics_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nList of 4\n $ gene_names: chr [1:3] \"TP53\" \"BRCA1\" \"MYC\"\n $ expression: num [1:3, 1:2] 1.2 3.4 5.6 7.8 9.1 2.3\n $ metadata  :List of 2\n  ..$ lab : chr \"CRG\"\n  ..$ date: chr \"2023-05-01\"\n $ sequencer : chr \"Illumina\"\n```\n:::\n:::\n\n\nBy the way, how would you add more patients?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Add new patient\npatient_data$P1002 <- list(\n  id = \"P1002\",\n  tests = data.frame(\n    test = c(\"WBC\", \"RBC\", \"Platelets\"),\n    value = c(6.2, 4.8, 150)\n  ),\n  has_mutation = FALSE\n)\n# Access specific patient\npatient_data$P1001$test\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nNULL\n```\n:::\n:::\n\n\nFor Batch Processing:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npatients <- list(\n  list(\n    id = \"P1001\",\n    tests = data.frame(test = c(\"WBC\", \"RBC\"), value = c(4.5, 5.1)),\n    has_mutation = TRUE\n  ),\n  list(\n    id = \"P1002\",\n    tests = data.frame(test = c(\"WBC\", \"RBC\", \"Platelets\"), value = c(6.2, 4.8, 150)),\n    has_mutation = FALSE\n  )\n)\n\n# Access 2nd patient's WBC value\npatients[[2]]$tests$value[patients[[2]]$tests$test == \"WBC\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 6.2\n```\n:::\n:::\n\n\nConverting Between Structures\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# List â†’ Vector\nunlist(genomics_data[1:3])\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n  gene_names1   gene_names2   gene_names3   expression1   expression2 \n       \"TP53\"       \"BRCA1\"         \"MYC\"         \"1.2\"         \"3.4\" \n  expression3   expression4   expression5   expression6  metadata.lab \n        \"5.6\"         \"7.8\"         \"9.1\"         \"2.3\"         \"CRG\" \nmetadata.date \n \"2023-05-01\" \n```\n:::\n:::\n\n\nVisualization\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Base R plot from list data\nbarplot(unlist(genomics_data[2]),\n        names.arg = genomics_data[[1]])\n```\n:::\n\n\nThis code won't work if you run. `unlist(genomics_data[2]` creates a vector of length 6 from our 3\\*2 matrix but `genomics_data[[1]]` has 3 things inside the `gene_names` vector. Debug like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(genomics_data$expression)  # e.g., 2 rows x 2 cols\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 3 2\n```\n:::\n\n```{.r .cell-code}\nlength(genomics_data$gene_names) # e.g., 3 genes\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 3\n```\n:::\n:::\n\n\nA. Gene-Centric (Mean Expression)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbarplot(rowMeans(genomics_data$expression),\n        names.arg = genomics_data$gene_names,\n        col = \"steelblue\",\n        ylab = \"Mean Expression\",\n        main = \"Average Gene Expression\")\n```\n\n::: {.cell-output-display}\n![](firststeps_files/figure-html/unnamed-chunk-19-1.png){width=1650}\n:::\n:::\n\n\nB. Sample-Centric (All Measurements)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbarplot(genomics_data$expression,\n        beside = TRUE,\n        names.arg = paste0(\"Sample_\", 1:ncol(genomics_data$expression)),\n        legend.text = genomics_data$gene_names,\n        args.legend = list(x = \"topright\", bty = \"n\"),\n        col = c(\"blue\", \"red\", \"green\"),\n        main = \"Expression Across Samples\")\n```\n\n::: {.cell-output-display}\n![](firststeps_files/figure-html/unnamed-chunk-20-1.png){width=1650}\n:::\n:::\n\n\n::: callout-note\nThis matches real-world scenarios:\n\nRNA-seq: Rows=genes, cols=samples\n\nrowMeans() = average expression per gene\n\nbeside=TRUE => compare samples within genes\n\nProteomics: Rows=proteins, cols=replicates\n\nSame principles apply\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate stats\ngene_means <- rowMeans(genomics_data$expression)\ngene_sds <- apply(genomics_data$expression, 1, sd)\n\n# Plot with error bars\nbp <- barplot(gene_means, ylim = c(0, max(gene_means + gene_sds)))\narrows(bp, gene_means - gene_sds, bp, gene_means + gene_sds, \n       angle = 90, code = 3)\n```\n\n::: {.cell-output-display}\n![](firststeps_files/figure-html/unnamed-chunk-21-1.png){width=1650}\n:::\n:::\n\n\n**Task: Create a list containing:**\n\ni) A character vector of 3 gene names\n\nii) A numeric matrix of expression values\n\niii) A logical vector indicating pathway membership\n\niv) A nested list with lab metadata\n\n## ðŸ“˜ Homeworks: Matrix and List Operations\n\n### ðŸ§ª Protein Quantification in Biological Samples\n\nYou are given the following protein concentration matrix:\n\n$$\n\\text{ProteinMatrix} =\n\\begin{bmatrix}\n  5 & 3 & 2 \\\\\n  7 & 6 & 4 \\\\\n\\end{bmatrix}\n$$\n\n- Rows represent samples:\n  - Sample1\n  - Sample2\n- Columns represent proteins:\n  - ProteinX\n  - ProteinY\n  - ProteinZ\n\nYou are also given a weight (importance) matrix for the proteins:\n\n$$\n\\text{WeightVector} =\n\\begin{bmatrix}\n  0.5 \\\\\n  1.0 \\\\\n  1.5 \\\\\n\\end{bmatrix}\n$$\n\n### ðŸ”§ Tasks\n\n1. Make the matrices (with exact names) and multiply the ProteinMatrix by the WeightVector.\n\n  That is:\n\n  $$\n  \\text{ProteinMatrix} \\times \\text{WeightVector}\n  $$\n\n2. Transpose the ProteinMatrix and show what it looks like.\n\n3. Create the Identity matrix of compatible size and show what happens when you multiply: $$\n    \\text{ProteinMatrix} \\times I\n    $$\n\n4.Do the calculations (rowSums, colSums, etc.) and visualization (barplot, heatmap) as shown in the class.\n\n### ðŸ§  Interpretation Questions\n\n- What does multiplying the protein levels by the weight vector mean biologically?\n- What does the result tell you about total protein burden (or total protein impact) for each sample?\n- What do the identity matrix represent in the context of protein interactions or measurement biases?\n- If you changed the weight of ProteinZ to 3.0, how would the result change?\n\n### ðŸ§¬ Gene-to-Protein Translation\n\nYou are given the following matrix representing normalized gene expression levels (e.g., TPM): $$\n\\text{GeneExpression} =\n\\begin{bmatrix}\n  10 &  8 &  5 \\\\\n  15 & 12 & 10 \\\\\n\\end{bmatrix}\n$$\n\n- Rows = Samples:\n  - Sample1\n  - Sample2\n- Columns = Genes:\n  - GeneA\n  - GeneB\n  - GeneC\n\nEach gene translates into proteins with a certain efficiency. The efficiency of translation from each gene to its corresponding protein is given by the following diagonal matrix:\n\n$$\n\\text{TranslationMatrix} =\n\\begin{bmatrix}\n  1.5 & 0   & 0 \\\\\n  0   & 1.2 & 0 \\\\\n  0   & 0   & 1.8 \\\\\n\\end{bmatrix}\n$$\n\nThis means:\n\n- GeneA â†’ ProteinA with 1.5Ã— efficiency\\\n- GeneB â†’ ProteinB with 1.2Ã— efficiency\\\n- GeneC â†’ ProteinC with 1.8Ã— efficiency\n\n### ðŸ”§ Tasks\n\n1. Make the matrices and multiply GeneExpression Ã— TranslationMatrix to compute the resulting ProteinMatrix.\n\n  - Show the result step-by-step.\n\n2. Transpose the GeneExpression matrix. What does this new matrix represent?\n\n3. Create the Identity matrix Iâ‚ƒ and multiply it with the TranslationMatrix. What happens?\n\n4. Create a new matrix containing only the expression of GeneA and GeneB across both samples. Call this submatrix A.\n\n  - Compute the inverse Aâ»Â¹ using `solve()` function.\n  - Then verify:\\\n    A Ã— Aâ»Â¹ = Iâ‚‚\n\n\n### ðŸ“Š Visualization Tasks\n\n5. Plot a MARplot-style scatter plot:\n  - x-axis: Gene expression values (GeneExpression matrix, flattened)\n  - y-axis: Corresponding Protein values (ProteinMatrix, flattened)\n  - Label each point as \"Sample-Gene\"\n6.  Generate a heatmap of the ProteinMatrix using Râ€™s `heatmap()` function.\n  - Add meaningful row and column labels.\n  - Enable clustering by rows and columns.\n\n### ðŸ§  Interpretation Questions\n\n- What does matrix multiplication represent biologically in this case?\n- Why does the diagonal TranslationMatrix make sense biologically?\n- What does it mean if Sample2 has higher protein levels even with similar gene expression?\n- How does the MARplot help interpret translation efficiency?\n- How does clustering in the heatmap reveal relationships between samples and proteins?\n\n\n### ðŸ„ Animal Breeding â€“ Economic Ranking of Bulls by Traits\n\nYou are evaluating two bulls for use in a dairy breeding program. Their Estimated Breeding Values (EBVs) are:\n\n$$\n\\text{BullEBVs} =\n\\begin{bmatrix}\n  400 & 1.2 & 0.8 \\\\\\\\\n  500 & 1.5 & 0.6 \\\\\\\\\n\\end{bmatrix}\n$$\n\n-   Rows:\n    -   Bull1\\\n    -   Bull2\n-   Columns:\n    -   Trait1 = Milk yield (liters/year)\\\n    -   Trait2 = Growth rate (kg/day)\\\n    -   Trait3 = Fertility (calving interval adjustment)\n\nYou assign economic weights to each trait:\n\n$$\n\\text{EconomicWeights} =\n\\begin{bmatrix}\n  0.002 \\\\\\\\\n  50 \\\\\\\\\n  100 \\\\\\\\\n\\end{bmatrix}\n$$\n\n### ðŸ”§ Tasks\n\n1. Compute:\n\n  $$\n  \\text{TotalValue} = \\text{BullEBVs} \\times \\text{EconomicWeights}\n  $$\n\n  - What are the resulting values?\n  - Which bull is more valuable economically?\n\n2. Interpret what multiplying by the economic weights means biologically.\n\n3. Create the 3Ã—3 identity matrix Iâ‚ƒ and multiply it with BullEBVs.\n\n  - What does it return?\n  - What does the identity matrix mean in this case?\n\n4. Subset the BullEBVs matrix to remove Trait1 (milk yield) and recalculate TotalValue.\n\n  - How does this change the ranking?\n\n### ðŸ“Š Visualization Tasks\n\n5. Create a bar plot comparing TotalValue for Bull1 and Bull2.\n\n6. Create a heatmap of the EBVs.\n\n  - Label rows and columns.\n  - Enable clustering.\n\n### ðŸ§  Interpretation Questions\n\n- How do economic weights affect trait importance?\n- Why might you ignore milk yield in some breeding programs?\n- What is the value of heatmaps in visualizing multivariate trait data?\n- Can this method be extended to more bulls and more traits?\n\n### ðŸŒ¾ Plant Breeding â€“ Trait Contributions from Parental Lines\n\nYou are breeding a new rice variety from three parental lines. The key traits are:\n\n- T1 = Drought resistance\n- T2 = Yield\n- T3 = Maturation time\n\nThe following trait values (normalized 1â€“10) have been measured:\n\n$$\n\\text{ParentTraits} =\n\\begin{bmatrix}\n  7 & 5 & 3 \\\\\\\\\n  6 & 8 & 4 \\\\\\\\\n  5 & 6 & 6 \\\\\\\\\n\\end{bmatrix}\n$$\n\n- Rows:\n  - P1 (Parent 1)\n  - P2 (Parent 2)\n  - P3 (Parent 3)\n- Columns:\n  - T1 = Drought resistance\n  - T2 = Yield\n  - T3 = Maturation time\n\nYou design a hybrid with contributions from each parent as follows:\n\n$$\n\\text{HybridWeights} =\n\\begin{bmatrix}\n  0.5 \\\\\\\\\n  0.3 \\\\\\\\\n  0.2 \\\\\\\\\n\\end{bmatrix}\n$$\n\n### ðŸ”§ Tasks\n\n1. Compute the HybridTrait vector by:\n\n  $$\n  \\text{HybridTraits} = \\text{HybridWeights}^T \\times \\text{ParentTraits}\n  $$\n\n  Show the steps and result.\n\n2. Explain what it means biologically when one parent contributes more to a particular trait.\n\n3. Create an identity matrix Iâ‚ƒ and multiply it with ParentTraits.\n\n  - What do you observe?\n  - What does I Ã— ParentTraits represent?\n\n4. Subset the ParentTraits matrix to include only T1 and T2. Recalculate the hybrid traits.\n\n  - Discuss how removing a trait affects your outcome.\n\n### ðŸ“Š Visualization Tasks\n\n5. Generate a heatmap of the ParentTraits matrix.\n  - Label the rows with parent names and columns with trait names.\n  - Enable row/column clustering.\n6. Create a bar plot showing the HybridTraits (T1, T2, T3).\n  - Color code each bar by trait.\n  - What trait contributes most?\n\n### ðŸ§  Interpretation Questions\n\n- How does the weighting of parents affect the hybrid's performance?\n- What does the identity matrix represent here?\n- If you used equal weights (â…“ for each), how would the hybrid traits change?\n- What real-world limitations does this simplified model ignore?\n\n### ðŸ§  Managing Matrices and Weight Vectors Using Lists in R\n\nNow that you have completed four biological matrix problems â€” Protein concentration, gene-to-protein mapping, bull breeding value ranking, and plant trait combinations â€” itâ€™s time to organize your data and weights using Râ€™s list structure.\n\nIn this task, you will:\n\n- Group each exampleâ€™s matrix and its corresponding weight vector inside a named list.\n- Combine these named lists into a larger list called bioList.\n- Use list indexing to repeat your earlier calculations and visualizations.\n- Reflect on the benefits and challenges of using structured data objects.\n\n### ðŸ“¦ Step 1: Create a master list\n\nYou should now build a named list called bioList containing the following four elements:\n\n- ProteinConc = list(matrix = ProteinMatrix, weights = WeightVector)\n- ProteinMap = list(matrix = ProteinMapping, weights = TranslationWeights)\n- Plant = list(matrix = ParentTraits, weights = HybridWeights)\n- Animal = list(matrix = BullEBVs, weights = EconomicWeights)\n\nHint: Each inner list should contain both:\n\n- matrix = the main data matrix\n- weights = the vector used for multiplication\n\nNo R code is required here (You have them from previous part, use inside same rmd/notebook file) â€” just structure your data like this in your workspace.\n\n### ðŸ”§ Tasks\n\n1. List the full names of each component in bioList.\n  What are the names of the top-level and nested components?\n\n2. Access each matrix and its corresponding weights using list indexing.\n\n  - How would you extract only the matrix of the Plant entry?\n  - How would you extract the weights for the Protein concentration entry?\n\n3. Use the correct matrix and weights to perform:\n\n  - ProteinConc: Weighted gene expression score\n  - ProteinMap: Contribution of transcripts to each protein\n  - Plant: Hybrid trait values\n  - Animal: Bull total economic value\n\n4. Subset one matrix in each sublist (e.g., drop a trait or feature) and repeat the weighted calculation.\n\n  - What changes in the results?\n  - Which traits/genes have the strongest influence?\n\n### ðŸ“Š Visualization Tasks\n\n5.  Generate one heatmap for any matrix stored in bioList.\n  - Choose one (e.g., ProteinMap or Plant)\n  - Apply clustering to rows and/or columns\n  - Label appropriately\n6. Generate two bar plots:\n  - One showing the result of weighted trait aggregation for the Plant hybrid\n  - One showing the total breeding values for each bull\n\n### ðŸ§  Interpretation Questions\n\n- How does structuring your data using a list help with clarity and reproducibility?\n- What risks or challenges might occur when accessing elements from nested lists?\n- Could this structure be scaled for real datasets with many samples or traits?\n- How would you loop over all elements in bioList to apply the same function?\n- How can this list structure be useful for building automated bioinformatics pipelines?\n\nðŸ“ Your Rmarkdown file(s) should include:\n\n- All matrix calculations (tasks). Also, name the rows and columns of each matrix accordingly.\n- All interpretation answers\n- All plots (output from embedded code)\n- And your commentary blocks for each code chunk\n\n**knit your rmd (or Notebook) file as html/pdf file and push both the rmd (or Notebook) and html/pdf files**\n\n## Factor Variables\n\nImportant for categorical data\n\n### Creating Factors\n\nFactors are used to represent categorical data in R. They are particularly important for biological data like genotypes, phenotypes, and experimental conditions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Simple factor: DNA sample origins\norigins <- c(\"Human\", \"Mouse\", \"Human\", \"Zebrafish\", \"Mouse\", \"Human\")\norigins_factor <- factor(origins, levels = c(\"Human\", \"Zebrafish\", \"Mouse\"))\norigins_factor\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] Human     Mouse     Human     Zebrafish Mouse     Human    \nLevels: Human Zebrafish Mouse\n```\n:::\n\n```{.r .cell-code}\n# Check levels (categories)\nlevels(origins_factor)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"Human\"     \"Zebrafish\" \"Mouse\"    \n```\n:::\n\n```{.r .cell-code}\n# Create a factor with predefined levels\ntreatment_groups <- factor(c(\"Control\", \"Low_dose\", \"High_dose\", \"Control\", \"Low_dose\"),\n                         levels = c(\"Control\", \"Low_dose\", \"High_dose\"))\ntreatment_groups\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] Control   Low_dose  High_dose Control   Low_dose \nLevels: Control Low_dose High_dose\n```\n:::\n\n```{.r .cell-code}\n# Ordered factors (important for severity, stages, etc.)\ndisease_severity <- factor(c(\"Mild\", \"Severe\", \"Moderate\", \"Mild\", \"Critical\"),\n                         levels = c(\"Mild\", \"Moderate\", \"Severe\", \"Critical\"),\n                         ordered = TRUE)\ndisease_severity\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] Mild     Severe   Moderate Mild     Critical\nLevels: Mild < Moderate < Severe < Critical\n```\n:::\n\n```{.r .cell-code}\n# Compare with ordered factors\ndisease_severity[1] > disease_severity[2]  # Is Mild less severe than Severe?\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] FALSE\n```\n:::\n:::\n\n\n### Factor Operations\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Count frequencies\nout <- table(origins_factor)\nout\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\norigins_factor\n    Human Zebrafish     Mouse \n        3         1         2 \n```\n:::\n\n```{.r .cell-code}\nout[\"Human\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nHuman \n    3 \n```\n:::\n\n```{.r .cell-code}\n# Calculate proportions\nprop.table(out)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\norigins_factor\n    Human Zebrafish     Mouse \n0.5000000 0.1666667 0.3333333 \n```\n:::\n\n```{.r .cell-code}\n# Change reference level (important for statistical models)\norigins_factor_relevel <- relevel(origins_factor, ref = \"Mouse\")\norigins_factor_relevel\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] Human     Mouse     Human     Zebrafish Mouse     Human    \nLevels: Mouse Human Zebrafish\n```\n:::\n\n```{.r .cell-code}\n# Convert to character\norigins_char <- as.character(origins_factor)\n\n# Plot factors - Basic barplot\nbarplot(table(origins_factor), \n        col = c(\"blue\", \"green\", \"red\"),\n        main = \"Sample Origins\",\n        ylab = \"Count\")\n```\n\n::: {.cell-output-display}\n![](firststeps_files/figure-html/factor-operations-1.png){width=1650}\n:::\n:::\n\n::: callout-note\nFactor `level`-ing and `relevel`-ing are different. `relevel` redefines what the reference should be. For example, in an experiment, you have `control`, `treatment1`, `treatment2` groups. Your reference might be `control`. So, all of your comparisons/statistics are on the basis of `control`. But you might change the reference (by `relevel` to `treatment1` and all of your comparison will be on the basis of `treatment1` group. Got it?\n:::\n\nMore advanced plot with factors:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngene_expr <- c(5.2, 7.8, 4.5, 12.3, 8.1, 3.7)\nnames(gene_expr) <- as.character(origins)\n\n# Boxplot by factor\nboxplot(gene_expr ~ origins, \n        col = \"lightblue\",\n        main = \"Gene Expression by Sample Origin\", \n        xlab = \"Origin\", \n        ylab = \"Expression Level\")\n```\n\n::: {.cell-output-display}\n![](firststeps_files/figure-html/unnamed-chunk-22-1.png){width=1650}\n:::\n:::\n\n::: callout-note\nDid you notice how factor `level`-ing changes the appearance of the categories in the plots? See the `barplot` and the `boxplot` again. Where are Zebrafish and Mouse now in the plots? Why are their positions on the x-axis changed?\n:::\n\n::: callout-note\nKeep noticing the output formats. Sometimes the output is just a number, sometimes a vector or table or list, etc. Check `prop.table(table(origins_factor))`. How is it?\n:::\n\n::: {.callout-note collapse=\"true\"}\n## Got it?\n\n`prop <- prop.table(table(origins_factor))` -- is a named numeric vector (atomic vector). `prop$Human` or similar won't work. Check this way:\n`prop`\n`prop[\"Human\"]; prop[\"Mouse\"]; prop[\"Zebrafish\"]`\n\nOr make it a data frame (df) first, then try to use normal way of handling df.\n:::\n\nAccessing the Output:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprop <- prop.table(table(origins_factor))\nprop #What do you see? A data frame? No difference?\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\norigins_factor\n    Human Zebrafish     Mouse \n0.5000000 0.1666667 0.3333333 \n```\n:::\n\n```{.r .cell-code}\nprop[\"Human\"]; prop[\"Mouse\"]; prop[\"Zebrafish\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nHuman \n  0.5 \n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n    Mouse \n0.3333333 \n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nZebrafish \n0.1666667 \n```\n:::\n:::\n\n\n## Subsetting Data\n\n### Vectors\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a vector\nexpression_data <- c(3.2, 4.5, 2.1, 6.7, 5.9, 3.3, 7.8, 2.9)\nnames(expression_data) <- paste0(\"Sample_\", 1:8)\nexpression_data\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nSample_1 Sample_2 Sample_3 Sample_4 Sample_5 Sample_6 Sample_7 Sample_8 \n     3.2      4.5      2.1      6.7      5.9      3.3      7.8      2.9 \n```\n:::\n\n```{.r .cell-code}\n# Subset by position\nexpression_data[3]             # Single element\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nSample_3 \n     2.1 \n```\n:::\n\n```{.r .cell-code}\nexpression_data[c(1, 3, 5)]    # Multiple elements\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nSample_1 Sample_3 Sample_5 \n     3.2      2.1      5.9 \n```\n:::\n\n```{.r .cell-code}\nexpression_data[2:5]           # Range\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nSample_2 Sample_3 Sample_4 Sample_5 \n     4.5      2.1      6.7      5.9 \n```\n:::\n\n```{.r .cell-code}\n# Subset by name\nexpression_data[\"Sample_6\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nSample_6 \n     3.3 \n```\n:::\n\n```{.r .cell-code}\nexpression_data[c(\"Sample_1\", \"Sample_8\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nSample_1 Sample_8 \n     3.2      2.9 \n```\n:::\n\n```{.r .cell-code}\n# Subset by condition\nexpression_data[expression_data > 5]              # Values > 5\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nSample_4 Sample_5 Sample_7 \n     6.7      5.9      7.8 \n```\n:::\n\n```{.r .cell-code}\nexpression_data[expression_data >= 3 & expression_data <= 6]  # Values between 3 and 6\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nSample_1 Sample_2 Sample_5 Sample_6 \n     3.2      4.5      5.9      3.3 \n```\n:::\n:::\n\n\n### Data Frames\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a data frame\ngene_df <- data.frame(\n  gene_id = c(\"BRCA1\", \"TP53\", \"MYC\", \"EGFR\", \"GAPDH\"),\n  expression = c(8.2, 6.1, 9.5, 7.0, 10.0),\n  mutation = factor(c(\"Yes\", \"No\", \"Yes\", \"No\", \"No\")),\n  pathway = c(\"DNA Repair\", \"Apoptosis\", \"Cell Cycle\", \"Signaling\", \"Metabolism\")\n)\n\ngene_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n  gene_id expression mutation    pathway\n1   BRCA1        8.2      Yes DNA Repair\n2    TP53        6.1       No  Apoptosis\n3     MYC        9.5      Yes Cell Cycle\n4    EGFR        7.0       No  Signaling\n5   GAPDH       10.0       No Metabolism\n```\n:::\n\n```{.r .cell-code}\n# Subsetting by row index\ngene_df[1:3, ]         # First three rows, all columns\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n  gene_id expression mutation    pathway\n1   BRCA1        8.2      Yes DNA Repair\n2    TP53        6.1       No  Apoptosis\n3     MYC        9.5      Yes Cell Cycle\n```\n:::\n\n```{.r .cell-code}\n# Subsetting by column index\ngene_df[, 1:2]     # All rows, first two columns\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n  gene_id expression\n1   BRCA1        8.2\n2    TP53        6.1\n3     MYC        9.5\n4    EGFR        7.0\n5   GAPDH       10.0\n```\n:::\n\n```{.r .cell-code}\n# Subsetting by column name\ngene_df[, c(\"gene_id\", \"mutation\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n  gene_id mutation\n1   BRCA1      Yes\n2    TP53       No\n3     MYC      Yes\n4    EGFR       No\n5   GAPDH       No\n```\n:::\n\n```{.r .cell-code}\n# Using the $ operator\ngene_df$expression\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1]  8.2  6.1  9.5  7.0 10.0\n```\n:::\n\n```{.r .cell-code}\ngene_df$mutation\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] Yes No  Yes No  No \nLevels: No Yes\n```\n:::\n\n```{.r .cell-code}\n# Subsetting by condition\ngene_df[gene_df$expression > 8, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n  gene_id expression mutation    pathway\n1   BRCA1        8.2      Yes DNA Repair\n3     MYC        9.5      Yes Cell Cycle\n5   GAPDH       10.0       No Metabolism\n```\n:::\n\n```{.r .cell-code}\ngene_df[gene_df$mutation == \"Yes\", ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n  gene_id expression mutation    pathway\n1   BRCA1        8.2      Yes DNA Repair\n3     MYC        9.5      Yes Cell Cycle\n```\n:::\n\n```{.r .cell-code}\n# Multiple conditions\ngene_df[gene_df$expression > 7 & gene_df$mutation == \"No\", ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n  gene_id expression mutation    pathway\n5   GAPDH         10       No Metabolism\n```\n:::\n:::\n\n\n**Logical Operators**\n\n| Operator | Meaning          | Example          |\n|----------|------------------|------------------|\n| `==`     | Equal to         | `x == 5`         |\n| `!=`     | Not equal        | `x != 5`         |\n| `<`      | Less than        | `x < 5`          |\n| `>`      | Greater than     | `x > 5`          |\n| `<=`     | Less or equal    | `x <= 5`         |\n| `>=`     | Greater or equal | `x >= 5`         |\n| `!`      | Not              | `!(x < 5)`       |\n| `|`      | OR               | `x < 5 | x > 10` |\n| `&`      | AND              | `x > 5 & x < 10` |\n\n### Row Names in Data Frames\n\nRow names are particularly important in bioinformatics where genes, proteins, or samples are often used as identifiers.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Setting row names for gene_df\nrownames(gene_df) <- gene_df$gene_id\ngene_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n      gene_id expression mutation    pathway\nBRCA1   BRCA1        8.2      Yes DNA Repair\nTP53     TP53        6.1       No  Apoptosis\nMYC       MYC        9.5      Yes Cell Cycle\nEGFR     EGFR        7.0       No  Signaling\nGAPDH   GAPDH       10.0       No Metabolism\n```\n:::\n:::\n\n\nWe can now drop the gene_id column, if required.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngene_df_clean <- gene_df[, -1]  # Remove the first column\ngene_df_clean\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n      expression mutation    pathway\nBRCA1        8.2      Yes DNA Repair\nTP53         6.1       No  Apoptosis\nMYC          9.5      Yes Cell Cycle\nEGFR         7.0       No  Signaling\nGAPDH       10.0       No Metabolism\n```\n:::\n\n```{.r .cell-code}\n# Access rows by name\ngene_df_clean[\"TP53\", ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n     expression mutation   pathway\nTP53        6.1       No Apoptosis\n```\n:::\n\n```{.r .cell-code}\n# Check if row names are unique\nany(duplicated(rownames(gene_df_clean)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\n# Handle potential duplicated row names\n# NOTE: R doesn't allow duplicate row names by default\ndup_genes <- data.frame(\n  expression = c(5.2, 6.3, 5.2, 8.1),\n  mutation = c(\"Yes\", \"No\", \"Yes\", \"No\")\n)\n\n# This would cause an error:\n#rownames(dup_genes) <- c(\"BRCA1\", \"BRCA1\", \"TP53\", \"EGFR\")\n\n# Instead, we can preemptively make them unique:\nproposed_names <- c(\"BRCA1\", \"BRCA1\", \"TP53\", \"EGFR\")\nunique_names <- make.unique(proposed_names)\nunique_names  # Show the generated unique names\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"BRCA1\"   \"BRCA1.1\" \"TP53\"    \"EGFR\"   \n```\n:::\n\n```{.r .cell-code}\n# Now we can safely assign them\nrownames(dup_genes) <- unique_names\ndup_genes\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n        expression mutation\nBRCA1          5.2      Yes\nBRCA1.1        6.3       No\nTP53           5.2      Yes\nEGFR           8.1       No\n```\n:::\n:::\n\n::: callout-note\nWhy is unique name important for us? Imagine this meaningful biological scenario: one gene might transcribed into many transcript isoforms and hence many protein isoforms. From RNAseq data, we might get alignment count for each gene. But then we can separate the count for each transcript. One gene has one name or ID, but the transcripts are many for the same gene! So, we can denote, for example, 21 isoform of geneA like genA.1, geneA.2, geneA.3,......., geneA.21. \nSee this link for [MBP gene](https://www.ncbi.nlm.nih.gov/gene?Db=gene&Cmd=DetailsSearch&Term=4155). How many transcript isoforms does it have?\n:::\n\n## ðŸ¡ Homeworks: Factors, Subsetting, and Biological Insight\n1. **(Factor vs Character)**\nExplain the difference between a character vector and a factor in R. Why would `mutation_status` be a factor and not just a character vector?\n\n2. **(Factor Level Order)**\nYou observed the following bacterial species in gut microbiome samples:\n\n::: {.cell}\n\n```{.r .cell-code}\nspecies <- c(\"Lactobacillus\", \"Bacteroides\", \"Escherichia\", \"Bacteroides\", \"Lactobacillus\")\nspecies_factor <- factor(species, levels = c(\"Bacteroides\", \"Escherichia\", \"Lactobacillus\"))\n```\n:::\n\nWhat will `levels(species_factor)` return? Why?\n\n3. Given the factor:\n\n::: {.cell}\n\n```{.r .cell-code}\ndisease_severity <- factor(c(\"Mild\", \"Severe\", \"Moderate\"), levels = c(\"Mild\", \"Moderate\", \"Severe\", \"Critical\"), ordered = TRUE)\n```\n:::\n\nWhat will be the result of `disease_severity[1] < disease_severity[2]` and why?\n\n4. You computed:\n\n::: {.cell}\n\n```{.r .cell-code}\nprop <- prop.table(table(species_factor))\n```\n:::\n\nHow do you extract the proportion of \"Escherichia\" samples from prop?\nIs `prop$Escherichia` valid?\n\n5. Interpret what this query returns:\n\n::: {.cell}\n\n```{.r .cell-code}\ngene_df[gene_df$expression > 7 & gene_df$mutation == \"No\", ]\n```\n:::\n\nWhat type of genes does it select?\n\n6. You have:\n\n::: {.cell}\n\n```{.r .cell-code}\nsamples <- c(\"WT\", \"KO\", \"WT\", \"KO\", \"WT\")\nexpression <- c(5.2, 8.1, 4.3, 9.0, 5.7)\n```\n:::\n\nMake a dataframe using these 2 vectors first. Then,\n\n(a) Create a factor `group_factor` for the samples.\n(b) Use `tapply()` to calculate mean expression per group.\n\n::: callout-note\nUse `?tapply()` to see how to use it. \n\n**Hint:** You need to provide things for `X`, `INDEX`, `FUN`. You have `X`, `INDEX` in this small dataframe. The `FUN` should be applied thinking of what you are trying to do. You are trying to get the mean or average, right?\n:::\n\n(c) Plot a `barplot` of average expression for each group.\n\n7. Use the `gene_df` example. Subset the data to find genes with:\n- expression > 8\n- pathway is either \"Cell Cycle\" or \"Signaling\"\n\n8. Create an ordered factor for the disease stages:\n`c(\"Stage I\", \"Stage III\", \"Stage II\", \"Stage IV\", \"Stage I\")`. Then plot the number of patients per stage using `barplot()`.\nConfirm that `\"Stage III\" > \"Stage I\"` is logical in your factor.\n\n9. Suppose `gene_data` has a column type with values \"Oncogene\", \"Tumor Suppressor\", and \"Housekeeping\".\n- Subset all \"Oncogene\" rows where expression > 8.\n- Change the reference level of the factor type to \"Housekeeping\"\n\n10. Simulate expression data for 3 tissues (see the code chunk below):\nWe are going to use `rnorm()` function to generate random values from a normal distribution for this purpose. The example values inside the `rnorm()` function means we want:\n- 30 values in total,\n- average or mean value = 8,\n- standard deviation of expression is 2.\n\nYou can play with the numbers to make your own values.\n\n`rep()` function is to replicate things (many times). In this example, we have `rep(c(\"brain\", \"liver\", \"kidney\"), each = 10)`. We will be having 10x \"brains\", followed by 10x \"liver\", followed by 10x \"kidney\". So, if you have changed your values inside the `rnorm()` function, make this value meaningful for you. Now we have 3 things, each=10. So, 3*10=30 is matching with the total value inside `rnorm()` function. Got it?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(42) #just for reproducibility. Not completely needed\ngene_expr <- rnorm(30, mean = 8, sd = 2)\ntissue <- rep(c(\"brain\", \"liver\", \"kidney\"), each = 10)\ntissue_factor <- factor(tissue, levels = c(\"liver\", \"brain\", \"kidney\"))\n```\n:::\n\n- Make a boxplot showing expression per tissue.\n- Which tissue shows the most variable gene expression? (Use `tapply()` + `sd()`)\n\n::: callout-note\n**Hint:**\nVariability is an expression of measuring standard deviation (`sd`) just by squaring it. So, `var` = `sd^2`. Well, do you see how to use `sd` inside `tapply()` function? Use `?tapply()` to know how to use it.\n:::\n\nUse these questions as a self-check -- reflect on why each step works before moving on to the next level (question).\n\n**Push your `.Rmd` file and share by Friday 10PM BD Time.**\n\n## Conditionals\n\n### `if-else` statement\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# if-else statement\ngene_value <- 6.8\n\nif(gene_value > 10) {\n  print(\"High expression\")\n} else if(gene_value > 5) {\n  print(\"Medium expression\")\n} else {\n  print(\"Low expression\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"Medium expression\"\n```\n:::\n:::\n\nVisualize it using the image below.\n\n::: text-center\n![](img/if_else.png){width=\"80%\"}\n:::\n\n### `ifelse` statement for vectors\n\n`ifelse` is binary in nature. So, we can categorize only 2 things using `ifelse`. See this example:\n\n::: {.cell}\n\n```{.r .cell-code}\nexpression_values <- c(12.5, 4.3, 8.1, 2.2)\nlabels <- ifelse(expression_values > 5, \"Upregulated\", \"Downregulated\")\nlabels\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"Upregulated\"   \"Downregulated\" \"Upregulated\"   \"Downregulated\"\n```\n:::\n:::\n\n::: text-center\n![](img/elseif.png){width=\"80%\"}\n:::\n\n::: callout-note\n`ifelse` has 3 things inside the parentheses, right? The first one is the condition, the second one is the category we define if the condition is met, and the third thing is the other remaining category we want to assign if the condition is not met. So, it's usage is perfect to say if a gene/transcript is upregulated or downregulated (binary classification).\n:::\n\nIf we still want to categorize more than 2 categories using `ifelse`, we need to use it in a nested way. See this example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# ifelse() for vectors\nexpression_levels <- c(2.5, 5.8, 7.2, 3.1, 6.9)\nexpression_category <- ifelse(expression_levels > 6, \n                             \"High\", \n                             ifelse(expression_levels > 4, \"Medium\", \"Low\"))\nexpression_category\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"Low\"    \"Medium\" \"High\"   \"Low\"    \"High\"  \n```\n:::\n:::\n\n::: text-center\n![](img/nested_elseif.png){width=\"80%\"}\n:::\n::: callout-note\nYou remember the general structure of `ifelse` loop, right? the second thing after the first `,` is the assigned category if the condition is met. So, we assigned it as `High` here in this example. But then after the second `,` there is a second `ifelse` loop instead of a category. The second loop makes 2 more binary categories `Medium` and `Low`, and our task of assigning 3 categories is achieved.\n:::\n\n`dplyr` package has a function named `case-when()` to help us use as many categories we want. The same task would be achieved like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Requires dplyr package\n#install.packages(\"dplyr\") #decomment if you need to install the package\nlibrary(dplyr)\nexpression_levels <- c(2.5, 5.8, 7.2, 3.1, 6.9)\nlabels <- case_when(\n  expression_levels > 6 ~ \"High\",\n  expression_levels > 4 ~ \"Medium\",\n  TRUE ~ \"Low\"  # Default case\n)\nlabels\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"Low\"    \"Medium\" \"High\"   \"Low\"    \"High\"  \n```\n:::\n:::\n\n::: callout-note\nDo you see the point how you would use the `ifelse` loop if you wanted to write a function to make 4 or 5 categories? If not, pause and re-think. You need to see the point. \nBut anyway, categorizing more than 2 is better using `if-else` statement\n:::\n\n### `for` loop\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenes <- c(\"BRCA1\", \"TP53\", \"MYC\", \"CDC2\", \"MBP\")\nexpr <- c(8.2, 5.4, 11.0, 5.4, 13.0)\n\nfor (i in 1:length(genes)) {\n  status <- if (expr[i] > 10) \"High\" else if (expr[i] > 6) \"Moderate\" else \"Low\"\n  cat(genes[i], \"has\", status, \"expression\\n\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nBRCA1 has Moderate expression\nTP53 has Low expression\nMYC has High expression\nCDC2 has Low expression\nMBP has High expression\n```\n:::\n:::\n\nIn-class Task:\n\n- Make a data frame using `genes` and `expr`.\n- Add/flag the categories `High`, `Moderate` and `Low` you get using the `for` loop in a new column named `expression_level` or similar.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Step 1: Vectors\ngenes <- c(\"BRCA1\", \"TP53\", \"MYC\", \"CDC2\", \"MBP\")\nexpr <- c(8.2, 5.4, 11.0, 5.4, 13.0)\n\n# Step 2: Create a data frame\ngene_df <- data.frame(gene = genes, expression = expr)\n\n# Step 3: Add an empty column for expression level\ngene_df$expression_level <- NA\n\n# Step 4: Use for loop to fill in the expression_level column\nfor (i in 1:nrow(gene_df)) {\n  gene_df$expression_level[i] <- if (gene_df$expression[i] > 10) {\n    \"High\"\n  } else if (gene_df$expression[i] > 6) {\n    \"Moderate\"\n  } else {\n    \"Low\"\n  }\n}\n\n# View the final data frame\nprint(gene_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n   gene expression expression_level\n1 BRCA1        8.2         Moderate\n2  TP53        5.4              Low\n3   MYC       11.0             High\n4  CDC2        5.4              Low\n5   MBP       13.0             High\n```\n:::\n:::\n\n### `while` loop\nContext:\nYou are preparing biological samples (e.g., blood, DNA extracts) for analysis. You have a set of samples labeled `Sample 1` to `Sample 5`. You want to check each one in order and confirm that it's ready for analysis. Use a while loop to process the samples sequentially.\n\n::: {.cell}\n\n```{.r .cell-code}\ni <- 1\nwhile (i <= 5) {\n  cat(\"Sample\", i, \"is ready for analysis\\n\")\n  i <- i + 1\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nSample 1 is ready for analysis\nSample 2 is ready for analysis\nSample 3 is ready for analysis\nSample 4 is ready for analysis\nSample 5 is ready for analysis\n```\n:::\n:::\n\n### `next` and `break`\nContext:\nYou are screening biological samples (e.g., tissue or blood) in a quality control process. Some samples are good, some are suboptimal (not contaminated but poor quality), and some are contaminated (must be flagged and stop further processing). Use `next` to skip suboptimal samples and `break` to immediately stop when a contaminated sample is found.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsamples <- c(\"good\", \"bad\", \"good\", \"contaminated\")\n\nfor (s in samples) {\n  if (s == \"contaminated\") {\n    print(\"Stop! Contaminated sample.\")\n    break\n  }\n  if (s == \"bad\") next\n  print(paste(\"Processing\", s))\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"Processing good\"\n[1] \"Processing good\"\n[1] \"Stop! Contaminated sample.\"\n```\n:::\n:::\n\n## Writing Functions in R\n### Flag gene expression\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflag_expression <- function(value) {\n  if (value > 10) {\n    return(\"High\")\n  } else if (value > 5) {\n    return(\"Moderate\")\n  } else {\n    return(\"Low\")\n  }\n}\n\nflag_expression(8.3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"Moderate\"\n```\n:::\n:::\n\n**Apply to a vector**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexpr_values <- c(12.2, 4.4, 7.5)\nsapply(expr_values, flag_expression)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"High\"     \"Low\"      \"Moderate\"\n```\n:::\n:::\n\n### Function with multiple arguments\n\n::: {.cell}\n\n```{.r .cell-code}\ngene_status <- function(gene, expression, threshold = 6) {\n  label <- ifelse(expression > threshold, \"Up\", \"Down\")\n  return(paste(gene, \"is\", label, \"regulated\"))\n}\n\ngene_status(\"TP53\", 8.1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] \"TP53 is Up regulated\"\n```\n:::\n:::\n\n### Return a list\n\n::: {.cell}\n\n```{.r .cell-code}\ncalc_stats <- function(values) {\n  return(list(mean = mean(values), sd = sd(values)))\n}\n\ncalc_stats(c(4.2, 5.5, 7.8))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n$mean\n[1] 5.833333\n\n$sd\n[1] 1.823001\n```\n:::\n:::\n\n## Handling Missing/Wrong Values\n\n### Identifying Issues\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create data with missing values\nclinical_data <- data.frame(\n  patient_id = 1:5,\n  age = c(25, 99, 30, -5, 40),    # -5 is wrong, 99 is suspect\n  bp = c(120, NA, 115, 125, 118),  # NA is missing\n  weight = c(65, 70, NA, 68, -1)   # -1 is wrong\n)\nclinical_data\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n  patient_id age  bp weight\n1          1  25 120     65\n2          2  99  NA     70\n3          3  30 115     NA\n4          4  -5 125     68\n5          5  40 118     -1\n```\n:::\n\n```{.r .cell-code}\n# Check for missing values\nis.na(clinical_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n     patient_id   age    bp weight\n[1,]      FALSE FALSE FALSE  FALSE\n[2,]      FALSE FALSE  TRUE  FALSE\n[3,]      FALSE FALSE FALSE   TRUE\n[4,]      FALSE FALSE FALSE  FALSE\n[5,]      FALSE FALSE FALSE  FALSE\n```\n:::\n\n```{.r .cell-code}\ncolSums(is.na(clinical_data))  # Count NAs by column\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\npatient_id        age         bp     weight \n         0          0          1          1 \n```\n:::\n\n```{.r .cell-code}\n# Check for impossible values\nclinical_data$age < 0\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] FALSE FALSE FALSE  TRUE FALSE\n```\n:::\n\n```{.r .cell-code}\nclinical_data$weight < 0\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] FALSE FALSE    NA FALSE  TRUE\n```\n:::\n\n```{.r .cell-code}\n# Find indices of problematic values\nwhich(clinical_data$age < 0 | clinical_data$age > 90)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 2 4\n```\n:::\n:::\n\n\n### Fixing Data\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Replace impossible values with NA\nclinical_data$age[clinical_data$age < 0 | clinical_data$age > 90] <- NA\nclinical_data$weight[clinical_data$weight < 0] <- NA\nclinical_data\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n  patient_id age  bp weight\n1          1  25 120     65\n2          2  NA  NA     70\n3          3  30 115     NA\n4          4  NA 125     68\n5          5  40 118     NA\n```\n:::\n\n```{.r .cell-code}\n# Replace NAs with mean (common in biological data)\nclinical_data$bp[is.na(clinical_data$bp)] <- mean(clinical_data$bp, na.rm = TRUE)\nclinical_data$weight[is.na(clinical_data$weight)] <- mean(clinical_data$weight, na.rm = TRUE)\nclinical_data\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n  patient_id age    bp   weight\n1          1  25 120.0 65.00000\n2          2  NA 119.5 70.00000\n3          3  30 115.0 67.66667\n4          4  NA 125.0 68.00000\n5          5  40 118.0 67.66667\n```\n:::\n\n```{.r .cell-code}\n# Replace NAs with median (better for skewed data)\nclinical_data$age[is.na(clinical_data$age)] <- median(clinical_data$age, na.rm = TRUE)\nclinical_data\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n  patient_id age    bp   weight\n1          1  25 120.0 65.00000\n2          2  30 119.5 70.00000\n3          3  30 115.0 67.66667\n4          4  30 125.0 68.00000\n5          5  40 118.0 67.66667\n```\n:::\n:::\n\n\n## Data Transformation\n\n### Introduction to Outliers\n\nOutliers can significantly affect statistical analyses, especially in biological data where sample variation can be high.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create data with outliers\nexpression_levels <- c(2.3, 2.7, 3.1, 2.9, 2.5, 3.0, 15.2, 2.8)\nboxplot(expression_levels, \n        main = \"Expression Levels with Outlier\",\n        ylab = \"Expression\")\n```\n\n::: {.cell-output-display}\n![](firststeps_files/figure-html/outliers-1.png){width=1650}\n:::\n:::\n\n\n### Identifying Outliers\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Statistical approach: Values beyond 1.5*IQR\ndata_summary <- summary(expression_levels)\ndata_summary\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  2.300   2.650   2.850   4.312   3.025  15.200 \n```\n:::\n\n```{.r .cell-code}\nIQR_value <- IQR(expression_levels)\nupper_bound <- data_summary[\"3rd Qu.\"] + 1.5 * IQR_value\nlower_bound <- data_summary[\"1st Qu.\"] - 1.5 * IQR_value\n\n# Find outliers\noutliers <- expression_levels[expression_levels > upper_bound | \n                             expression_levels < lower_bound]\noutliers\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] 15.2\n```\n:::\n:::\n\n\n### Transforming Vectors\n\nMathematical transformations can normalize data, reduce outlier effects, and make data more suitable for statistical analyses.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Original data\ngene_exp <- c(15, 42, 87, 115, 320, 560, 1120)\nhist(gene_exp, main = \"Original Expression Values\", xlab = \"Expression\")\n```\n\n::: {.cell-output-display}\n![](firststeps_files/figure-html/transformations-1.png){width=1650}\n:::\n\n```{.r .cell-code}\n# Log transformation (common in gene expression analysis)\nlog_exp <- log2(gene_exp)\nhist(log_exp, main = \"Log2 Transformed Expression\", xlab = \"Log2 Expression\")\n```\n\n::: {.cell-output-display}\n![](firststeps_files/figure-html/transformations-2.png){width=1650}\n:::\n\n```{.r .cell-code}\n# Square root transformation (less aggressive than log)\nsqrt_exp <- sqrt(gene_exp)\nhist(sqrt_exp, main = \"Square Root Transformed Expression\", xlab = \"Sqrt Expression\")\n```\n\n::: {.cell-output-display}\n![](firststeps_files/figure-html/transformations-3.png){width=1650}\n:::\n\n```{.r .cell-code}\n# Z-score normalization (standardization)\nz_exp <- scale(gene_exp)\nhist(z_exp, main = \"Z-score Normalized Expression\", xlab = \"Z-score\")\n```\n\n::: {.cell-output-display}\n![](firststeps_files/figure-html/transformations-4.png){width=1650}\n:::\n\n```{.r .cell-code}\n# Compare transformations\npar(mfrow = c(2, 2))\nhist(gene_exp, main = \"Original\")\nhist(log_exp, main = \"Log2\")\nhist(sqrt_exp, main = \"Square Root\")\nhist(z_exp, main = \"Z-score\")\n```\n\n::: {.cell-output-display}\n![](firststeps_files/figure-html/transformations-5.png){width=1650}\n:::\n\n```{.r .cell-code}\npar(mfrow = c(1, 1))  # Reset plotting layout\n```\n:::\n\n\n### Logical Expressions\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create gene expression vector\nexp_data <- c(5.2, 3.8, 7.1, 2.9, 6.5, 8.0, 4.3)\nnames(exp_data) <- paste0(\"Gene_\", 1:7)\n\n# Basic comparisons\nexp_data > 5    # Which genes have expression > 5?\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nGene_1 Gene_2 Gene_3 Gene_4 Gene_5 Gene_6 Gene_7 \n  TRUE  FALSE   TRUE  FALSE   TRUE   TRUE  FALSE \n```\n:::\n\n```{.r .cell-code}\nexp_data <= 4   # Which genes have expression <= 4?\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nGene_1 Gene_2 Gene_3 Gene_4 Gene_5 Gene_6 Gene_7 \n FALSE   TRUE  FALSE   TRUE  FALSE  FALSE  FALSE \n```\n:::\n\n```{.r .cell-code}\n# Store results in logical vector\nhigh_exp <- exp_data > 6\nhigh_exp\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nGene_1 Gene_2 Gene_3 Gene_4 Gene_5 Gene_6 Gene_7 \n FALSE  FALSE   TRUE  FALSE   TRUE   TRUE  FALSE \n```\n:::\n\n```{.r .cell-code}\n# Use logical vectors for subsetting\nexp_data[high_exp]  # Get high expression values\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nGene_3 Gene_5 Gene_6 \n   7.1    6.5    8.0 \n```\n:::\n:::\n\n\n### Logical Operators\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Combining conditions with AND (&)\nexp_data > 4 & exp_data < 7  # Expression between 4 and 7\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nGene_1 Gene_2 Gene_3 Gene_4 Gene_5 Gene_6 Gene_7 \n  TRUE  FALSE  FALSE  FALSE   TRUE  FALSE   TRUE \n```\n:::\n\n```{.r .cell-code}\n# Combining conditions with OR (|)\nexp_data < 4 | exp_data > 7  # Expression less than 4 OR greater than 7\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nGene_1 Gene_2 Gene_3 Gene_4 Gene_5 Gene_6 Gene_7 \n FALSE   TRUE   TRUE   TRUE  FALSE   TRUE  FALSE \n```\n:::\n\n```{.r .cell-code}\n# Using NOT (!)\n!high_exp  # Not high expression\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nGene_1 Gene_2 Gene_3 Gene_4 Gene_5 Gene_6 Gene_7 \n  TRUE   TRUE  FALSE   TRUE  FALSE  FALSE   TRUE \n```\n:::\n\n```{.r .cell-code}\n# Subsetting with combined conditions\nexp_data[exp_data > 4 & exp_data < 7]  # Get values between 4 and 7\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nGene_1 Gene_5 Gene_7 \n   5.2    6.5    4.3 \n```\n:::\n:::\n\n\n### Logical Functions\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# all() - Are all values TRUE?\nall(exp_data > 0)  # Are all expressions positive?\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n# any() - Is at least one value TRUE?\nany(exp_data > 7)  # Is any expression greater than 7?\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n# which() - Get indices of TRUE values\nwhich(exp_data > 6)  # Which elements have expressions > 6?\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\nGene_3 Gene_5 Gene_6 \n     3      5      6 \n```\n:::\n\n```{.r .cell-code}\n# %in% operator - Test for membership\ntest_genes <- c(\"Gene_1\", \"Gene_5\", \"Gene_9\")\nnames(exp_data) %in% test_genes  # Which names match test_genes?\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.custom-output}\n[1]  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE\n```\n:::\n:::\n\n\n### Practical Session\n\nCheck out this repo: `https://github.com/genomicsclass/dagdata/`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Download small example dataset\ndownload.file(\"https://github.com/genomicsclass/dagdata/raw/master/inst/extdata/msleep_ggplot2.csv\",\n              destfile = \"msleep_data.csv\")\n\n# Load data\nmsleep <- read.csv(\"msleep_data.csv\")\n```\n:::\n\n\n1.  Convert 'vore' column to factor and plot its distribution.\n2.  Create a matrix of sleep data columns and add row names.\n3.  Find and handle any missing values.\n4.  Calculate mean sleep time by diet category (vore).\n5.  Identify outliers in sleep_total.\n\n## Summary of the Lesson\n\nIn this lesson, we covered:\n\n1. **Factor Variables**: Essential for categorical data in biology (genotypes, treatments, etc.)\n\n  - Creation, levels, ordering, and visualization\n\n2.  **Subsetting Techniques**: Critical for data extraction and analysis\n\n  - Vector and data frame subsetting with various methods\n  - Using row names effectively for biological identifiers\n\n3. **Matrix Operations**: Fundamental for expression data\n\n  - Creation, manipulation, and biological applications\n  - Calculating fold changes and other common operations\n\n4.  **Missing Values**: \nPractical approaches for real-world biological data\n\n  - Identification and appropriate replacement methods\n\n5. **Data Transformation**: Making data suitable for statistical analysis\n\n  - Log, square root, and z-score transformations\n  - Outlier identification and handling\n\n6. **Logical Operations**: For data filtering and decision making\n\n  - Conditions, combinations, and applications\n\n    These skills form the foundation for the more advanced visualization techniques we'll cover in future lessons.\n\n7. **List**: Fundamental for many biological data and packages' output.\n\n  - Properties, accessing, and applications\n\n8. We will know more about conditionals, R packages to handle data and visualization in a better and efficient way.\n\n## Homework\n\n1. **Matrix Operations**:\n  - Create a gene expression matrix with 8 genes and 4 conditions\n  - Calculate the mean expression for each gene\n  - Calculate fold change between condition 4 and condition 1\n  - Create a heatmap of your matrix\n2. **Factor Analysis**:\n  - Using the `iris` dataset, convert Species to an ordered factor\n  - Create boxplots showing Sepal.Length by Species\n  - Calculate mean petal length for each species level\n3. **Data Cleaning Challenge**:\n  - In the downloaded `msleep_data.csv`:\n  - Identify all columns with missing values\n  - Replace missing values appropriately\n  - Create a new categorical variable \"sleep_duration\" with levels \"Short\", \"Medium\", \"Long\"\n4. **List challenge**:\n  - Make your own lists\n  - Replicate all the tasks we did\n  - You may ask AI to give you beginner-level questions but don't ask to solve the questions programmatically. Tell AI not to provide answers.\n5. **Complete Documentation**:\n  - Write all code in R Markdown\n  - Include comments explaining your approach\n  - Push to GitHub\n\n#### Due date: Friday 10pm BD Time\n\n\n\n",
    "supporting": [
      "firststeps_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}