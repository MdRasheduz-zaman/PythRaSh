{
  "hash": "3aefc11d330578bca9bb5b27bfa60bf0",
  "result": {
    "markdown": "---\ntitle: \"HW solutions\"\nabstract: \"dataframe, matrices, list, factor, vector, etc.\"\n---\n\n\n  \n<style>\n  .content {\n    text-align: justify !important;\n  }\n  p {\n    text-align: justify !important;\n  }\n  .quarto-body {\n    text-align: justify !important;\n  }\n</style>\n\n# L3: Matrices and Lists\n\n## Task 1: Protein Concentration in Samples\n\nWe measured the concentration (in µg/µL) of three proteins (P1, P2, P3) in four samples (S1–S4):\n\n### 1. Matrices\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Making Protein Matrix\nProteinMatrix <- matrix(\n  c(5, 3, 2,\n    7, 6, 4),\n  nrow = 2, byrow = TRUE\n)\nrownames(ProteinMatrix) = c(\"Sample1\", \"Sample2\")\ncolnames(ProteinMatrix) = c(\"ProteinX\", \"ProteinY\", \"ProteinZ\")\nProteinMatrix\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        ProteinX ProteinY ProteinZ\nSample1        5        3        2\nSample2        7        6        4\n```\n:::\n:::\n\n\nNow goes the weight matrix\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Making weight matrix\nWeightVector <- matrix(\n  c(0.5, 1.0, 1.5),\n  nrow=3, byrow = TRUE\n)\nrownames(WeightVector) = c(\"ProteinX\", \"ProteinY\", \"ProteinZ\")\ncolnames(WeightVector) = c(\"Weight\")\nWeightVector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         Weight\nProteinX    0.5\nProteinY    1.0\nProteinZ    1.5\n```\n:::\n:::\n\n\n\nNow, multiply them.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Multiplying Matrices\nTotalConc = ProteinMatrix %*% WeightVector\ncolnames(TotalConc) <- \"Total_Protein_Conc\"\nprint(TotalConc)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        Total_Protein_Conc\nSample1                8.5\nSample2               15.5\n```\n:::\n:::\n\n\n\n### 2. Making transpose of ProteinMatrix\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nProteinMatTranspose = t(ProteinMatrix)\nProteinMatTranspose\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         Sample1 Sample2\nProteinX       5       7\nProteinY       3       6\nProteinZ       2       4\n```\n:::\n:::\n\n\n### 3. Identity Matrix\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nI <- diag(3)\nIdentitycheck = ProteinMatrix %*% I\ncolnames(Identitycheck) <- c(\"ProteinX\", \"ProteinY\", \"ProteinZ\")\nIdentitycheck\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        ProteinX ProteinY ProteinZ\nSample1        5        3        2\nSample2        7        6        4\n```\n:::\n:::\n\n\n\n### 4.1. Total Protein per Sample\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrowSums(ProteinMatrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSample1 Sample2 \n     10      17 \n```\n:::\n:::\n\n\n\n### 4.2. Total Protein per Protein Type\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolSums(ProteinMatrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nProteinX ProteinY ProteinZ \n      12        9        6 \n```\n:::\n:::\n\n\n\n### 4.3. Heatmap of Protein Concentrations\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nheatmap(ProteinMatrix, scale = \"none\", col = heat.colors(10))\n```\n\n::: {.cell-output-display}\n![](solutions_files/figure-pdf/unnamed-chunk-8-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n### Interpretation\n\n- Multiplying the protein levels by the weight vector shows how much each protein contributes in a sample. The result shows total protein concentration per sample.\n- The result shows that sample S2 has the highest protein burden.\n- The identity matrix represents no protein interactions or measurement biases. It is a simple matrix calculation.\n- New calculation:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# changing the weight of ProteinZ to 3.0\nnewweightvector = matrix(\n  c(0.5, 1.0, 3.0),\n  nrow=3, byrow = TRUE\n)\nrownames(WeightVector) = c(\"ProteinX\", \"ProteinY\", \"ProteinZ\")\ncolnames(WeightVector) = c(\"Weight\")\nnewTotalconc = ProteinMatrix %*% newweightvector\ncolnames(newTotalconc) <- \"Total_Protein_Conc\"\nnewTotalconc\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        Total_Protein_Conc\nSample1               11.5\nSample2               21.5\n```\n:::\n:::\n\n\nStill, S2 has more protein burden.\n\nBonus:\n\n- Heatmap reveals PX is most abundant across all samples.\n\n---\n\n## Task 2: Gene-to-Protein Translation\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# making  Gene Expression matrix\nGeneExpression <- matrix(\n  c(10, 8, 5,\n    15, 12, 10),\n  nrow = 2, byrow = TRUE\n)\nrownames(GeneExpression) <- c(\"Sample1\", \"Sample2\")\ncolnames(GeneExpression) <- c(\"GeneA\", \"GeneB\", \"GeneC\")\nGeneExpression\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        GeneA GeneB GeneC\nSample1    10     8     5\nSample2    15    12    10\n```\n:::\n:::\n\n\n\nTranslation efficiency:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# making Translation Matrix\nTranslationMatrix <- matrix(\n  c(1.5, 0 , 0,\n  0, 1.2, 0,\n  0, 0, 1.8),\nnrow = 3, byrow = TRUE\n)\n\nrownames(TranslationMatrix) <- c(\"GeneA\", \"GeneB\", \"GeneC\")\nTranslationMatrix\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1] [,2] [,3]\nGeneA  1.5  0.0  0.0\nGeneB  0.0  1.2  0.0\nGeneC  0.0  0.0  1.8\n```\n:::\n:::\n\n\n\n### Protein Output\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# computing Protein matrix\nProtein_matrix <- GeneExpression %*% TranslationMatrix\nprint(Protein_matrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        [,1] [,2] [,3]\nSample1 15.0  9.6    9\nSample2 22.5 14.4   18\n```\n:::\n:::\n\n\n### 2. Transpose\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Transpose of GeneExpression matrix\nGeneExpression_Transpose <- t(GeneExpression)\nGeneExpression_Transpose\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Sample1 Sample2\nGeneA      10      15\nGeneB       8      12\nGeneC       5      10\n```\n:::\n:::\n\n\nThe new matrix represnts a matrix where the rows and columns of GeneExpression matrix have been interchanged.\n\n### 3. Identity matrix and multipliccation\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Creating Identity matrix\nI <- diag(3)\nI\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    0    0\n[2,]    0    1    0\n[3,]    0    0    1\n```\n:::\n:::\n\n\nNow, multiply:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nProduct_matrix = TranslationMatrix %*%  I \nProduct_matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1] [,2] [,3]\nGeneA  1.5  0.0  0.0\nGeneB  0.0  1.2  0.0\nGeneC  0.0  0.0  1.8\n```\n:::\n:::\n\n\nThe product is identical to TranslationMatrix\n\n### 4. Sub-matrix:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# making submatrix A\nA = matrix(\n  c(10, 8,\n    15, 12), nrow=2, byrow = TRUE\n)\nrownames(A) = c(\"sample1\", \"sample2\")\ncolnames(A) = c(\"GeneA\", \"GeneB\")\n\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        GeneA GeneB\nsample1    10     8\nsample2    15    12\n```\n:::\n\n```{.r .cell-code}\n# finding inverse of A\n#inv_A <- solve(A)\n#inv_A\n```\n:::\n\n\nThe inverse matrix could not be calculated since A is a singular matrix.\nSo, A * A^-1 is also not possible.\n\n### Visualization tasks:\n\n- 1. MARplot\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# generating MARplot-style scatter plot\nplot(GeneExpression, Protein_matrix, type=\"p\", main=\"Protein level vs. Gene Expression level\")\nlabels <- \"Sample-Gene\"\ntext(GeneExpression, Protein_matrix, labels = labels, pos=3)\n```\n\n::: {.cell-output-display}\n![](solutions_files/figure-pdf/unnamed-chunk-17-1.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\n# generating a heatmap\nheatmap(Protein_matrix, main= \"Heatmap of Protein Level\", Rowv = TRUE, Colv = TRUE, labRow= rownames(Protein_matrix), labCol= c(\"ProteinA\", \"ProteinB\", \"ProteinC\"), col=topo.colors(256) )\n```\n\n::: {.cell-output-display}\n![](solutions_files/figure-pdf/unnamed-chunk-17-2.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n- 2. Heatmap of Expression:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nheatmap(GeneExpression, col = terrain.colors(10), scale = \"column\")\n```\n\n::: {.cell-output-display}\n![](solutions_files/figure-pdf/unnamed-chunk-18-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n### Interpretation\n\n1. Matrix multiplication allows each gene in both samples to be multiplied to their respective translation efficiency. So, the product shows how successfully each gene is translated\")\n\n2. The diagonal TranslationMatrix make sense biologically because they show translation efficiency of each gene and there is no other interaction between them. Although there could be interaction in real-world scenarios.\n\n3. If Sample2 has higher protein levels even with similar gene expression, it means that more mRNAs are translated to proteins compared to Sample1\"\n\n4. The upward trend in MARplot may indicate an increase in translation efficacy and downward trend may indicate a decline in translation efficacy\"\n\n5. Clustering in the heatmap may suggest which samples are most similar to each other based on their prot.\n\n---\n\n## Task 3: Animal Breeding – Bull Ranking by Economic Traits\n\n**Define Data**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define Bull EBVs\nBullEBVs <- matrix(c(\n  400, 1.2, 0.8,\n  500, 1.5, 0.6\n), nrow = 2, byrow = TRUE)\n\nrownames(BullEBVs) <- c(\"Bull1\", \"Bull2\")\ncolnames(BullEBVs) <- c(\"Milk_yield\", \"Growth_rate\", \"Fertility\")\n\n# Define Economic Weights\nEconomicWeights <- matrix(c(0.002, 50, 100), ncol = 1)\n```\n:::\n\n\n1️⃣ Compute Total Economic Value\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTotalValue <- BullEBVs %*% EconomicWeights\nTotalValue\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       [,1]\nBull1 140.8\nBull2 136.0\n```\n:::\n:::\n\n\n\n✅ Interpretation\n\nBull1: (400 × 0.002) + (1.2 × 50) + (0.8 × 100) = 140.8\nBull2: (500 × 0.002) + (1.5 × 50) + (0.6 × 100) = 136.0\n\nBull1 is more valuable economically.\n\n2️⃣ Biological Interpretation\n\nEconomic weights convert genetic merit (EBVs) into economic merit. Traits with higher financial importance have a larger impact, regardless of absolute EBV values.\n\n3️⃣ Multiply with Identity Matrix\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nI3 <- diag(3)\nBullEBVs_identity <- BullEBVs %*% I3\nBullEBVs_identity\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1] [,2] [,3]\nBull1  400  1.2  0.8\nBull2  500  1.5  0.6\n```\n:::\n:::\n\n\n✅ Interpretation\n\nMultiplying by identity matrix returns the original matrix. It confirms that EBV structure is preserved.\n\n4️⃣ Remove Milk Yield and Recalculate Total Value\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nBullEBVs_noMilk <- BullEBVs[, -1]\nEconomicWeights_noMilk <- EconomicWeights[2:3, , drop = FALSE]\n\nTotalValue_noMilk <- BullEBVs_noMilk %*% EconomicWeights_noMilk\nTotalValue_noMilk\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1]\nBull1  140\nBull2  135\n```\n:::\n:::\n\n\n\n✅ Interpretation\n\nBull1: (1.2 × 50) + (0.8 × 100) = 140\nBull2: (1.5 × 50) + (0.6 × 100) = 135\n\nBull1 still ranks higher, but by a smaller margin.\n\n5️⃣ Bar Plot: Total Economic Value (Base R)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbarplot(\n  TotalValue,\n  beside = TRUE,\n  names.arg = rownames(BullEBVs),\n  col = c(\"skyblue\", \"orange\"),\n  main = \"Total Economic Value of Bulls\",\n  ylab = \"Total Value\"\n)\n```\n\n::: {.cell-output-display}\n![](solutions_files/figure-pdf/unnamed-chunk-23-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n6️⃣ Heatmap of EBVs (Base R)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nheatmap(\n  BullEBVs,\n  Rowv = NA,\n  Colv = NA,\n  scale = \"none\",\n  col = heat.colors(256),\n  main = \"Heatmap of Bull EBVs\"\n)\n```\n\n::: {.cell-output-display}\n![](solutions_files/figure-pdf/unnamed-chunk-24-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n🧠 Interpretation Questions\n\nHow do economic weights affect trait importance?\n\nTraits with higher weights contribute more to the total economic value.This makes them more influential in ranking and selection.\n\nWhy might you ignore milk yield?\n\nMilk yield may be excluded in systems focusing on fertility, growth, or when it is no longer a limiting factor.Environmental or economic contexts may also shift trait priorities.\n\nWhat is the value of heatmaps?\n\nHeatmaps visually compare EBVs across bulls and traits.They help detect patterns, outliers, and clusters easily in multivariate data.\n\nCan this method be extended to more bulls and traits?\n\nYes. This method scales to any number of bulls or traits.Just ensure the EBVs matrix and economic weights are dimensionally compatible.\n\n\n## Task 4: Plant Breeding – Trait Contributions from Parental Lines\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# making parent traits matrix\nParentTraits = matrix(\n  c(7, 5, 3,\n    6, 8, 4,\n    5, 6, 6), nrow=3, byrow= TRUE\n)\nrownames(ParentTraits) = c(\"P1\", \"P2\", \"P3\")\ncolnames(ParentTraits) = c(\"T1 Drought resistance\", \"T2 Yield\", \"T3 Maturation time\")\nprint(ParentTraits)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   T1 Drought resistance T2 Yield T3 Maturation time\nP1                     7        5                  3\nP2                     6        8                  4\nP3                     5        6                  6\n```\n:::\n\n```{.r .cell-code}\n# making HybridWeights matrix\nHybridWeights = matrix(\n  c(0.5, 0.3, 0.2), nrow=3, byrow= TRUE\n)\nprint(\"HybridWeights:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"HybridWeights:\"\n```\n:::\n\n```{.r .cell-code}\nprint(HybridWeights)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1]\n[1,]  0.5\n[2,]  0.3\n[3,]  0.2\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Transpose of HybridWeights\nHybridWeightsTranspose = t(HybridWeights)\nprint(\"HybridWeightsTranspose:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"HybridWeightsTranspose:\"\n```\n:::\n\n```{.r .cell-code}\nprint(HybridWeightsTranspose)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]  0.5  0.3  0.2\n```\n:::\n:::\n\n\n\n### computing Hybrid traits matrix\n\n\n::: {.cell}\n\n```{.r .cell-code}\nHybridTraits =  HybridWeightsTranspose %*% ParentTraits\nprint(\"The HybridTraits matrix is:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"The HybridTraits matrix is:\"\n```\n:::\n\n```{.r .cell-code}\nprint(HybridTraits)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     T1 Drought resistance T2 Yield T3 Maturation time\n[1,]                   6.3      6.1                3.9\n```\n:::\n\n```{.r .cell-code}\n# Explaining what it means biologically when one parent contributes more to a particular trait\nprint(\"A parent contributing more to a particular trait than others makes it more desirable and more likely to be selected for plant breeding\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A parent contributing more to a particular trait than others makes it more desirable and more likely to be selected for plant breeding\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# making identity matrix and multiplying with ParentTraits \nI = diag(3)\nprint(I)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    0    0\n[2,]    0    1    0\n[3,]    0    0    1\n```\n:::\n\n```{.r .cell-code}\nProduct = I %*% ParentTraits\nprint(Product)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     T1 Drought resistance T2 Yield T3 Maturation time\n[1,]                     7        5                  3\n[2,]                     6        8                  4\n[3,]                     5        6                  6\n```\n:::\n\n```{.r .cell-code}\nprint(\"Observation:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Observation:\"\n```\n:::\n\n```{.r .cell-code}\nprint(\" I × ParentTraits is identical to ParentTraits matrix\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \" I × ParentTraits is identical to ParentTraits matrix\"\n```\n:::\n\n```{.r .cell-code}\nprint(\"I × ParentTraits represents the original matrix and therefore no transformation or change\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"I × ParentTraits represents the original matrix and therefore no transformation or change\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# subsetting\nparentsub = ParentTraits[, 1:2]\nprint(\"Subset matrix of ParentTraits\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Subset matrix of ParentTraits\"\n```\n:::\n\n```{.r .cell-code}\nprint(parentsub)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   T1 Drought resistance T2 Yield\nP1                     7        5\nP2                     6        8\nP3                     5        6\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnewhybridtraits = HybridWeightsTranspose %*% parentsub\nprint(\"recalculated hybrid traits is\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"recalculated hybrid traits is\"\n```\n:::\n\n```{.r .cell-code}\nprint(newhybridtraits)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     T1 Drought resistance T2 Yield\n[1,]                   6.3      6.1\n```\n:::\n:::\n\n\nRemoving maturation trait does not provide insight about the maturation time of the three parent plants. The new matrix has one less column but the values of other two traits is unchanged.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Visulaization tasks\n\n# A heatmap of ParentTraits matrix\nheatmap(ParentTraits, Rowv=TRUE, Colv=TRUE, labRow= rownames(ParentTraits), labCol= colnames(ParentTraits), col=heat.colors(256), scale=\"none\", main=\"Heatmap of Three Traits of Three Parents\")\n```\n\n::: {.cell-output-display}\n![](solutions_files/figure-pdf/unnamed-chunk-31-1.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\n# A barplot of HybridTraits\nhybridtraitsvec = c(T1=6.3, T2=6.1, T3=3.9)\n\n\nbarplot(hybridtraitsvec, main=\"Hybrid values of each trait\", ylab=\"weighted Values of each trait\", col=c(\"lightblue\", \"lightgreen\", \"lightyellow\"))\n```\n\n::: {.cell-output-display}\n![](solutions_files/figure-pdf/unnamed-chunk-31-2.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\n## Interpretation Questions\n\nprint(\"The parent traits with more weight might affect hybrid’s performance more.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"The parent traits with more weight might affect hybrid’s performance more.\"\n```\n:::\n\n```{.r .cell-code}\nprint(\"I think the identity matrix serves as a control which is used to compare the matrix with itself\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"I think the identity matrix serves as a control which is used to compare the matrix with itself\"\n```\n:::\n\n```{.r .cell-code}\nequal_weights = matrix(c(0.3, 0.3, 0.3), nrow=1, byrow=TRUE)\nchange_in_hybrid_traits = equal_weights %*% ParentTraits\nprint(\"The change in hybrid weights will be\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"The change in hybrid weights will be\"\n```\n:::\n\n```{.r .cell-code}\nprint(change_in_hybrid_traits)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     T1 Drought resistance T2 Yield T3 Maturation time\n[1,]                   5.4      5.7                3.9\n```\n:::\n\n```{.r .cell-code}\nprint(\"I think this simple model ignores the influence of various abiotic and biotic factors such as environmental condition, diseases etc.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"I think this simple model ignores the influence of various abiotic and biotic factors such as environmental condition, diseases etc.\"\n```\n:::\n:::\n\n\n\n## Task 5: Lists\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Making a MasterList\nbioList = list(\nProteinConc = list(ProteinMatrix, WeightVector),\nProteinMap = list(GeneExpression, TranslationMatrix),\nPlant = list(ParentTraits, HybridWeights),\nAnimal = list(BullEBVs, EconomicWeights)\n)\n\nprint(bioList)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$ProteinConc\n$ProteinConc[[1]]\n        ProteinX ProteinY ProteinZ\nSample1        5        3        2\nSample2        7        6        4\n\n$ProteinConc[[2]]\n         Weight\nProteinX    0.5\nProteinY    1.0\nProteinZ    1.5\n\n\n$ProteinMap\n$ProteinMap[[1]]\n        GeneA GeneB GeneC\nSample1    10     8     5\nSample2    15    12    10\n\n$ProteinMap[[2]]\n      [,1] [,2] [,3]\nGeneA  1.5  0.0  0.0\nGeneB  0.0  1.2  0.0\nGeneC  0.0  0.0  1.8\n\n\n$Plant\n$Plant[[1]]\n   T1 Drought resistance T2 Yield T3 Maturation time\nP1                     7        5                  3\nP2                     6        8                  4\nP3                     5        6                  6\n\n$Plant[[2]]\n     [,1]\n[1,]  0.5\n[2,]  0.3\n[3,]  0.2\n\n\n$Animal\n$Animal[[1]]\n      Milk_yield Growth_rate Fertility\nBull1        400         1.2       0.8\nBull2        500         1.5       0.6\n\n$Animal[[2]]\n      [,1]\n[1,] 2e-03\n[2,] 5e+01\n[3,] 1e+02\n```\n:::\n\n```{.r .cell-code}\n# Task1\nprint(\"List of top level components:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"List of top level components:\"\n```\n:::\n\n```{.r .cell-code}\nprint(\"1. ProteinConc 2. ProteinMap 3. Plant 4. Animal\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1. ProteinConc 2. ProteinMap 3. Plant 4. Animal\"\n```\n:::\n\n```{.r .cell-code}\nprint(\"List of nested components:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"List of nested components:\"\n```\n:::\n\n```{.r .cell-code}\nprint(\"1. ProteinMatrix 2. WeightVector 3. GeneExpression 4. TranslationMatrix 5. ParentTraits 6. HybridWeights 7. BullEBVs 8.EconomicWeights\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1. ProteinMatrix 2. WeightVector 3. GeneExpression 4. TranslationMatrix 5. ParentTraits 6. HybridWeights 7. BullEBVs 8.EconomicWeights\"\n```\n:::\n\n```{.r .cell-code}\n# Task 2\nbioList[[2]][[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        GeneA GeneB GeneC\nSample1    10     8     5\nSample2    15    12    10\n```\n:::\n\n```{.r .cell-code}\nbioList[[2]][[2]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1] [,2] [,3]\nGeneA  1.5  0.0  0.0\nGeneB  0.0  1.2  0.0\nGeneC  0.0  0.0  1.8\n```\n:::\n\n```{.r .cell-code}\nbioList[[4]][[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Milk_yield Growth_rate Fertility\nBull1        400         1.2       0.8\nBull2        500         1.5       0.6\n```\n:::\n\n```{.r .cell-code}\nbioList[[4]][[2]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1]\n[1,] 2e-03\n[2,] 5e+01\n[3,] 1e+02\n```\n:::\n\n```{.r .cell-code}\nmatrix_of_plant_entry = bioList[[3]][[1]]\nprint(matrix_of_plant_entry)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   T1 Drought resistance T2 Yield T3 Maturation time\nP1                     7        5                  3\nP2                     6        8                  4\nP3                     5        6                  6\n```\n:::\n\n```{.r .cell-code}\nweight_for_protein_conc = bioList[[1]][[2]]\nprint(weight_for_protein_conc)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         Weight\nProteinX    0.5\nProteinY    1.0\nProteinZ    1.5\n```\n:::\n\n```{.r .cell-code}\n# Task 3\nWeighted_gene_expression_score = bioList[[1]][[1]] %*% bioList[[1]][[2]]\nprint(Weighted_gene_expression_score)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        Weight\nSample1    8.5\nSample2   15.5\n```\n:::\n\n```{.r .cell-code}\nContribution_of_transcripts_to_each_protein = bioList[[2]][[1]] %*% bioList[[2]][[2]]\nprint(Contribution_of_transcripts_to_each_protein)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        [,1] [,2] [,3]\nSample1 15.0  9.6    9\nSample2 22.5 14.4   18\n```\n:::\n\n```{.r .cell-code}\nHybrid_trait_values = t(bioList[[3]][[2]]) %*% bioList[[3]][[1]] \nprint(Hybrid_trait_values)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     T1 Drought resistance T2 Yield T3 Maturation time\n[1,]                   6.3      6.1                3.9\n```\n:::\n\n```{.r .cell-code}\nBull_total_economic_value = bioList[[4]][[1]] %*% bioList[[4]][[2]]\nprint(Bull_total_economic_value)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       [,1]\nBull1 140.8\nBull2 136.0\n```\n:::\n\n```{.r .cell-code}\n# Task 4\n\nsubset_BullEBVs = bioList[[4]][[1]][, 2:3]\nprint(subset_BullEBVs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Growth_rate Fertility\nBull1         1.2       0.8\nBull2         1.5       0.6\n```\n:::\n\n```{.r .cell-code}\nEcoweightsub = bioList[[4]][[2]][2:3, ]\nprint(Ecoweightsub)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  50 100\n```\n:::\n\n```{.r .cell-code}\nRecalculated_total_value = subset_BullEBVs %*% Ecoweightsub\nprint(Recalculated_total_value)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1]\nBull1  140\nBull2  135\n```\n:::\n\n```{.r .cell-code}\n## Visualization Tasks\n# Creating barplot showing the result of weighted trait aggregation for the Plant hybrid\nbarplot(Hybrid_trait_values, main=\"weighted trait aggregation for the Plant hybrid\", ylab=\"weighted Values of each trait\", col=c(\"salmon\"))\n```\n\n::: {.cell-output-display}\n![](solutions_files/figure-pdf/unnamed-chunk-32-1.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\n# Creating barplot showing the total breeding values for each bull\nbarplot(t(Bull_total_economic_value), main=\"Comparison of Total values of Bulls\", ylab=\"weighted Values of each trait\", col=c(\"lightblue\"))\n```\n\n::: {.cell-output-display}\n![](solutions_files/figure-pdf/unnamed-chunk-32-2.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\n# Creating heatmap\nheatmap(bioList[[4]][[1]], Rowv=TRUE, Colv=TRUE, labRow= rownames(bioList[[4]][[1]]), labCol= colnames(bioList[[4]][[1]]), col=heat.colors(256), scale= \"column\", main=\"Heatmap of Bull EBVs\")\n```\n\n::: {.cell-output-display}\n![](solutions_files/figure-pdf/unnamed-chunk-32-3.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\n## Interpretation Questions\nprint(\"Structuring data using a list help to logically organise different datatypes such as matrix, vector and list itself. Since each component is differently named, they can be easily accessed.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Structuring data using a list help to logically organise different datatypes such as matrix, vector and list itself. Since each component is differently named, they can be easily accessed.\"\n```\n:::\n\n```{.r .cell-code}\nprint(\"Nested lists require multiple levels of indexing where there is a higher chance of making mistakes with the indices such as using the wrong number of brackets or the wrong index number\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Nested lists require multiple levels of indexing where there is a higher chance of making mistakes with the indices such as using the wrong number of brackets or the wrong index number\"\n```\n:::\n\n```{.r .cell-code}\nprint(\"Yes, this structure could be scaled for real datasets with many samples or traits\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Yes, this structure could be scaled for real datasets with many samples or traits\"\n```\n:::\n\n```{.r .cell-code}\nprint(\"How would you loop over all elements in bioList to apply the same function? Not sure\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"How would you loop over all elements in bioList to apply the same function? Not sure\"\n```\n:::\n\n```{.r .cell-code}\nprint(\"How can this list structure be useful for building automated bioinformatics pipelines? Not sure\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"How can this list structure be useful for building automated bioinformatics pipelines? Not sure\"\n```\n:::\n:::\n",
    "supporting": [
      "solutions_files/figure-pdf"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}