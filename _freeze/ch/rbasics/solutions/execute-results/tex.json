{
  "hash": "76966d595b1826454e8a26851feb479c",
  "result": {
    "markdown": "---\ntitle: \"HW solutions\"\nabstract: \"dataframe, matrices, list, factor, vector, etc.\"\n---\n\n\n  \n<style>\n  .content {\n    text-align: justify !important;\n  }\n  p {\n    text-align: justify !important;\n  }\n  .quarto-body {\n    text-align: justify !important;\n  }\n</style>\n\n# L3: Matrices and Lists\n\n## Task 1: Protein Quantification in Biological Samples\n\nWe measured the concentration (in Âµg/ÂµL) of three proteins (P1, P2, P3) in four samples (S1â€“S4):\n\n### 1. Matrices\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Making Protein Matrix\nProteinMatrix <- matrix(\n  c(5, 3, 2,\n    7, 6, 4),\n  nrow = 2, byrow = TRUE\n)\nrownames(ProteinMatrix) = c(\"Sample1\", \"Sample2\")\ncolnames(ProteinMatrix) = c(\"ProteinX\", \"ProteinY\", \"ProteinZ\")\nProteinMatrix\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        ProteinX ProteinY ProteinZ\nSample1        5        3        2\nSample2        7        6        4\n```\n:::\n:::\n\n\nNow goes the weight matrix\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Making weight matrix\nWeightVector <- matrix(\n  c(0.5, 1.0, 1.5),\n  nrow=3, byrow = TRUE\n)\nrownames(WeightVector) = c(\"ProteinX\", \"ProteinY\", \"ProteinZ\")\ncolnames(WeightVector) = c(\"Weight\")\nWeightVector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         Weight\nProteinX    0.5\nProteinY    1.0\nProteinZ    1.5\n```\n:::\n:::\n\n\n\nNow, multiply them.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Multiplying Matrices\nTotalConc = ProteinMatrix %*% WeightVector\ncolnames(TotalConc) <- \"Total_Protein_Conc\"\nprint(TotalConc)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        Total_Protein_Conc\nSample1                8.5\nSample2               15.5\n```\n:::\n:::\n\n\n\n### 2. Making transpose of ProteinMatrix\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nProteinMatTranspose = t(ProteinMatrix)\nProteinMatTranspose\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         Sample1 Sample2\nProteinX       5       7\nProteinY       3       6\nProteinZ       2       4\n```\n:::\n:::\n\n\n### 3. Identity Matrix\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nI <- diag(3)\nIdentitycheck = ProteinMatrix %*% I\ncolnames(Identitycheck) <- c(\"ProteinX\", \"ProteinY\", \"ProteinZ\")\nIdentitycheck\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        ProteinX ProteinY ProteinZ\nSample1        5        3        2\nSample2        7        6        4\n```\n:::\n:::\n\n\n\n### 4.1. Total Protein per Sample\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrowSums(ProteinMatrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSample1 Sample2 \n     10      17 \n```\n:::\n:::\n\n\n\n### 4.2. Total Protein per Protein Type\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolSums(ProteinMatrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nProteinX ProteinY ProteinZ \n      12        9        6 \n```\n:::\n:::\n\n\n\n### 4.3. Heatmap of Protein Concentrations\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nheatmap(ProteinMatrix, scale = \"none\", col = heat.colors(10))\n```\n\n::: {.cell-output-display}\n![](solutions_files/figure-pdf/unnamed-chunk-8-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n### ðŸ§  Interpretation\n\n- Multiplying the protein levels by the weight vector shows how much each protein contributes in a sample. The result shows total protein concentration per sample.\n- The result shows that sample S2 has the highest protein burden.\n- The identity matrix represents no protein interactions or measurement biases. It is a simple matrix calculation.\n- New calculation:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# changing the weight of ProteinZ to 3.0\nnewweightvector = matrix(\n  c(0.5, 1.0, 3.0),\n  nrow=3, byrow = TRUE\n)\nrownames(WeightVector) = c(\"ProteinX\", \"ProteinY\", \"ProteinZ\")\ncolnames(WeightVector) = c(\"Weight\")\nnewTotalconc = ProteinMatrix %*% newweightvector\ncolnames(newTotalconc) <- \"Total_Protein_Conc\"\nnewTotalconc\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        Total_Protein_Conc\nSample1               11.5\nSample2               21.5\n```\n:::\n:::\n\n\nStill, S2 has more protein burden.\n\nBonus:\n\n- Heatmap reveals PX is most abundant across all samples.\n\n---\n\n## Task 2: Gene-to-Protein Translation\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# making  Gene Expression matrix\nGeneExpression <- matrix(\n  c(10, 8, 5,\n    15, 12, 10),\n  nrow = 2, byrow = TRUE\n)\nrownames(GeneExpression) <- c(\"Sample1\", \"Sample2\")\ncolnames(GeneExpression) <- c(\"GeneA\", \"GeneB\", \"GeneC\")\nGeneExpression\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        GeneA GeneB GeneC\nSample1    10     8     5\nSample2    15    12    10\n```\n:::\n:::\n\n\n\nTranslation efficiency:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# making Translation Matrix\nTranslationMatrix <- matrix(\n  c(1.5, 0 , 0,\n  0, 1.2, 0,\n  0, 0, 1.8),\nnrow = 3, byrow = TRUE\n)\n\nrownames(TranslationMatrix) <- c(\"GeneA\", \"GeneB\", \"GeneC\")\ncolnames(TranslationMatrix) <- c(\"protA\", \"protB\", \"protC\")\nTranslationMatrix\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      protA protB protC\nGeneA   1.5   0.0   0.0\nGeneB   0.0   1.2   0.0\nGeneC   0.0   0.0   1.8\n```\n:::\n:::\n\n\n\n### Protein Output\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# computing Protein matrix\nProtein_matrix <- GeneExpression %*% TranslationMatrix\ncolnames(Protein_matrix) <- c(\"total_protA\", \"total_protB\", \"total_protC\")\nprint(Protein_matrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        total_protA total_protB total_protC\nSample1        15.0         9.6           9\nSample2        22.5        14.4          18\n```\n:::\n:::\n\n\n### 2. Transpose\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Transpose of GeneExpression matrix\nGeneExpression_Transpose <- t(GeneExpression)\nGeneExpression_Transpose\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Sample1 Sample2\nGeneA      10      15\nGeneB       8      12\nGeneC       5      10\n```\n:::\n:::\n\n\nThe new matrix represnts a matrix where the rows and columns of GeneExpression matrix have been interchanged.\n\n### 3. Identity matrix and multipliccation\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Creating Identity matrix\nI <- diag(3)\nI\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    0    0\n[2,]    0    1    0\n[3,]    0    0    1\n```\n:::\n:::\n\n\nNow, multiply:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nProduct_matrix = TranslationMatrix %*%  I \nProduct_matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1] [,2] [,3]\nGeneA  1.5  0.0  0.0\nGeneB  0.0  1.2  0.0\nGeneC  0.0  0.0  1.8\n```\n:::\n:::\n\n\nThe product is identical to TranslationMatrix\n\n### 4. Sub-matrix:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# making submatrix A\nA = matrix(\n  c(10, 8,\n    15, 12), nrow=2, byrow = TRUE\n)\nrownames(A) = c(\"sample1\", \"sample2\")\ncolnames(A) = c(\"GeneA\", \"GeneB\")\n\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        GeneA GeneB\nsample1    10     8\nsample2    15    12\n```\n:::\n\n```{.r .cell-code}\n# finding inverse of A\n#inv_A <- solve(A)\n#inv_A\n```\n:::\n\n\nThe inverse matrix could not be calculated since A is a singular matrix.\nSo, A * A^-1 is also not possible.\n\n### Visualization tasks:\n\n- 1. MARplot\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# generating MARplot-style scatter plot\nplot(GeneExpression, Protein_matrix, type=\"p\", main=\"Protein level vs. Gene Expression level\")\nlabels <- \"Sample-Gene\"\ntext(GeneExpression, Protein_matrix, labels = labels, pos=3)\n```\n\n::: {.cell-output-display}\n![](solutions_files/figure-pdf/unnamed-chunk-17-1.pdf){fig-pos='H'}\n:::\n\n```{.r .cell-code}\n# generating a heatmap\nheatmap(Protein_matrix, main= \"Heatmap of Protein Level\", Rowv = TRUE, Colv = TRUE, labRow= rownames(Protein_matrix), labCol= c(\"ProteinA\", \"ProteinB\", \"ProteinC\"), col=topo.colors(256) )\n```\n\n::: {.cell-output-display}\n![](solutions_files/figure-pdf/unnamed-chunk-17-2.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n- 2. Heatmap of Expression:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nheatmap(GeneExpression, col = terrain.colors(10), scale = \"column\")\n```\n\n::: {.cell-output-display}\n![](solutions_files/figure-pdf/unnamed-chunk-18-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n### ðŸ§  Interpretation\n\n1. Matrix multiplication allows each gene in both samples to be multiplied to their respective translation efficiency. So, the product shows how successfully each gene is translated\")\n\n2. The diagonal TranslationMatrix make sense biologically because they show translation efficiency of each gene and there is no other interaction between them. Although there could be interaction in real-world scenarios.\n\n3. If Sample2 has higher protein levels even with similar gene expression, it means that more mRNAs are translated to proteins compared to Sample1\"\n\n4. The upward trend in MARplot may indicate an increase in translation efficacy and downward trend may indicate a decline in translation efficacy\"\n\n5. Clustering in the heatmap may suggest which samples are most similar to each other based on their prot.\n\n\n## Task 3: Animal Breeding â€“ Bull Ranking by Economic Traits\n\n### Define Data\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define Bull EBVs\nBullEBVs <- matrix(c(\n  400, 1.2, 0.8,\n  500, 1.5, 0.6\n), nrow = 2, byrow = TRUE)\n\nrownames(BullEBVs) <- c(\"Bull1\", \"Bull2\")\ncolnames(BullEBVs) <- c(\"Milk_yield\", \"Growth_rate\", \"Fertility\")\nBullEBVs\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Milk_yield Growth_rate Fertility\nBull1        400         1.2       0.8\nBull2        500         1.5       0.6\n```\n:::\n\n```{.r .cell-code}\n# Define Economic Weights\nEconomicWeights <- matrix(c(0.002, 50, 100), ncol = 1)\nrownames(EconomicWeights) <- colnames(BullEBVs)\ncolnames(EconomicWeights) <- c(\"Weight\")\nEconomicWeights\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            Weight\nMilk_yield   2e-03\nGrowth_rate  5e+01\nFertility    1e+02\n```\n:::\n:::\n\n\n### Compute Total Economic Value\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTotalValue <- BullEBVs %*% EconomicWeights\ncolnames(TotalValue) <- c(\"Merit\")\nTotalValue\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Merit\nBull1 140.8\nBull2 136.0\n```\n:::\n:::\n\n\n\n**Interpretation**\n\nBull1: (400 Ã— 0.002) + (1.2 Ã— 50) + (0.8 Ã— 100) = 140.8\n\nBull2: (500 Ã— 0.002) + (1.5 Ã— 50) + (0.6 Ã— 100) = 136.0\n\nBull1 is more valuable economically.\n\n**Biological Interpretation**\n\nEconomic weights convert genetic merit (EBVs, Estimated Breeding Values) into economic merit. Traits with higher financial importance have a larger impact, regardless of absolute EBV values.\n\n### Multiply with Identity Matrix\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nI3 <- diag(3)\nrownames(I3) <- colnames(BullEBVs)\ncolnames(I3) <- colnames(BullEBVs)\nI3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n            Milk_yield Growth_rate Fertility\nMilk_yield           1           0         0\nGrowth_rate          0           1         0\nFertility            0           0         1\n```\n:::\n\n```{.r .cell-code}\nBullEBVs_identity <- BullEBVs %*% I3\nBullEBVs_identity\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Milk_yield Growth_rate Fertility\nBull1        400         1.2       0.8\nBull2        500         1.5       0.6\n```\n:::\n:::\n\n\n\n**Interpretation**\n\nMultiplying by identity matrix returns the original matrix. It confirms that EBV structure is preserved.\n\n### Remove Milk Yield and Recalculate Total Value\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nBullEBVs_noMilk <- BullEBVs[, -1]\nEconomicWeights_noMilk <- EconomicWeights[2:3, , drop = FALSE]\n\nTotalValue_noMilk <- BullEBVs_noMilk %*% EconomicWeights_noMilk\ncolnames(TotalValue_noMilk) <- c(\"New_Merit\")\nTotalValue_noMilk\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      New_Merit\nBull1       140\nBull2       135\n```\n:::\n:::\n\n\n\n**Interpretation**\n\nBull1: (1.2 Ã— 50) + (0.8 Ã— 100) = 140\n\nBull2: (1.5 Ã— 50) + (0.6 Ã— 100) = 135\n\nBull1 still ranks higher, but by a smaller margin.\n\n### Bar Plot: Total Economic Value\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbarplot(\n  TotalValue,\n  beside = TRUE,\n  names.arg = rownames(BullEBVs),\n  col = c(\"skyblue\", \"orange\"),\n  main = \"Total Economic Value of Bulls\",\n  ylab = \"Total Value\"\n)\n```\n\n::: {.cell-output-display}\n![](solutions_files/figure-pdf/unnamed-chunk-23-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n### Heatmap of EBVs\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nheatmap(\n  BullEBVs,\n  Rowv = NA,\n  Colv = NA,\n  scale = \"none\",\n  col = heat.colors(256),\n  main = \"Heatmap of Bull EBVs\"\n)\n```\n\n::: {.cell-output-display}\n![](solutions_files/figure-pdf/unnamed-chunk-24-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n### ðŸ§  Interpretation Questions\n\n- How do economic weights affect trait importance?\n\nTraits with higher weights contribute more to the total economic value. This makes them more influential in ranking and selection.\n\n- Why might you ignore milk yield?\n\nMilk yield may be excluded in systems focusing on fertility, growth, or when it is no longer a limiting factor. Environmental or economic contexts may also shift trait priorities.\n\n- What is the value of heatmaps?\n\nHeatmaps visually compare EBVs across bulls and traits.They help detect patterns, outliers, and clusters easily in multivariate data.\n\n- Can this method be extended to more bulls and traits?\n\nYes. This method scales to any number of bulls or traits. Just ensure the EBVs matrix and economic weights are dimensionally compatible.\n\n\n## Task 4: Plant Breeding â€“ Trait Contributions from Parental Lines\n\n### Define Data\n\n**Parent trait values (normalized 1â€“10)**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nParentTraits <- matrix(c(\n  7, 5, 3,\n  6, 8, 4,\n  5, 6, 6\n), nrow = 3, byrow = TRUE)\n\nrownames(ParentTraits) <- c(\"P1\", \"P2\", \"P3\")\ncolnames(ParentTraits) <- c(\"Drought_resistance\", \"Yield\", \"Maturation_time\")\nParentTraits\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Drought_resistance Yield Maturation_time\nP1                  7     5               3\nP2                  6     8               4\nP3                  5     6               6\n```\n:::\n\n```{.r .cell-code}\n# Define Hybrid Weights\nHybridWeights <- matrix(c(0.5, 0.3, 0.2), nrow = 1)\ncolnames(HybridWeights) <- colnames(ParentTraits)\nrownames(HybridWeights) <- c(\"Weight\")\nHybridWeights\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       Drought_resistance Yield Maturation_time\nWeight                0.5   0.3             0.2\n```\n:::\n:::\n\n\n\n### Compute HybridTraits Vector\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nHybridTraits <- HybridWeights %*% ParentTraits\nrownames(HybridTraits) <- c(\"Contribution\")\ncolnames(HybridTraits) <- rownames(ParentTraits)\nHybridTraits\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n              P1  P2  P3\nContribution 6.3 6.1 3.9\n```\n:::\n:::\n\n\n**Interpretation**\n\nHybridTraits = (0.5 Ã— P1) + (0.3 Ã— P2) + (0.2 Ã— P3)\n\nDrought_resistance = (0.5 Ã— 7) + (0.3 Ã— 6) + (0.2 Ã— 5) = 6.3\n\nYield = (0.5 Ã— 5) + (0.3 Ã— 8) + (0.2 Ã— 6) = 6.1\n\nMaturation_time = (0.5 Ã— 3) + (0.3 Ã— 4) + (0.2 Ã— 6) = 3.9\n\nThe hybrid is moderately strong in drought resistance and yield, and has a relatively shorter maturation time.\n\n**Biological Meaning of Unequal Contribution**\n\nWhen one parent contributes more to a trait, it suggests that the trait's heritable strength comes disproportionately from that parent. Breeders can use this knowledge to amplify desirable traits using the best parent.\n\n### Multiply with Identity Matrix\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nI3 <- diag(3)\nParentTraits_identity <- ParentTraits %*% I3\ncolnames(ParentTraits_identity) <- colnames(ParentTraits)\nParentTraits_identity\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Drought_resistance Yield Maturation_time\nP1                  7     5               3\nP2                  6     8               4\nP3                  5     6               6\n```\n:::\n:::\n\n\n\n**Interpretation**\n\nMultiplying by identity matrix returns the original matrix. This operation verifies structural consistency and dimensionality.\n\n### Remove T3 (Maturation Time) and Recalculate\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nParentTraits_T1T2 <- ParentTraits[, 1:2]\nParentTraits_T1T2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Drought_resistance Yield\nP1                  7     5\nP2                  6     8\nP3                  5     6\n```\n:::\n\n```{.r .cell-code}\nHybridTraits_T1T2 <- HybridWeights %*% ParentTraits_T1T2\nHybridTraits_T1T2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       Drought_resistance Yield\nWeight                6.3   6.1\n```\n:::\n:::\n\n\n\n**Interpretation**\n\nDrought_resistance = (0.5 Ã— 7) + (0.3 Ã— 6) + (0.2 Ã— 5) = 6.3\n\nYield = (0.5 Ã— 5) + (0.3 Ã— 8) + (0.2 Ã— 6) = 6.1\n\nRemoving a trait (T3) changes the trait profile. Hybrid selection may now favor traits that remain.\n\n### Heatmap of ParentTraits\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nheatmap(\n  ParentTraits,\n  Rowv = NA,\n  Colv = NA,\n  scale = \"none\",\n  col = heat.colors(256),\n  main = \"Heatmap of Parent Traits\"\n)\n```\n\n::: {.cell-output-display}\n![](solutions_files/figure-pdf/unnamed-chunk-29-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n### Bar Plot of Hybrid Traits\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbarplot(\n  HybridTraits,\n  beside = TRUE,\n  names.arg = colnames(ParentTraits),\n  col = c(\"#66c2a5\", \"#fc8d62\", \"#8da0cb\"),\n  main = \"Hybrid Trait Profile\",\n  ylab = \"Trait Value\"\n)\n```\n\n::: {.cell-output-display}\n![](solutions_files/figure-pdf/unnamed-chunk-30-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n### ðŸ§  Interpretation Questions\n\n- How does the weighting of parents affect the hybrid's performance?\n\n  Stronger weights mean more genetic contribution. Traits from highly weighted parents dominate the hybrid profile.\n\n- What does the identity matrix represent here?\n\n  It represents a neutral transformation. It confirms data integrity when used in matrix multiplication.\n\n- If you used equal weights (â…“ for each), how would the hybrid traits change?\n\n  Traits would reflect an even mix, potentially leading to balanced but less specialized performance.\n\n- What real-world limitations does this simplified model ignore?\n\n  i. Non-additive genetic effects (dominance, epistasis)\n\n  ii. Environmental interactions\n\n  iii. Trait heritability and correlations\n\n  iv. Breeding feasibility and cost\n\n## Task 5: Managing Matrices and Weight Vectors Using Lists in R\n\nNow that we've explored trait-based decisions using matrices, it's time to organize our work using R's list structure. Lists help bundle related objects like matrices and weight vectors, keeping the analysis modular and scalable.\n\n### Create a Master List\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Assuming previous matrices and weights are already defined:\n\n# Making a MasterList\nbioList = list(\n  ProteinConc = list(matrix = ProteinMatrix, weights = WeightVector),\n  ProteinMap  = list(matrix = GeneExpression, weights = TranslationMatrix),\n  Animal = list(matrix = BullEBVs, weights = EconomicWeights),\n  Plant = list(matrix = ParentTraits, weights = HybridWeights)\n)\n\nprint(bioList)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$ProteinConc\n$ProteinConc$matrix\n        ProteinX ProteinY ProteinZ\nSample1        5        3        2\nSample2        7        6        4\n\n$ProteinConc$weights\n         Weight\nProteinX    0.5\nProteinY    1.0\nProteinZ    1.5\n\n\n$ProteinMap\n$ProteinMap$matrix\n        GeneA GeneB GeneC\nSample1    10     8     5\nSample2    15    12    10\n\n$ProteinMap$weights\n      protA protB protC\nGeneA   1.5   0.0   0.0\nGeneB   0.0   1.2   0.0\nGeneC   0.0   0.0   1.8\n\n\n$Animal\n$Animal$matrix\n      Milk_yield Growth_rate Fertility\nBull1        400         1.2       0.8\nBull2        500         1.5       0.6\n\n$Animal$weights\n            Weight\nMilk_yield   2e-03\nGrowth_rate  5e+01\nFertility    1e+02\n\n\n$Plant\n$Plant$matrix\n   Drought_resistance Yield Maturation_time\nP1                  7     5               3\nP2                  6     8               4\nP3                  5     6               6\n\n$Plant$weights\n       Drought_resistance Yield Maturation_time\nWeight                0.5   0.3             0.2\n```\n:::\n:::\n\n\n\n### List the Structure\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(bioList)               # Top-level list names\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"ProteinConc\" \"ProteinMap\"  \"Animal\"      \"Plant\"      \n```\n:::\n\n```{.r .cell-code}\nlengths(bioList)             # Number of components in each sublist\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nProteinConc  ProteinMap      Animal       Plant \n          2           2           2           2 \n```\n:::\n:::\n\n\n\n**Interpretation**\n\nEach top-level entry (e.g., ProteinConc, Plant) contains two components:\n\n- A matrix (e.g., ProteinMatrix)\n- A corresponding weight vector or matrix\n\n### Indexing Elements from Lists\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Access the trait matrix for Plant\nbioList$Plant[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Drought_resistance Yield Maturation_time\nP1                  7     5               3\nP2                  6     8               4\nP3                  5     6               6\n```\n:::\n\n```{.r .cell-code}\n#or\nbioList$Plant$matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Drought_resistance Yield Maturation_time\nP1                  7     5               3\nP2                  6     8               4\nP3                  5     6               6\n```\n:::\n\n```{.r .cell-code}\n# Access the weight vector for ProteinConc\nbioList$ProteinConc[[2]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         Weight\nProteinX    0.5\nProteinY    1.0\nProteinZ    1.5\n```\n:::\n\n```{.r .cell-code}\n#or\nbioList$ProteinConc$weights\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         Weight\nProteinX    0.5\nProteinY    1.0\nProteinZ    1.5\n```\n:::\n:::\n\n\n\n**Interpretation**\n\nUse double brackets [[ ]] to extract unnamed list elements by position. But we named our list, so they are easily extractable using the `$` notation.\n\n### Perform Weighted Calculations\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Protein concentration score\nbioList$ProteinConc$matrix %*% bioList$ProteinConc$weights\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        Weight\nSample1    8.5\nSample2   15.5\n```\n:::\n\n```{.r .cell-code}\n# Gene â†’ Protein contribution\nbioList$ProteinMap$matrix %*% bioList$ProteinMap$weights\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        protA protB protC\nSample1  15.0   9.6     9\nSample2  22.5  14.4    18\n```\n:::\n\n```{.r .cell-code}\n# Bull economic value\nbioList$Animal$matrix %*% bioList$Animal$weights\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Weight\nBull1  140.8\nBull2  136.0\n```\n:::\n\n```{.r .cell-code}\n# Hybrid trait value\nbioList$Plant$weights %*% bioList$Plant$matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       Drought_resistance Yield Maturation_time\nWeight                6.3   6.1             3.9\n```\n:::\n:::\n\n\n\n### Subset and Recalculate\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Remove last trait from ParentTraits\nParentSubset <- bioList$Plant$matrix[, 1:2]\nNewWeights <- matrix(c(0.6, 0.4), nrow = 2)\n\n# Recalculated hybrid score\nSubsetHybridScore <- ParentSubset %*% NewWeights\nSubsetHybridScore\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   [,1]\nP1  6.2\nP2  6.8\nP3  5.4\n```\n:::\n:::\n\n\n\n**Interpretation**\n\nDropping a trait and reweighting highlights its influence in trait aggregation and selection.\n\n### Visualization Tasks\n\n#### Heatmap: Gene Expression\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nheatmap(\n  bioList$ProteinMap$matrix,\n  scale = \"none\",\n  col = heat.colors(256),\n  main = \"Gene Expression Heatmap\",\n  xlab = \"Proteins\",\n  ylab = \"Genes\"\n)\n```\n\n::: {.cell-output-display}\n![](solutions_files/figure-pdf/unnamed-chunk-36-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n#### Bar Plots\n\n##### Hybrid traits\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbarplot(\n  bioList$Plant$weights %*% bioList$Plant$matrix,\n  beside = TRUE,\n  main = \"Hybrid Trait Contributions\",\n  col = \"#66c2a5\",\n  ylab = \"Score\"\n)\n```\n\n::: {.cell-output-display}\n![](solutions_files/figure-pdf/unnamed-chunk-37-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n##### Bull EBV (Economic Breeding Values)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbarplot(\n  bioList$Animal$matrix %*% bioList$Animal$weights,\n  beside = TRUE,\n  main = \"Bull EBVs (Economic Values)\",\n  col = \"#fc8d62\",\n  ylab = \"Score\"\n)\n```\n\n::: {.cell-output-display}\n![](solutions_files/figure-pdf/unnamed-chunk-38-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n\n### ðŸ§  Interpretation Questions\n\n- Why use a list structure?\n\nKeeps each dataset and its weights together.\nFacilitates automated workflows and reuse.\n\n- Whatâ€™s tricky about `[[ ]]` access?\n\nYou must remember the order (`[[1]]` = `matrix`, `[[2]]` = `weights`).\nNo names means you can't use $matrix, only positional access.\n\nLoop across all list entries\n\nWeighted scores for all entries\n`lapply(bioList, function(x) x[[2]] %*% x[[1]])`\n\n- How does this help in large-scale pipelines?\n\nYou can use this format with `lapply()`, `purrr::map()`, or in targets pipelines for reproducibility and modular processing.\n",
    "supporting": [
      "solutions_files/figure-pdf"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}