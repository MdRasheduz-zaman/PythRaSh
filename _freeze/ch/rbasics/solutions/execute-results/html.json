{
  "hash": "97f2fb574fbdaa363a2d11ae3d70456d",
  "result": {
    "markdown": "---\ntitle: \"HW solutions\"\nabstract: \"dataframe, matrices, list, factor, vector, etc.\"\n---\n\n  \n<style>\n  .content {\n    text-align: justify !important;\n  }\n  p {\n    text-align: justify !important;\n  }\n  .quarto-body {\n    text-align: justify !important;\n  }\n</style>\n\n# L3: Matrices and Lists\n\n## Task 1: Protein Concentration in Samples\n\nWe measured the concentration (in µg/µL) of three proteins (P1, P2, P3) in four samples (S1–S4):\n\n### 1. Matrices\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Making Protein Matrix\nProteinMatrix <- matrix(\n  c(5, 3, 2,\n    7, 6, 4),\n  nrow = 2, byrow = TRUE\n)\nrownames(ProteinMatrix) = c(\"Sample1\", \"Sample2\")\ncolnames(ProteinMatrix) = c(\"ProteinX\", \"ProteinY\", \"ProteinZ\")\nProteinMatrix\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        ProteinX ProteinY ProteinZ\nSample1        5        3        2\nSample2        7        6        4\n```\n:::\n:::\n\nNow goes the weight matrix\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Making weight matrix\nWeightVector <- matrix(\n  c(0.5, 1.0, 1.5),\n  nrow=3, byrow = TRUE\n)\nrownames(WeightVector) = c(\"ProteinX\", \"ProteinY\", \"ProteinZ\")\ncolnames(WeightVector) = c(\"Weight\")\nWeightVector\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         Weight\nProteinX    0.5\nProteinY    1.0\nProteinZ    1.5\n```\n:::\n:::\n\n\nNow, multiply them.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Multiplying Matrices\nTotalConc = ProteinMatrix %*% WeightVector\ncolnames(TotalConc) <- \"Total_Protein_Conc\"\nprint(TotalConc)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        Total_Protein_Conc\nSample1                8.5\nSample2               15.5\n```\n:::\n:::\n\n\n### 2. Making transpose of ProteinMatrix\n\n\n::: {.cell}\n\n```{.r .cell-code}\nProteinMatTranspose = t(ProteinMatrix)\nProteinMatTranspose\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         Sample1 Sample2\nProteinX       5       7\nProteinY       3       6\nProteinZ       2       4\n```\n:::\n:::\n\n### 3. Identity Matrix\n\n\n::: {.cell}\n\n```{.r .cell-code}\nI <- diag(3)\nIdentitycheck = ProteinMatrix %*% I\ncolnames(Identitycheck) <- c(\"ProteinX\", \"ProteinY\", \"ProteinZ\")\nIdentitycheck\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        ProteinX ProteinY ProteinZ\nSample1        5        3        2\nSample2        7        6        4\n```\n:::\n:::\n\n\n### 4.1. Total Protein per Sample\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrowSums(ProteinMatrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSample1 Sample2 \n     10      17 \n```\n:::\n:::\n\n\n### 4.2. Total Protein per Protein Type\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolSums(ProteinMatrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nProteinX ProteinY ProteinZ \n      12        9        6 \n```\n:::\n:::\n\n\n### 4.3. Heatmap of Protein Concentrations\n\n\n::: {.cell}\n\n```{.r .cell-code}\nheatmap(ProteinMatrix, scale = \"none\", col = heat.colors(10))\n```\n\n::: {.cell-output-display}\n![](solutions_files/figure-html/unnamed-chunk-8-1.png){width=1650}\n:::\n:::\n\n\n### Interpretation\n\n- Multiplying the protein levels by the weight vector shows how much each protein contributes in a sample. The result shows total protein concentration per sample.\n- The result shows that sample S2 has the highest protein burden.\n- The identity matrix represents no protein interactions or measurement biases. It is a simple matrix calculation.\n- New calculation:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# changing the weight of ProteinZ to 3.0\nnewweightvector = matrix(\n  c(0.5, 1.0, 3.0),\n  nrow=3, byrow = TRUE\n)\nrownames(WeightVector) = c(\"ProteinX\", \"ProteinY\", \"ProteinZ\")\ncolnames(WeightVector) = c(\"Weight\")\nnewTotalconc = ProteinMatrix %*% newweightvector\ncolnames(newTotalconc) <- \"Total_Protein_Conc\"\nnewTotalconc\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        Total_Protein_Conc\nSample1               11.5\nSample2               21.5\n```\n:::\n:::\n\nStill, S2 has more protein burden.\n\nBonus:\n\n- Heatmap reveals PX is most abundant across all samples.\n\n---\n\n## Task 2: Gene-to-Protein Translation\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# making  Gene Expression matrix\nGeneExpression <- matrix(\n  c(10, 8, 5,\n    15, 12, 10),\n  nrow = 2, byrow = TRUE\n)\nrownames(GeneExpression) <- c(\"Sample1\", \"Sample2\")\ncolnames(GeneExpression) <- c(\"GeneA\", \"GeneB\", \"GeneC\")\nGeneExpression\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        GeneA GeneB GeneC\nSample1    10     8     5\nSample2    15    12    10\n```\n:::\n:::\n\n\nTranslation efficiency:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# making Translation Matrix\nTranslationMatrix <- matrix(\n  c(1.5, 0 , 0,\n  0, 1.2, 0,\n  0, 0, 1.8),\nnrow = 3, byrow = TRUE\n)\n\nrownames(TranslationMatrix) <- c(\"GeneA\", \"GeneB\", \"GeneC\")\nTranslationMatrix\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1] [,2] [,3]\nGeneA  1.5  0.0  0.0\nGeneB  0.0  1.2  0.0\nGeneC  0.0  0.0  1.8\n```\n:::\n:::\n\n\n### Protein Output\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# computing Protein matrix\nProtein_matrix <- GeneExpression %*% TranslationMatrix\nprint(Protein_matrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        [,1] [,2] [,3]\nSample1 15.0  9.6    9\nSample2 22.5 14.4   18\n```\n:::\n:::\n\n### 2. Transpose\n\n::: {.cell}\n\n```{.r .cell-code}\n# Transpose of GeneExpression matrix\nGeneExpression_Transpose <- t(GeneExpression)\nGeneExpression_Transpose\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Sample1 Sample2\nGeneA      10      15\nGeneB       8      12\nGeneC       5      10\n```\n:::\n:::\n\nThe new matrix represnts a matrix where the rows and columns of GeneExpression matrix have been interchanged.\n\n### 3. Identity matrix and multipliccation\n\n::: {.cell}\n\n```{.r .cell-code}\n# Creating Identity matrix\nI <- diag(3)\nI\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    0    0\n[2,]    0    1    0\n[3,]    0    0    1\n```\n:::\n:::\n\nNow, multiply:\n\n::: {.cell}\n\n```{.r .cell-code}\nProduct_matrix = TranslationMatrix %*%  I \nProduct_matrix\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1] [,2] [,3]\nGeneA  1.5  0.0  0.0\nGeneB  0.0  1.2  0.0\nGeneC  0.0  0.0  1.8\n```\n:::\n:::\n\nThe product is identical to TranslationMatrix\n\n### 4. Sub-matrix:\n\n::: {.cell}\n\n```{.r .cell-code}\n# making submatrix A\nA = matrix(\n  c(10, 8,\n    15, 12), nrow=2, byrow = TRUE\n)\nrownames(A) = c(\"sample1\", \"sample2\")\ncolnames(A) = c(\"GeneA\", \"GeneB\")\n\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        GeneA GeneB\nsample1    10     8\nsample2    15    12\n```\n:::\n\n```{.r .cell-code}\n# finding inverse of A\n#inv_A <- solve(A)\n#inv_A\n```\n:::\n\nThe inverse matrix could not be calculated since A is a singular matrix.\nSo, A * A^-1 is also not possible.\n\n### Visualization tasks:\n\n- 1. MARplot\n\n::: {.cell}\n\n```{.r .cell-code}\n# generating MARplot-style scatter plot\nplot(GeneExpression, Protein_matrix, type=\"p\", main=\"Protein level vs. Gene Expression level\")\nlabels <- \"Sample-Gene\"\ntext(GeneExpression, Protein_matrix, labels = labels, pos=3)\n```\n\n::: {.cell-output-display}\n![](solutions_files/figure-html/unnamed-chunk-17-1.png){width=1650}\n:::\n\n```{.r .cell-code}\n# generating a heatmap\nheatmap(Protein_matrix, main= \"Heatmap of Protein Level\", Rowv = TRUE, Colv = TRUE, labRow= rownames(Protein_matrix), labCol= c(\"ProteinA\", \"ProteinB\", \"ProteinC\"), col=topo.colors(256) )\n```\n\n::: {.cell-output-display}\n![](solutions_files/figure-html/unnamed-chunk-17-2.png){width=1650}\n:::\n:::\n\n\n- 2. Heatmap of Expression:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nheatmap(GeneExpression, col = terrain.colors(10), scale = \"column\")\n```\n\n::: {.cell-output-display}\n![](solutions_files/figure-html/unnamed-chunk-18-1.png){width=1650}\n:::\n:::\n\n### Interpretation\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(\"1. Matrix multiplication allows each gene in both samples to be multiplied to their respective translation efficiency. So, the product shows how successfully each gene is translated\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1. Matrix multiplication allows each gene in both samples to be multiplied to their respective translation efficiency. So, the product shows how successfully each gene is translated\"\n```\n:::\n\n```{.r .cell-code}\nprint(\"2. The diagonal TranslationMatrix make sense biologically because they show translation efficiency of each gene and there is no other interaction between them. Although there could be interaction in real-world scenarios.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2. The diagonal TranslationMatrix make sense biologically because they show translation efficiency of each gene and there is no other interaction between them. Although there could be interaction in real-world scenarios.\"\n```\n:::\n\n```{.r .cell-code}\nprint(\"3. If Sample2 has higher protein levels even with similar gene expression, it means that more mRNAs are translated to proteins compared to Sample1\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"3. If Sample2 has higher protein levels even with similar gene expression, it means that more mRNAs are translated to proteins compared to Sample1\"\n```\n:::\n\n```{.r .cell-code}\nprint(\"4. The upward trend in MARplot may indicate an increase in translation efficacy and downward trend may indicate a decline in translation efficacy\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"4. The upward trend in MARplot may indicate an increase in translation efficacy and downward trend may indicate a decline in translation efficacy\"\n```\n:::\n\n```{.r .cell-code}\nprint(\"5. Clustering in the heatmap may suggest which samples are most similar to each other based on their prot\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"5. Clustering in the heatmap may suggest which samples are most similar to each other based on their prot\"\n```\n:::\n:::\n\n\n---\n\n## Task 3: Animal Breeding – Bull Ranking by Economic Traits\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# making a matrix of Estimated Breeding Values (EBVs) of 2 bulls\nBullEBVs <- matrix(\n  c(400, 1.2, 0.8,\n    500, 1.5, 0.6), nrow = 2, byrow = TRUE\n)\n\nrownames(BullEBVs) <- c(\"Bull1\", \"Bull2\")\ncolnames(BullEBVs) = c(\"Trait1\", \"Trait2\", \"Trait3\")\n\n# making a matrix of economic weights\nEconomicWeights = matrix(\n  c(0.002, 50, 100), nrow=3, byrow=TRUE\n)\n\nTotalValue = BullEBVs %*% EconomicWeights\nprint(TotalValue)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       [,1]\nBull1 140.8\nBull2 136.0\n```\n:::\n:::\n\nTotal value for bull1 is 140.8 and for bull2 is 136.\nBull1 is more valuable economically.\n\n### What multiplying by the economic weights means biologically\n\nIn this case, we multiply the Estimated Breeding Values (EBVs) of each trait by corresponding Economic weights. This gives a value showing the economic relevance of each trait.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# making 3×3 identity matrix\nI <- diag(3)\nIdentityproduct = BullEBVs %*% I\nprint(Identityproduct)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1] [,2] [,3]\nBull1  400  1.2  0.8\nBull2  500  1.5  0.6\n```\n:::\n:::\n\n\nMultiplying I and BullEBVs returns a matrix identical to BullEBVs.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Subsetting the BullEBVs matrix by removing Trait1 (milk yield)\nBullsubset = BullEBVs[, 2:3]\nprint(Bullsubset)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Trait2 Trait3\nBull1    1.2    0.8\nBull2    1.5    0.6\n```\n:::\n\n```{.r .cell-code}\nEconomicweightsub = EconomicWeights[2:3,]\nprint(Economicweightsub)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  50 100\n```\n:::\n\n```{.r .cell-code}\nNewTotalValues = Bullsubset %*% Economicweightsub\nprint(NewTotalValues)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1]\nBull1  140\nBull2  135\n```\n:::\n:::\n\nThe ranking does not change. Bull1 is still more valuable.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Visualization Tasks\n\n# creating a barplot\nTotalvalueT = t(TotalValue)\nbarplot(TotalvalueT, main=\"Total value for each bull\", ylab= \"weighted values\", col=c(\"lightblue\"))\n```\n\n::: {.cell-output-display}\n![](solutions_files/figure-html/unnamed-chunk-23-1.png){width=1650}\n:::\n\n```{.r .cell-code}\n# creating a heatmap\nheatmap(BullEBVs, Rowv=TRUE, Colv=TRUE, labRow= rownames(BullEBVs), labCol= colnames(BullEBVs), col=topo.colors(256), scale=\"none\", main=\"Heatmap of EBVs\")\n```\n\n::: {.cell-output-display}\n![](solutions_files/figure-html/unnamed-chunk-23-2.png){width=1650}\n:::\n:::\n\n\n### Interpretation Questions\n\n\n- 1. Economic weights reflect the economic relevance of each trait, that is, which trait is important economically.\n- 2. Milk yield is ignored in some breeding programs because the main goal of breeding programs is to produce greater number of genetically superior offsprings.\n- 3. Heatmaps help to visualize patterns and clusters in multivariate trait data.\n- 4. This method be extended to more bulls and more traits.\n\n\n## Task 4: Plant Breeding – Trait Contributions from Parental Lines\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# making parent traits matrix\nParentTraits = matrix(\n  c(7, 5, 3,\n    6, 8, 4,\n    5, 6, 6), nrow=3, byrow= TRUE\n)\nrownames(ParentTraits) = c(\"P1\", \"P2\", \"P3\")\ncolnames(ParentTraits) = c(\"T1 Drought resistance\", \"T2 Yield\", \"T3 Maturation time\")\nprint(ParentTraits)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   T1 Drought resistance T2 Yield T3 Maturation time\nP1                     7        5                  3\nP2                     6        8                  4\nP3                     5        6                  6\n```\n:::\n\n```{.r .cell-code}\n# making HybridWeights matrix\nHybridWeights = matrix(\n  c(0.5, 0.3, 0.2), nrow=3, byrow= TRUE\n)\nprint(\"HybridWeights:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"HybridWeights:\"\n```\n:::\n\n```{.r .cell-code}\nprint(HybridWeights)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1]\n[1,]  0.5\n[2,]  0.3\n[3,]  0.2\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Transpose of HybridWeights\nHybridWeightsTranspose = t(HybridWeights)\nprint(\"HybridWeightsTranspose:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"HybridWeightsTranspose:\"\n```\n:::\n\n```{.r .cell-code}\nprint(HybridWeightsTranspose)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]  0.5  0.3  0.2\n```\n:::\n:::\n\n\n### computing Hybrid traits matrix\n\n::: {.cell}\n\n```{.r .cell-code}\nHybridTraits =  HybridWeightsTranspose %*% ParentTraits\nprint(\"The HybridTraits matrix is:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"The HybridTraits matrix is:\"\n```\n:::\n\n```{.r .cell-code}\nprint(HybridTraits)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     T1 Drought resistance T2 Yield T3 Maturation time\n[1,]                   6.3      6.1                3.9\n```\n:::\n\n```{.r .cell-code}\n# Explaining what it means biologically when one parent contributes more to a particular trait\nprint(\"A parent contributing more to a particular trait than others makes it more desirable and more likely to be selected for plant breeding\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A parent contributing more to a particular trait than others makes it more desirable and more likely to be selected for plant breeding\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# making identity matrix and multiplying with ParentTraits \nI = diag(3)\nprint(I)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    0    0\n[2,]    0    1    0\n[3,]    0    0    1\n```\n:::\n\n```{.r .cell-code}\nProduct = I %*% ParentTraits\nprint(Product)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     T1 Drought resistance T2 Yield T3 Maturation time\n[1,]                     7        5                  3\n[2,]                     6        8                  4\n[3,]                     5        6                  6\n```\n:::\n\n```{.r .cell-code}\nprint(\"Observation:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Observation:\"\n```\n:::\n\n```{.r .cell-code}\nprint(\" I × ParentTraits is identical to ParentTraits matrix\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \" I × ParentTraits is identical to ParentTraits matrix\"\n```\n:::\n\n```{.r .cell-code}\nprint(\"I × ParentTraits represents the original matrix and therefore no transformation or change\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"I × ParentTraits represents the original matrix and therefore no transformation or change\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# subsetting\nparentsub = ParentTraits[, 1:2]\nprint(\"Subset matrix of ParentTraits\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Subset matrix of ParentTraits\"\n```\n:::\n\n```{.r .cell-code}\nprint(parentsub)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   T1 Drought resistance T2 Yield\nP1                     7        5\nP2                     6        8\nP3                     5        6\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnewhybridtraits = HybridWeightsTranspose %*% parentsub\nprint(\"recalculated hybrid traits is\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"recalculated hybrid traits is\"\n```\n:::\n\n```{.r .cell-code}\nprint(newhybridtraits)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     T1 Drought resistance T2 Yield\n[1,]                   6.3      6.1\n```\n:::\n:::\n\nRemoving maturation trait does not provide insight about the maturation time of the three parent plants. The new matrix has one less column but the values of other two traits is unchanged.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Visulaization tasks\n\n# A heatmap of ParentTraits matrix\nheatmap(ParentTraits, Rowv=TRUE, Colv=TRUE, labRow= rownames(ParentTraits), labCol= colnames(ParentTraits), col=heat.colors(256), scale=\"none\", main=\"Heatmap of Three Traits of Three Parents\")\n```\n\n::: {.cell-output-display}\n![](solutions_files/figure-html/unnamed-chunk-30-1.png){width=1650}\n:::\n\n```{.r .cell-code}\n# A barplot of HybridTraits\nhybridtraitsvec = c(T1=6.3, T2=6.1, T3=3.9)\n\n\nbarplot(hybridtraitsvec, main=\"Hybrid values of each trait\", ylab=\"weighted Values of each trait\", col=c(\"lightblue\", \"lightgreen\", \"lightyellow\"))\n```\n\n::: {.cell-output-display}\n![](solutions_files/figure-html/unnamed-chunk-30-2.png){width=1650}\n:::\n\n```{.r .cell-code}\n## Interpretation Questions\n\nprint(\"The parent traits with more weight might affect hybrid’s performance more.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"The parent traits with more weight might affect hybrid’s performance more.\"\n```\n:::\n\n```{.r .cell-code}\nprint(\"I think the identity matrix serves as a control which is used to compare the matrix with itself\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"I think the identity matrix serves as a control which is used to compare the matrix with itself\"\n```\n:::\n\n```{.r .cell-code}\nequal_weights = matrix(c(0.3, 0.3, 0.3), nrow=1, byrow=TRUE)\nchange_in_hybrid_traits = equal_weights %*% ParentTraits\nprint(\"The change in hybrid weights will be\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"The change in hybrid weights will be\"\n```\n:::\n\n```{.r .cell-code}\nprint(change_in_hybrid_traits)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     T1 Drought resistance T2 Yield T3 Maturation time\n[1,]                   5.4      5.7                3.9\n```\n:::\n\n```{.r .cell-code}\nprint(\"I think this simple model ignores the influence of various abiotic and biotic factors such as environmental condition, diseases etc.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"I think this simple model ignores the influence of various abiotic and biotic factors such as environmental condition, diseases etc.\"\n```\n:::\n:::\n\n\n## Task 5: Lists\n\n::: {.cell}\n\n```{.r .cell-code}\n# Making a MasterList\nbioList = list(\nProteinConc = list(ProteinMatrix, WeightVector),\nProteinMap = list(GeneExpression, TranslationMatrix),\nPlant = list(ParentTraits, HybridWeights),\nAnimal = list(BullEBVs, EconomicWeights)\n)\n\nprint(bioList)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$ProteinConc\n$ProteinConc[[1]]\n        ProteinX ProteinY ProteinZ\nSample1        5        3        2\nSample2        7        6        4\n\n$ProteinConc[[2]]\n         Weight\nProteinX    0.5\nProteinY    1.0\nProteinZ    1.5\n\n\n$ProteinMap\n$ProteinMap[[1]]\n        GeneA GeneB GeneC\nSample1    10     8     5\nSample2    15    12    10\n\n$ProteinMap[[2]]\n      [,1] [,2] [,3]\nGeneA  1.5  0.0  0.0\nGeneB  0.0  1.2  0.0\nGeneC  0.0  0.0  1.8\n\n\n$Plant\n$Plant[[1]]\n   T1 Drought resistance T2 Yield T3 Maturation time\nP1                     7        5                  3\nP2                     6        8                  4\nP3                     5        6                  6\n\n$Plant[[2]]\n     [,1]\n[1,]  0.5\n[2,]  0.3\n[3,]  0.2\n\n\n$Animal\n$Animal[[1]]\n      Trait1 Trait2 Trait3\nBull1    400    1.2    0.8\nBull2    500    1.5    0.6\n\n$Animal[[2]]\n      [,1]\n[1,] 2e-03\n[2,] 5e+01\n[3,] 1e+02\n```\n:::\n\n```{.r .cell-code}\n# Task1\nprint(\"List of top level components:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"List of top level components:\"\n```\n:::\n\n```{.r .cell-code}\nprint(\"1. ProteinConc 2. ProteinMap 3. Plant 4. Animal\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1. ProteinConc 2. ProteinMap 3. Plant 4. Animal\"\n```\n:::\n\n```{.r .cell-code}\nprint(\"List of nested components:\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"List of nested components:\"\n```\n:::\n\n```{.r .cell-code}\nprint(\"1. ProteinMatrix 2. WeightVector 3. GeneExpression 4. TranslationMatrix 5. ParentTraits 6. HybridWeights 7. BullEBVs 8.EconomicWeights\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1. ProteinMatrix 2. WeightVector 3. GeneExpression 4. TranslationMatrix 5. ParentTraits 6. HybridWeights 7. BullEBVs 8.EconomicWeights\"\n```\n:::\n\n```{.r .cell-code}\n# Task 2\nbioList[[2]][[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        GeneA GeneB GeneC\nSample1    10     8     5\nSample2    15    12    10\n```\n:::\n\n```{.r .cell-code}\nbioList[[2]][[2]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1] [,2] [,3]\nGeneA  1.5  0.0  0.0\nGeneB  0.0  1.2  0.0\nGeneC  0.0  0.0  1.8\n```\n:::\n\n```{.r .cell-code}\nbioList[[4]][[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Trait1 Trait2 Trait3\nBull1    400    1.2    0.8\nBull2    500    1.5    0.6\n```\n:::\n\n```{.r .cell-code}\nbioList[[4]][[2]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1]\n[1,] 2e-03\n[2,] 5e+01\n[3,] 1e+02\n```\n:::\n\n```{.r .cell-code}\nmatrix_of_plant_entry = bioList[[3]][[1]]\nprint(matrix_of_plant_entry)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   T1 Drought resistance T2 Yield T3 Maturation time\nP1                     7        5                  3\nP2                     6        8                  4\nP3                     5        6                  6\n```\n:::\n\n```{.r .cell-code}\nweight_for_protein_conc = bioList[[1]][[2]]\nprint(weight_for_protein_conc)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         Weight\nProteinX    0.5\nProteinY    1.0\nProteinZ    1.5\n```\n:::\n\n```{.r .cell-code}\n# Task 3\nWeighted_gene_expression_score = bioList[[1]][[1]] %*% bioList[[1]][[2]]\nprint(Weighted_gene_expression_score)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        Weight\nSample1    8.5\nSample2   15.5\n```\n:::\n\n```{.r .cell-code}\nContribution_of_transcripts_to_each_protein = bioList[[2]][[1]] %*% bioList[[2]][[2]]\nprint(Contribution_of_transcripts_to_each_protein)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        [,1] [,2] [,3]\nSample1 15.0  9.6    9\nSample2 22.5 14.4   18\n```\n:::\n\n```{.r .cell-code}\nHybrid_trait_values = t(bioList[[3]][[2]]) %*% bioList[[3]][[1]] \nprint(Hybrid_trait_values)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     T1 Drought resistance T2 Yield T3 Maturation time\n[1,]                   6.3      6.1                3.9\n```\n:::\n\n```{.r .cell-code}\nBull_total_economic_value = bioList[[4]][[1]] %*% bioList[[4]][[2]]\nprint(Bull_total_economic_value)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       [,1]\nBull1 140.8\nBull2 136.0\n```\n:::\n\n```{.r .cell-code}\n# Task 4\n\nsubset_BullEBVs = bioList[[4]][[1]][, 2:3]\nprint(subset_BullEBVs)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Trait2 Trait3\nBull1    1.2    0.8\nBull2    1.5    0.6\n```\n:::\n\n```{.r .cell-code}\nEcoweightsub = bioList[[4]][[2]][2:3, ]\nprint(Ecoweightsub)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  50 100\n```\n:::\n\n```{.r .cell-code}\nRecalculated_total_value = subset_BullEBVs %*% Ecoweightsub\nprint(Recalculated_total_value)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1]\nBull1  140\nBull2  135\n```\n:::\n\n```{.r .cell-code}\n## Visualization Tasks\n# Creating barplot showing the result of weighted trait aggregation for the Plant hybrid\nbarplot(Hybrid_trait_values, main=\"weighted trait aggregation for the Plant hybrid\", ylab=\"weighted Values of each trait\", col=c(\"salmon\"))\n```\n\n::: {.cell-output-display}\n![](solutions_files/figure-html/unnamed-chunk-31-1.png){width=1650}\n:::\n\n```{.r .cell-code}\n# Creating barplot showing the total breeding values for each bull\nbarplot(t(Bull_total_economic_value), main=\"Comparison of Total values of Bulls\", ylab=\"weighted Values of each trait\", col=c(\"lightblue\"))\n```\n\n::: {.cell-output-display}\n![](solutions_files/figure-html/unnamed-chunk-31-2.png){width=1650}\n:::\n\n```{.r .cell-code}\n# Creating heatmap\nheatmap(bioList[[4]][[1]], Rowv=TRUE, Colv=TRUE, labRow= rownames(bioList[[4]][[1]]), labCol= colnames(bioList[[4]][[1]]), col=heat.colors(256), scale= \"column\", main=\"Heatmap of Bull EBVs\")\n```\n\n::: {.cell-output-display}\n![](solutions_files/figure-html/unnamed-chunk-31-3.png){width=1650}\n:::\n\n```{.r .cell-code}\n## Interpretation Questions\nprint(\"Structuring data using a list help to logically organise different datatypes such as matrix, vector and list itself. Since each component is differently named, they can be easily accessed.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Structuring data using a list help to logically organise different datatypes such as matrix, vector and list itself. Since each component is differently named, they can be easily accessed.\"\n```\n:::\n\n```{.r .cell-code}\nprint(\"Nested lists require multiple levels of indexing where there is a higher chance of making mistakes with the indices such as using the wrong number of brackets or the wrong index number\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Nested lists require multiple levels of indexing where there is a higher chance of making mistakes with the indices such as using the wrong number of brackets or the wrong index number\"\n```\n:::\n\n```{.r .cell-code}\nprint(\"Yes, this structure could be scaled for real datasets with many samples or traits\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Yes, this structure could be scaled for real datasets with many samples or traits\"\n```\n:::\n\n```{.r .cell-code}\nprint(\"How would you loop over all elements in bioList to apply the same function? Not sure\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"How would you loop over all elements in bioList to apply the same function? Not sure\"\n```\n:::\n\n```{.r .cell-code}\nprint(\"How can this list structure be useful for building automated bioinformatics pipelines? Not sure\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"How can this list structure be useful for building automated bioinformatics pipelines? Not sure\"\n```\n:::\n:::\n",
    "supporting": [
      "solutions_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}