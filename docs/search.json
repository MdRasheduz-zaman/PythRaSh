[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "PythRaSh",
    "section": "",
    "text": "PythRaSh starts out as a step-by-step introduction to R, Python, Linux and Command-line Tools, Probability and Statistics, etc. while its later parts are more of a cookbook with analyses of typical examples in life sciences with focus on (Molecular) Biology, Breeding and Genetics, (Gen)-omics, Medical Sciences, Agriculture, Ecology and other related fields."
  },
  {
    "objectID": "index.html#workshops",
    "href": "index.html#workshops",
    "title": "PythRaSh",
    "section": "Workshops",
    "text": "Workshops\nMoreover, the chapters published here serve as the basis for my YouTube teaching. Also, these are the primers for my upcoming workshops. Email me at md.rasheduzzaman.ugoe[at]gmail.com if you are interested in one of my upcoming workshops. Provide me with your details, what you want to learn, motivation behind that, what you are expert in, etc.\nI am teaching Data Analysis with R now. Here, I teach R, basic git and GitHub, Linux and CLTs. These are the first step of taking you towards your (Gen)-omics journey."
  },
  {
    "objectID": "ch/prob_stat/stat.html",
    "href": "ch/prob_stat/stat.html",
    "title": "Statistics Basics",
    "section": "",
    "text": "CitationBibTeX citation:@online{rasheduzzaman2024,\n  author = {Md Rasheduzzaman},\n  title = {Statistics {Basics}},\n  date = {2024-08-14},\n  langid = {en},\n  abstract = {Statistical tests, Statistics, Statistic, CLT, etc}\n}\nFor attribution, please cite this work as:\nMd Rasheduzzaman. 2024. “Statistics Basics.” August 14,\n2024."
  },
  {
    "objectID": "ch/linux-and-ctl/advanced.html",
    "href": "ch/linux-and-ctl/advanced.html",
    "title": "Advanced Linux and CTL",
    "section": "",
    "text": "Q1\nI have many files inside a folder. I want to move them into to sub-folders named f1 and f2 (I made them using mkdir -p f1 f2). How to do that?\nThis is the way:\n\ni=0\nfor file in $(ls *.fastq.gz | sort -V); do\n  if [ $i -le 400 ]; then\n    mv \"$file\" f1/\n  else\n    mv \"$file\" f2/\n  fi\n  i=$((i + 1))\ndone\n\nHere, I am sending files having 0-400 in there name to f1 folder and remaining ones to f2. You just need to use your file naming pattern, and you are all set.\nHow to execute/run this file now?\nRun these:\n\nchmod +x move_files.sh\n./move_files.sh\n\nchmod +x is making the file executable. Then we are running it using ./move_files.sh.\n\n\n\n\nCitationBibTeX citation:@online{rasheduzzaman2025,\n  author = {Md Rasheduzzaman},\n  title = {Advanced {Linux} and {CTL}},\n  date = {2025-04-23},\n  langid = {en},\n  abstract = {awk, grep, cut, etc.}\n}\nFor attribution, please cite this work as:\nMd Rasheduzzaman. 2025. “Advanced Linux and CTL.” April 23,\n2025."
  },
  {
    "objectID": "ch/rbasics/git.html",
    "href": "ch/rbasics/git.html",
    "title": "Git and CLI",
    "section": "",
    "text": "So, the summary goes first. Once you finish reading, fall back here to remind you the important things and steps of working with gitand GitHub and terminal. Regular practice will be easier in this way.\n\ngit and GitHub configuration is a bit tedious process (to make it secure for us though), but we are supposed to do it one time only. We don’t need to do it again and again.\nAnother important aspect is we are learning “how to follow instructions”.\nMany personal things in programming are in generic terms. We have to replace them accordingly. For example, your_name@gmail.com, your_user_name, your_password, path/to/your/file,your meaningful message etc.\nLearning to ask questions.\nThe standard workflow to work with a GitHub repository follows these few steps:\n\n\nGo to your GitHub account → Find the + sign and click on it → Click on New Repository.\nClone it in your computer (inside your preferred folder) running git clone git@github.com:yourusername/test1.git. Don’t forget to replace git@github.com:yourusername/test1.git with the SSH link you copied for your repo.\nMake change in your folder adding or creating files/folders. You can optionally check status of your folder running git status.\nStage/prepare/add them all to git running git add ..\n\nCommit/decorate it with a meaningful message running git commit -m \"your meaningful message\".\nNow push it to your remote (GitHub) repo running git push origin main.\n\n\nWe are recognizing code chunks in the document/page. Single line, multi-line code, and how to run them (run codes from the code chunks, even if I don’t explicitly say Run). Did you catch that running a code means writing (or copy-pasting) and pressing “Enter”/“Return” key on keyboard? Also, run multi-line code line by line, meaning next line after finishing the previous one running.\nGetting used to different vocabulary related to Computer and programming.\nWe learned navigating the file system from the bash/terminal."
  },
  {
    "objectID": "ch/rbasics/git.html#install-git",
    "href": "ch/rbasics/git.html#install-git",
    "title": "Git and CLI",
    "section": "Install Git",
    "text": "Install Git\nFor Windows\n\n\nDownload: Download Git from https://git-scm.com/download/win\n\n\nInstall: Now install, accept the default settings while installing\n\nOpen git bash: After installation, open Git Bash (not cmd/PowerShell). Find it and open by double clicking. Just keep it open, nothing else. We will return to this a bit later.\nFor MacOS\nIt should already be there. Open your terminal/shell now (Press \"command\" + \"space\" buttons together and write “terminal”. Choose the terminal). Then run:\n\ngit --version\n\nIf Git isn’t installed, macOS will prompt you to install the Xcode Command Line Tools. Click “Install” and you are done. But find the recommended below. Just run these two commands to keep your directory/repo clean.\n\necho .DS_Store &gt;&gt; ~/.gitignore_global\ngit config --global core.excludesfile ~/.gitignore_global\n\nMacOS makes .DS_Store which is not really needed for any projects (this is just an internal thingy for MacOS). But to make it work, we should have chosen the option for a gitignore file while opening the GitHub repository. We will know more about it later. Don’t worry. We are adding it to gitignore and telling git to ignore it for file tracking.\nFor Ubuntu/Debian\nOpen your terminal (Press Ctrl + Alt + T.) and run these two commands one after another:\n\nsudo apt update\nsudo apt install git\n\nProvide your password if prompted. You are all set!"
  },
  {
    "objectID": "ch/rbasics/git.html#create-a-github-account",
    "href": "ch/rbasics/git.html#create-a-github-account",
    "title": "Git and CLI",
    "section": "Create a GitHub Account",
    "text": "Create a GitHub Account\n\nNow go to https://github.com → Sign up with your email\nChoose a username and password. Make the username easy to remember (for example, with your names, maybe), password should be as difficult as possible.\n\nHint, it can be different than your email password. Use combination of capital and small letters, numbers and special characters like “@”, “!”, “?”, etc.\n\nVerify email (with the OTP) and you are set."
  },
  {
    "objectID": "ch/rbasics/git.html#set-up-git-for-the-first-time-only",
    "href": "ch/rbasics/git.html#set-up-git-for-the-first-time-only",
    "title": "Git and CLI",
    "section": "Set Up Git (for the first time only)",
    "text": "Set Up Git (for the first time only)\n\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"your_email@example.com\"\n\n\n\n\n\n\n\nInfo!\n\n\n\nIt is a multi-line code chunk (2 lines). Run the first one first, then the second one.\n\n\n\n\n\n\n\n\nStop!\n\n\n\nHere, Your Name and your_email@example.com means your user name (the one you set up just a bit ago. You don’t remember? Explore your GitHub account, you will see it there.) and the email address you used for GitHub. Use them correctly. Space, punctuation marks, capital or small letters should exactly match (Don’t be a “Murad takla”).\n\n\nYou can check your config:\n\ngit config --global --list\n\nIsn’t it showing things correctly? It should!"
  },
  {
    "objectID": "ch/rbasics/git.html#generate-ssh-key-and-connect-to-github",
    "href": "ch/rbasics/git.html#generate-ssh-key-and-connect-to-github",
    "title": "Git and CLI",
    "section": "Generate SSH Key and Connect to GitHub",
    "text": "Generate SSH Key and Connect to GitHub\nRecommended, need to do only once\n\n\n\n\n\n\nStop!\n\n\n\nThis step is creating a private and public key for you to identify that it is really you who is interacting (pushing, pulling, cloning for example) with the GitHub account later. We only upload the public key to GitHub, but never the private key. That is exclusively for yourself. Never share it with anybody.\n\n\n\nssh-keygen -t ed25519 -C \"you@example.com\"\n\nRead and just press Enter for all the prompts\n\n\n\n\n\n\nStop!\n\n\n\nDid you replace you@example.com with yours? If not, do it again replacing it with correct email address for your GitHub account.\n\n\n\n\n\n\n\n\nStop!\n\n\n\nDid you press Enter or return key multiple times or just kept staring at the screen? Read the messages on your screen to understand, and keep pressing Enter."
  },
  {
    "objectID": "ch/rbasics/git.html#add-ssh-key-to-github",
    "href": "ch/rbasics/git.html#add-ssh-key-to-github",
    "title": "Git and CLI",
    "section": "Add SSH Key to GitHub",
    "text": "Add SSH Key to GitHub\nNow, we are going to add the public key to GitHub. But do we know it? Get it this way:\n\nRun:\n\n\ncat ~/.ssh/id_ed25519.pub\n\n\nCopy the output: Be careful here. Just copy the output. No extra space after your email address (i.e. till .com).\n\n\n\n\n\n\n\nStop!\n\n\n\nDid you copied it correctly? Check again, maybe.\n\n\n\n\n\n\n\n\nHow is your key?\n\n\n\n\n\nIt has 3 fields separated with 2 spaces. Did you notice that?\n\n\n\n\nGo to GitHub → Settings → SSH and GPG keys → New SSH Key\n\nTitle: Whatever you want (but keep it simple, like my ssh key) Paste the key you copied and save it by clicking on Add SSH key. You are done.\n\n\n\n\n\n\nStop!\n\n\n\nDid you copy-pasted it correctly and is the key visible if you check under SSH and GPG keys now? It shows only the second field of your key though. If not, it is not done correctly. Work around!\n\n\n\nTest it:\n\n\nssh -T git@github.com\n\n\n\n\n\n\n\nHow is it?\n\n\n\nHi Your_user_name! You’ve successfully authenticated, but GitHub does not provide shell access.\n\n\nIt is totally fine, ignore the warning.\nSetting and configuration is done. Voila!"
  },
  {
    "objectID": "ch/rbasics/firststeps.html",
    "href": "ch/rbasics/firststeps.html",
    "title": "Basic R",
    "section": "",
    "text": "Let’s do some basic calculation.\n\n5+3\n\n[1] 8\n\n3+2\n\n[1] 5\n\n3-2\n\n[1] 1\n\n3*2\n\n[1] 6\n\n3/2 #normal division\n\n[1] 1.5\n\n7 %/% 2 #integer division, only the quotient\n\n[1] 3\n\n5 %% 3 #modulus division, the remainder\n\n[1] 2\n\n(10-5)*(2+4) #use of parentheses\n\n[1] 30\n\n10-5*2+4 #Noticed BODMAS?\n\n[1] 4\n\n(10-5)*(2+4) #Noticed BODMAS\n\n[1] 30\n\n7/(1+3); 7/1+3 #multi-line codes, separated with semi-colon\n\n[1] 1.75\n\n\n[1] 10\n\n1+2; log(1); 1/10 #more multi-line codes\n\n[1] 3\n\n\n[1] 0\n\n\n[1] 0.1\n\n\n\nVariables are variable. We have freedom to name them as we wish. But make any variable name meaningful and identifiable.\n\na &lt;- 5 #assign value 5 to a \nb = 10\na\n\n[1] 5\n\nb\n\n[1] 10\n\na &lt;- a + 10\nb = b + 15\na\n\n[1] 15\n\na^2 #a squared\n\n[1] 225\n\na**2 #a squared again, in a different way.\n\n[1] 225\n\na^3 #a qubed\n\n[1] 3375\n\n\n\n\n\n\n\n\nNote\n\n\n\n&lt;- and = are used to assign values. It is not mathematical equality. b &lt;- b + 15 might make better sense than b = b + 15.\n\n\n\nDo some more practice.\n\n7/3\n\n[1] 2.333333\n\n7%/%3\n\n[1] 2\n\n7%%3\n\n[1] 1\n\n\n\nSome important functions we apply on numerical values\n\nx &lt;- 9/4\nfloor(x)\n\n[1] 2\n\nceiling(x)\n\n[1] 3\n\nround(x)\n\n[1] 2\n\nround(x, 2) #round till 2 decimal points\n\n[1] 2.25\n\n\n\nGet to know TRUE/FALSE in R.\n\na = 5\nb = 7\nc = 10\nd = 3\na == b #is a equal to b? Ans: No/FALSE\n\n[1] FALSE\n\na != b #is a not equal to b? Ans: Yes/TRUE\n\n[1] TRUE\n\na &gt; b #is a greater than b? Ans: FALSE\n\n[1] FALSE\n\na &lt; b #is a less than b? Ans: TRUE\n\n[1] TRUE\n\na &gt;= b #is a greater than or equal to b? Ans: FALSE\n\n[1] FALSE\n\na &lt;= b #is a less than or equal to b? Ans: TRUE\n\n[1] TRUE\n\na &lt; b | d &gt; b #is a less than b OR d greater than b?\n\n[1] TRUE\n\n#It's answer will be TRUE OR FALSE --&gt; So, TRUE\na &lt; b & c &gt; d #is a less than b AND a greater than b? It's answer will be TRUE AND TRUE --&gt; So, TRUE\n\n[1] TRUE\n\na &lt; b & d &gt; c #is a less than b AND a greater than b? It's answer will be TRUE AND FALSE --&gt; So, FALSE\n\n[1] FALSE\n\n\n\nBut how to know more about a function? The package/library developer have written helpful documentation for us.\n\n?log\nexample(log)\n\n\nlog&gt; log(exp(3))\n[1] 3\n\nlog&gt; log10(1e7) # = 7\n[1] 7\n\nlog&gt; x &lt;- 10^-(1+2*1:9)\n\nlog&gt; cbind(deparse.level=2, # to get nice column names\nlog+       x, log(1+x), log1p(x), exp(x)-1, expm1(x))\n          x   log(1 + x)     log1p(x)   exp(x) - 1     expm1(x)\n [1,] 1e-03 9.995003e-04 9.995003e-04 1.000500e-03 1.000500e-03\n [2,] 1e-05 9.999950e-06 9.999950e-06 1.000005e-05 1.000005e-05\n [3,] 1e-07 1.000000e-07 1.000000e-07 1.000000e-07 1.000000e-07\n [4,] 1e-09 1.000000e-09 1.000000e-09 1.000000e-09 1.000000e-09\n [5,] 1e-11 1.000000e-11 1.000000e-11 1.000000e-11 1.000000e-11\n [6,] 1e-13 9.992007e-14 1.000000e-13 9.992007e-14 1.000000e-13\n [7,] 1e-15 1.110223e-15 1.000000e-15 1.110223e-15 1.000000e-15\n [8,] 1e-17 0.000000e+00 1.000000e-17 0.000000e+00 1.000000e-17\n [9,] 1e-19 0.000000e+00 1.000000e-19 0.000000e+00 1.000000e-19\n\n?log()\n\n\nWhat is a vector? See the example and think.\n\nx &lt;- c(1, 2, 3, 4, 5) #c means concatenate\nz &lt;- 1:5 #consecutively, from 1 through 5. A short-hand notation using :\ny &lt;- c(3, 6, 9, 12, 15, 20)\nlength(x)\n\n[1] 5\n\nmode(x)\n\n[1] \"numeric\"\n\nis(x)\n\n[1] \"numeric\" \"vector\" \n\nx[1] #first entry in vector y\n\n[1] 1\n\nx[2:5] #2nd to 5th entries in vector y\n\n[1] 2 3 4 5\n\nDNA &lt;- c(\"A\", \"T\", \"G\", \"C\") #character vector. Notice the quotation marks.\ndec &lt;- c(10.0, 20.5, 30, 60, 80.9, 90, 100.7, 50, 40, 45, 48, 56, 55) #vector of floats. All numbers became floats, it's called coercion\ndec[c(1:3, 7:length(dec))] #1st to 3rd and then 7th till the end of vector `dec`. Output as a vector.\n\n [1]  10.0  20.5  30.0 100.7  50.0  40.0  45.0  48.0  56.0  55.0\n\n\n\nNotice the element-wise or index-wise mathematical operations (+, /, log2(), round(), etc.). Noticed?\n\nx &lt;- 1:10\ny &lt;- 2:11\n#x and y are of same length\nx + y\n\n [1]  3  5  7  9 11 13 15 17 19 21\n\ny / x\n\n [1] 2.000000 1.500000 1.333333 1.250000 1.200000 1.166667 1.142857 1.125000\n [9] 1.111111 1.100000\n\nlog2(x)\n\n [1] 0.000000 1.000000 1.584963 2.000000 2.321928 2.584963 2.807355 3.000000\n [9] 3.169925 3.321928\n\nround(log2(x), 1) #log2 of all the values of `x`, 1 digit after decimal to round.\n\n [1] 0.0 1.0 1.6 2.0 2.3 2.6 2.8 3.0 3.2 3.3\n\nround(log2(x), 3) #same logic\n\n [1] 0.000 1.000 1.585 2.000 2.322 2.585 2.807 3.000 3.170 3.322\n\n\n\n\n\n\n\n\nNote\n\n\n\nNested functions work inside out. Think again about round(log2(x), 1) and you will see it. At first, it is making log2 of vector x and then it is rounding the log2 values to one digit after decimal. Got it?\n\n\n\nNow, it’s time to use vectors to make data sets…..\n\nnames &lt;- c(\"Mina\", \"Raju\", \"Mithu\", \"Lali\")\ngender &lt;- c(\"Female\", \"Male\", \"Female\", \"Female\")\nage &lt;- c(15, 12, 2, 3)\nis_human &lt;- c(TRUE, TRUE, FALSE, FALSE)\ncartoon &lt;- data.frame(names, gender, age, is_human)\nwrite.table(cartoon, \"cartoon.csv\", sep = \",\", col.names = TRUE)\ndf &lt;- read.table(\"cartoon.csv\", header = TRUE, sep = \",\")\ndim(df) #`dim` means dimension. so, rows * columns\n\n[1] 4 4\n\nstr(df) #structure of `df`\n\n'data.frame':   4 obs. of  4 variables:\n $ names   : chr  \"Mina\" \"Raju\" \"Mithu\" \"Lali\"\n $ gender  : chr  \"Female\" \"Male\" \"Female\" \"Female\"\n $ age     : int  15 12 2 3\n $ is_human: logi  TRUE TRUE FALSE FALSE\n\n\nWe made the vectors first, and the used them to make the cartton data frame or table. We learned how to export the data frame using write.table function. Also, we learned to import or read back the table using read.table function. What are the sep, col.names, header arguments there? Why do we need them? Think. Try thinking of different properties of a data set.\n\n\ngene_expr &lt;- data.frame(\n  genes = c(\"TP53\", \"BRCA1\", \"MYC\", \"EGFR\", \"GAPDH\", \"CDC2\"),\n  sample1 = c(8.2, 6.1, 9.5, 7.0, 10.0, 12),\n  Sample2 = c(5.9, 3.9, 7.2, 4.8, 7.9, 9),\n  Sample3 = c(8.25, 6.15, 9.6, 7.1, 10.1, 11.9),\n  pathways = c(\"Apoptosis\", \"DNA Repair\", \"Cell Cycle\", \"Signaling\", \"Housekeeping\", \"Cell Division\")\n)\nwrite.table(gene_expr, \"gene_expr.csv\", sep = \",\", col.names = TRUE)\ngene_set &lt;- read.table(\"gene_expr.csv\", header = TRUE, sep = \",\")\n\n\n\n\n\n\n\nNote\n\n\n\nHere, we directly used the vectors as different columns while making the data frame. Did you notice that? Also, the syntax is different here. We can’t assign the vectors with the assignment operator (means we can’t use &lt;- sign. We have to use the = sign). Try using the &lt;- sign. Did you notice the column names?\n\n\n\n\nCompute the difference between this year (2025) and the year you started at the university and divide this by the difference between this year and the year you were born. Multiply this with 100 to get the percentage of your life you have spent at the university.\nMake different kinds of variables and vectors with the data types we learned together.\nWhat are the properties of a data frame?\n\nHint: Open an excel/csv/txt file you have and try to “generalize”.\n\nCan you make logical questions on the 2 small data sets we used? Try. It will help you understanding the logical operations we tried on variables. Now we are going to apply them on vectors (columns) on the data sets. For example, in the cartoon data set, we can ask/try to subset the data set filtering for females only, or for both females and age greater than 2 years.\nIf you are writing or practicing coding in R, write comment for each line on what it is doing. It will help to chunk it better into your brain.\nPush the script and/or your answers to the questions (with your solutions) to one of your GitHub repo (and send me the repo link).\n\n\nFriday, 10pm BD Time."
  },
  {
    "objectID": "ch/rbasics/firststeps.html#part-0-using-r-as-a-calculator",
    "href": "ch/rbasics/firststeps.html#part-0-using-r-as-a-calculator",
    "title": "Basic R",
    "section": "",
    "text": "Let’s do some basic calculation.\n\n5+3\n\n[1] 8\n\n3+2\n\n[1] 5\n\n3-2\n\n[1] 1\n\n3*2\n\n[1] 6\n\n3/2 #normal division\n\n[1] 1.5\n\n7 %/% 2 #integer division, only the quotient\n\n[1] 3\n\n5 %% 3 #modulus division, the remainder\n\n[1] 2\n\n(10-5)*(2+4) #use of parentheses\n\n[1] 30\n\n10-5*2+4 #Noticed BODMAS?\n\n[1] 4\n\n(10-5)*(2+4) #Noticed BODMAS\n\n[1] 30\n\n7/(1+3); 7/1+3 #multi-line codes, separated with semi-colon\n\n[1] 1.75\n\n\n[1] 10\n\n1+2; log(1); 1/10 #more multi-line codes\n\n[1] 3\n\n\n[1] 0\n\n\n[1] 0.1"
  },
  {
    "objectID": "ch/rbasics/firststeps.html#part-1-variables-and-assignments",
    "href": "ch/rbasics/firststeps.html#part-1-variables-and-assignments",
    "title": "Basic R",
    "section": "",
    "text": "Variables are variable. We have freedom to name them as we wish. But make any variable name meaningful and identifiable.\n\na &lt;- 5 #assign value 5 to a \nb = 10\na\n\n[1] 5\n\nb\n\n[1] 10\n\na &lt;- a + 10\nb = b + 15\na\n\n[1] 15\n\na^2 #a squared\n\n[1] 225\n\na**2 #a squared again, in a different way.\n\n[1] 225\n\na^3 #a qubed\n\n[1] 3375\n\n\n\n\n\n\n\n\nNote\n\n\n\n&lt;- and = are used to assign values. It is not mathematical equality. b &lt;- b + 15 might make better sense than b = b + 15.\n\n\n\nDo some more practice.\n\n7/3\n\n[1] 2.333333\n\n7%/%3\n\n[1] 2\n\n7%%3\n\n[1] 1"
  },
  {
    "objectID": "ch/rbasics/firststeps.html#part-2-rounding",
    "href": "ch/rbasics/firststeps.html#part-2-rounding",
    "title": "Basic R",
    "section": "",
    "text": "Some important functions we apply on numerical values\n\nx &lt;- 9/4\nfloor(x)\n\n[1] 2\n\nceiling(x)\n\n[1] 3\n\nround(x)\n\n[1] 2\n\nround(x, 2) #round till 2 decimal points\n\n[1] 2.25"
  },
  {
    "objectID": "ch/rbasics/firststeps.html#part-3-logical-operations",
    "href": "ch/rbasics/firststeps.html#part-3-logical-operations",
    "title": "Basic R",
    "section": "",
    "text": "Get to know TRUE/FALSE in R.\n\na = 5\nb = 7\nc = 10\nd = 3\na == b #is a equal to b? Ans: No/FALSE\n\n[1] FALSE\n\na != b #is a not equal to b? Ans: Yes/TRUE\n\n[1] TRUE\n\na &gt; b #is a greater than b? Ans: FALSE\n\n[1] FALSE\n\na &lt; b #is a less than b? Ans: TRUE\n\n[1] TRUE\n\na &gt;= b #is a greater than or equal to b? Ans: FALSE\n\n[1] FALSE\n\na &lt;= b #is a less than or equal to b? Ans: TRUE\n\n[1] TRUE\n\na &lt; b | d &gt; b #is a less than b OR d greater than b?\n\n[1] TRUE\n\n#It's answer will be TRUE OR FALSE --&gt; So, TRUE\na &lt; b & c &gt; d #is a less than b AND a greater than b? It's answer will be TRUE AND TRUE --&gt; So, TRUE\n\n[1] TRUE\n\na &lt; b & d &gt; c #is a less than b AND a greater than b? It's answer will be TRUE AND FALSE --&gt; So, FALSE\n\n[1] FALSE"
  },
  {
    "objectID": "ch/rbasics/firststeps.html#part-4-help-and-documentation",
    "href": "ch/rbasics/firststeps.html#part-4-help-and-documentation",
    "title": "Basic R",
    "section": "",
    "text": "But how to know more about a function? The package/library developer have written helpful documentation for us.\n\n?log\nexample(log)\n\n\nlog&gt; log(exp(3))\n[1] 3\n\nlog&gt; log10(1e7) # = 7\n[1] 7\n\nlog&gt; x &lt;- 10^-(1+2*1:9)\n\nlog&gt; cbind(deparse.level=2, # to get nice column names\nlog+       x, log(1+x), log1p(x), exp(x)-1, expm1(x))\n          x   log(1 + x)     log1p(x)   exp(x) - 1     expm1(x)\n [1,] 1e-03 9.995003e-04 9.995003e-04 1.000500e-03 1.000500e-03\n [2,] 1e-05 9.999950e-06 9.999950e-06 1.000005e-05 1.000005e-05\n [3,] 1e-07 1.000000e-07 1.000000e-07 1.000000e-07 1.000000e-07\n [4,] 1e-09 1.000000e-09 1.000000e-09 1.000000e-09 1.000000e-09\n [5,] 1e-11 1.000000e-11 1.000000e-11 1.000000e-11 1.000000e-11\n [6,] 1e-13 9.992007e-14 1.000000e-13 9.992007e-14 1.000000e-13\n [7,] 1e-15 1.110223e-15 1.000000e-15 1.110223e-15 1.000000e-15\n [8,] 1e-17 0.000000e+00 1.000000e-17 0.000000e+00 1.000000e-17\n [9,] 1e-19 0.000000e+00 1.000000e-19 0.000000e+00 1.000000e-19\n\n?log()"
  },
  {
    "objectID": "ch/rbasics/firststeps.html#part-5-working-with-vectors",
    "href": "ch/rbasics/firststeps.html#part-5-working-with-vectors",
    "title": "Basic R",
    "section": "",
    "text": "What is a vector? See the example and think.\n\nx &lt;- c(1, 2, 3, 4, 5) #c means concatenate\nz &lt;- 1:5 #consecutively, from 1 through 5. A short-hand notation using :\ny &lt;- c(3, 6, 9, 12, 15, 20)\nlength(x)\n\n[1] 5\n\nmode(x)\n\n[1] \"numeric\"\n\nis(x)\n\n[1] \"numeric\" \"vector\" \n\nx[1] #first entry in vector y\n\n[1] 1\n\nx[2:5] #2nd to 5th entries in vector y\n\n[1] 2 3 4 5\n\nDNA &lt;- c(\"A\", \"T\", \"G\", \"C\") #character vector. Notice the quotation marks.\ndec &lt;- c(10.0, 20.5, 30, 60, 80.9, 90, 100.7, 50, 40, 45, 48, 56, 55) #vector of floats. All numbers became floats, it's called coercion\ndec[c(1:3, 7:length(dec))] #1st to 3rd and then 7th till the end of vector `dec`. Output as a vector.\n\n [1]  10.0  20.5  30.0 100.7  50.0  40.0  45.0  48.0  56.0  55.0\n\n\n\nNotice the element-wise or index-wise mathematical operations (+, /, log2(), round(), etc.). Noticed?\n\nx &lt;- 1:10\ny &lt;- 2:11\n#x and y are of same length\nx + y\n\n [1]  3  5  7  9 11 13 15 17 19 21\n\ny / x\n\n [1] 2.000000 1.500000 1.333333 1.250000 1.200000 1.166667 1.142857 1.125000\n [9] 1.111111 1.100000\n\nlog2(x)\n\n [1] 0.000000 1.000000 1.584963 2.000000 2.321928 2.584963 2.807355 3.000000\n [9] 3.169925 3.321928\n\nround(log2(x), 1) #log2 of all the values of `x`, 1 digit after decimal to round.\n\n [1] 0.0 1.0 1.6 2.0 2.3 2.6 2.8 3.0 3.2 3.3\n\nround(log2(x), 3) #same logic\n\n [1] 0.000 1.000 1.585 2.000 2.322 2.585 2.807 3.000 3.170 3.322\n\n\n\n\n\n\n\n\nNote\n\n\n\nNested functions work inside out. Think again about round(log2(x), 1) and you will see it. At first, it is making log2 of vector x and then it is rounding the log2 values to one digit after decimal. Got it?"
  },
  {
    "objectID": "ch/rbasics/firststeps.html#part-6-data-frame",
    "href": "ch/rbasics/firststeps.html#part-6-data-frame",
    "title": "Basic R",
    "section": "",
    "text": "Now, it’s time to use vectors to make data sets…..\n\nnames &lt;- c(\"Mina\", \"Raju\", \"Mithu\", \"Lali\")\ngender &lt;- c(\"Female\", \"Male\", \"Female\", \"Female\")\nage &lt;- c(15, 12, 2, 3)\nis_human &lt;- c(TRUE, TRUE, FALSE, FALSE)\ncartoon &lt;- data.frame(names, gender, age, is_human)\nwrite.table(cartoon, \"cartoon.csv\", sep = \",\", col.names = TRUE)\ndf &lt;- read.table(\"cartoon.csv\", header = TRUE, sep = \",\")\ndim(df) #`dim` means dimension. so, rows * columns\n\n[1] 4 4\n\nstr(df) #structure of `df`\n\n'data.frame':   4 obs. of  4 variables:\n $ names   : chr  \"Mina\" \"Raju\" \"Mithu\" \"Lali\"\n $ gender  : chr  \"Female\" \"Male\" \"Female\" \"Female\"\n $ age     : int  15 12 2 3\n $ is_human: logi  TRUE TRUE FALSE FALSE\n\n\nWe made the vectors first, and the used them to make the cartton data frame or table. We learned how to export the data frame using write.table function. Also, we learned to import or read back the table using read.table function. What are the sep, col.names, header arguments there? Why do we need them? Think. Try thinking of different properties of a data set.\n\n\ngene_expr &lt;- data.frame(\n  genes = c(\"TP53\", \"BRCA1\", \"MYC\", \"EGFR\", \"GAPDH\", \"CDC2\"),\n  sample1 = c(8.2, 6.1, 9.5, 7.0, 10.0, 12),\n  Sample2 = c(5.9, 3.9, 7.2, 4.8, 7.9, 9),\n  Sample3 = c(8.25, 6.15, 9.6, 7.1, 10.1, 11.9),\n  pathways = c(\"Apoptosis\", \"DNA Repair\", \"Cell Cycle\", \"Signaling\", \"Housekeeping\", \"Cell Division\")\n)\nwrite.table(gene_expr, \"gene_expr.csv\", sep = \",\", col.names = TRUE)\ngene_set &lt;- read.table(\"gene_expr.csv\", header = TRUE, sep = \",\")\n\n\n\n\n\n\n\nNote\n\n\n\nHere, we directly used the vectors as different columns while making the data frame. Did you notice that? Also, the syntax is different here. We can’t assign the vectors with the assignment operator (means we can’t use &lt;- sign. We have to use the = sign). Try using the &lt;- sign. Did you notice the column names?"
  },
  {
    "objectID": "ch/rbasics/firststeps.html#homeworks",
    "href": "ch/rbasics/firststeps.html#homeworks",
    "title": "Basic R",
    "section": "",
    "text": "Compute the difference between this year (2025) and the year you started at the university and divide this by the difference between this year and the year you were born. Multiply this with 100 to get the percentage of your life you have spent at the university.\nMake different kinds of variables and vectors with the data types we learned together.\nWhat are the properties of a data frame?\n\nHint: Open an excel/csv/txt file you have and try to “generalize”.\n\nCan you make logical questions on the 2 small data sets we used? Try. It will help you understanding the logical operations we tried on variables. Now we are going to apply them on vectors (columns) on the data sets. For example, in the cartoon data set, we can ask/try to subset the data set filtering for females only, or for both females and age greater than 2 years.\nIf you are writing or practicing coding in R, write comment for each line on what it is doing. It will help to chunk it better into your brain.\nPush the script and/or your answers to the questions (with your solutions) to one of your GitHub repo (and send me the repo link).\n\n\nFriday, 10pm BD Time."
  },
  {
    "objectID": "ch/rbasics/firststeps.html#part-0-getting-started",
    "href": "ch/rbasics/firststeps.html#part-0-getting-started",
    "title": "Basic R",
    "section": "Part 0: Getting Started",
    "text": "Part 0: Getting Started\nInstallation of R Markdown\nWe will use rmarkdown to have the flexibility of writing codes like the one you are reading now. If you haven’t installed the rmarkdown package yet, you can do so with:\n\n# Install rmarkdown package\n#install.packages(\"rmarkdown\")\nlibrary(rmarkdown)\n# Other useful packages we might use\n#install.packages(\"dplyr\")    # Data manipulation\nlibrary(dplyr)\n#install.packages(\"readr\")    # Reading CSV files\nlibrary(readr)\n\nRemove the hash sign before the install.packages(\"rmarkdown\"), install.packages(\"dplyr\"), install.packages(\"readr\") if the library loading fails. That means the package is not there to be loaded. We need to download/install first.\n\n\n\n\n\n\nNote\n\n\n\nDo you remember this book by Hadley Wickham?. Try to follow it to get the hold on the basic R syntax and lexicon.\n\n\nBasic Setup for Today’s Session\n\n# Clear environment\nrm(list = ls())\n\n# Check working directory\ngetwd()\n\n# Set working directory if needed\n# setwd(\"path/to/your/directory\")  # Uncomment and modify as needed\n\nPreamble on random variables (RV):\nRV is so fundamental of an idea to interpret and do better in any kind of data analyses. But what is it? Let’s imagine this scenario first. You got 30 mice to do an experiment to check anti-diabetic effect of a plant extract. You randomly assigned them into 3 groups. control, treat1 (meaning insulin receivers), and treat2 (meaning your plant extract receivers). Then you kept testing and measuring. You have mean glucose level of every mouse and show whether the mean value of treat1 is equal to treat2 or not. So, are you done? Not really. Be fastidious about the mice. What if you got some other 30 mice? Are they the same? Will their mean glucose level be the same? No, right. We would end up with different mean value. We call this type of quantities RV. Mean, Standard deviation, median, variance, etc. all are RVs. Do you see the logic? That’s why assume this constraint and look for p-value, confidence interval (or CI), etc. by (null) hypothesis testing and sample distribution analyses. We will get into these stuffs later. But let’s check what I meant.\nLet’s download the data first.\n\n# Download small example dataset\ndownload.file(\"https://raw.githubusercontent.com/genomicsclass/dagdata/master/inst/extdata/femaleControlsPopulation.csv\",\n              destfile = \"mice.csv\")\n\n# Load data\nmice &lt;- read.csv(\"mice.csv\")\n\nLet’s check now.\n\ncontrol &lt;- sample(mice$Bodyweight,12)\nmean(control)\n\n[1] 24.55833\n\ncontrol1 &lt;- sample(mice$Bodyweight,12)\nmean(control1)\n\n[1] 23.3775\n\ncontrol2 &lt;- sample(mice$Bodyweight,12)\nmean(control2)\n\n[1] 24.65083\n\n\nDo you see the difference in the mean value now?\nSome Basic Stuffs: Atomic Vector\n\natomic_vec &lt;- c(Human=0.5, Mouse=0.33)\n\nIt is fast, but has limited access methods.\nHow to access elements here?\n\natomic_vec[\"Human\"]\n\nHuman \n  0.5 \n\natomic_vec[\"Mouse\"]\n\nMouse \n 0.33 \n\n\nSome Basic Stuffs: Matrices\nMatrices are essential for biologists working with expression data, distance matrices, and other numerical data.\n\n# Create a gene expression matrix: rows=genes, columns=samples\nexpr_matrix &lt;- matrix(\n  c(12.3, 8.7, 15.2, 6.8,\n    9.5, 11.2, 13.7, 7.4,\n    5.6, 6.8, 7.9, 6.5),\n  nrow = 3, ncol = 4, byrow = TRUE\n)\n\n# Add dimension names\nrownames(expr_matrix) &lt;- c(\"BRCA1\", \"TP53\", \"GAPDH\")\ncolnames(expr_matrix) &lt;- c(\"Control_1\", \"Control_2\", \"Treatment_1\", \"Treatment_2\")\nexpr_matrix\n\n      Control_1 Control_2 Treatment_1 Treatment_2\nBRCA1      12.3       8.7        15.2         6.8\nTP53        9.5      11.2        13.7         7.4\nGAPDH       5.6       6.8         7.9         6.5\n\n# Matrix dimensions\ndim(expr_matrix)       # Returns rows and columns\n\n[1] 3 4\n\nnrow(expr_matrix)      # Number of rows\n\n[1] 3\n\nncol(expr_matrix)      # Number of columns\n\n[1] 4\n\n# Matrix subsetting\nexpr_matrix[2, ]       # One gene, all samples\n\n  Control_1   Control_2 Treatment_1 Treatment_2 \n        9.5        11.2        13.7         7.4 \n\nexpr_matrix[, 3:4]     # All genes, treatment samples only\n\n      Treatment_1 Treatment_2\nBRCA1        15.2         6.8\nTP53         13.7         7.4\nGAPDH         7.9         6.5\n\nexpr_matrix[\"TP53\", c(\"Control_1\", \"Treatment_1\")]  # Specific gene and samples\n\n  Control_1 Treatment_1 \n        9.5        13.7 \n\n# Matrix calculations (useful for bioinformatics)\n# Mean expression per gene\ngene_means &lt;- rowMeans(expr_matrix)\ngene_means\n\nBRCA1  TP53 GAPDH \n10.75 10.45  6.70 \n\n# Mean expression per sample\nsample_means &lt;- colMeans(expr_matrix)\nsample_means\n\n  Control_1   Control_2 Treatment_1 Treatment_2 \n   9.133333    8.900000   12.266667    6.900000 \n\n# Calculate fold change (Treatment vs Control)\ncontrol_means &lt;- rowMeans(expr_matrix[, 1:2])\ntreatment_means &lt;- rowMeans(expr_matrix[, 3:4])\nfold_change &lt;- treatment_means / control_means\nfold_change\n\n   BRCA1     TP53    GAPDH \n1.047619 1.019324 1.161290 \n\n# Matrix visualization\n# Heatmap of expression data\nheatmap(expr_matrix, \n        Colv = NA,         # Don't cluster columns\n        scale = \"row\",     # Scale by row (gene)\n        col = heat.colors(16),\n        main = \"Gene Expression Heatmap\")\n\n\n\n\nSome Basic Stuffs: List\nLists are the most flexible data structure in R - they can hold any combination of data types, including other lists! This makes them essential for biological data analysis where we often deal with mixed data types.\n\n# A list storing different types of genomic data\ngenomics_data &lt;- list(\n  gene_names = c(\"TP53\", \"BRCA1\", \"MYC\"),               # Character vector\n  expression = matrix(c(1.2, 3.4, 5.6, 7.8, 9.1, 2.3), nrow=3),    # Numeric matrix\n  is_cancer_gene = c(TRUE, TRUE, FALSE),                 # Logical vector\n  metadata = list(                                       # Nested list!\n    lab = \"CRG\",\n    date = \"2023-05-01\"\n  )\n)\n\nHow to Access Elements of a List?\n\n# Method 1: Double brackets [[ ]] for single element\ngenomics_data[[1]]  # Returns gene_names vector\n\n[1] \"TP53\"  \"BRCA1\" \"MYC\"  \n\n# Method 2: $ operator with names (when elements are named)\ngenomics_data$expression  # Returns the matrix\n\n     [,1] [,2]\n[1,]  1.2  7.8\n[2,]  3.4  9.1\n[3,]  5.6  2.3\n\n# Method 3: Single bracket [ ] returns a sublist\ngenomics_data[1:2]  # Returns list with first two elements\n\n$gene_names\n[1] \"TP53\"  \"BRCA1\" \"MYC\"  \n\n$expression\n     [,1] [,2]\n[1,]  1.2  7.8\n[2,]  3.4  9.1\n[3,]  5.6  2.3\n\n\nKey Difference from Vectors:\n\n# Compare to your prop.table() example:\natomic_vec[\"Human\"]    # Returns named numeric (vector)\n\nHuman \n  0.5 \n\natomic_vec[\"Mouse\"]\n\nMouse \n 0.33 \n\ngenomics_data[1] # Returns list containing the vector\n\n$gene_names\n[1] \"TP53\"  \"BRCA1\" \"MYC\"  \n\n\nWhy Biologists Need Lists?lm(), prcomp() functions, RNAseq analysis packages produces list. So, we need to learn how to handle lists.\nSee these examples:\nA. Storing BLAST results\n\nblast_hits &lt;- list(\n  query_id = \"GeneX\",\n  hit_ids = c(\"NP_123\", \"NP_456\"),\n  e_values = c(1e-50, 3e-12),\n  alignment = matrix(c(\"ATG...\", \"CTA...\"), ncol=1))\n\nB. Handling Mixed Data\n\npatient_data &lt;- list(\n  id = \"P1001\",\n  tests = data.frame(\n    test = c(\"WBC\", \"RBC\"),\n    value = c(4.5, 5.1)\n  ),\n  has_mutation = TRUE\n)\n\nCommon List Operations\n\n# Add new element\ngenomics_data$sequencer &lt;- \"Illumina\"\n\n# Remove element\ngenomics_data$is_cancer_gene &lt;- NULL\n\n# Check structure (critical for complex lists)\nstr(genomics_data)\n\nList of 4\n $ gene_names: chr [1:3] \"TP53\" \"BRCA1\" \"MYC\"\n $ expression: num [1:3, 1:2] 1.2 3.4 5.6 7.8 9.1 2.3\n $ metadata  :List of 2\n  ..$ lab : chr \"CRG\"\n  ..$ date: chr \"2023-05-01\"\n $ sequencer : chr \"Illumina\"\n\n\nConverting Between Structures\n\n# List → Vector\nunlist(genomics_data[1:3])\n\n  gene_names1   gene_names2   gene_names3   expression1   expression2 \n       \"TP53\"       \"BRCA1\"         \"MYC\"         \"1.2\"         \"3.4\" \n  expression3   expression4   expression5   expression6  metadata.lab \n        \"5.6\"         \"7.8\"         \"9.1\"         \"2.3\"         \"CRG\" \nmetadata.date \n \"2023-05-01\" \n\n\nVisualization\n\n# Base R plot from list data\nbarplot(unlist(genomics_data[2]),\n        names.arg = genomics_data[[1]])\n\nThis code won’t work if you run. unlist(genomics_data[2] creates a vector of length 6 from our 3*2 matrix but genomics_data[[1]] has 3 things inside the gene_names vector. Debug like this:\n\ndim(genomics_data$expression)  # e.g., 2 rows x 2 cols\n\n[1] 3 2\n\nlength(genomics_data$gene_names) # e.g., 3 genes\n\n[1] 3\n\n\nA. Gene-Centric (Mean Expression)\n\nbarplot(rowMeans(genomics_data$expression),\n        names.arg = genomics_data$gene_names,\n        col = \"steelblue\",\n        ylab = \"Mean Expression\",\n        main = \"Average Gene Expression\")\n\n\n\n\nB. Sample-Centric (All Measurements)\n\nbarplot(genomics_data$expression,\n        beside = TRUE,\n        names.arg = paste0(\"Sample_\", 1:ncol(genomics_data$expression)),\n        legend.text = genomics_data$gene_names,\n        args.legend = list(x = \"topright\", bty = \"n\"),\n        col = c(\"blue\", \"red\", \"green\"),\n        main = \"Expression Across Samples\")\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThis matches real-world scenarios:\nRNA-seq: Rows=genes, cols=samples\nrowMeans() = average expression per gene\nbeside=TRUE =&gt; compare samples within genes\nProteomics: Rows=proteins, cols=replicates\nSame principles apply\n\n\n\n# Calculate stats\ngene_means &lt;- rowMeans(genomics_data$expression)\ngene_sds &lt;- apply(genomics_data$expression, 1, sd)\n\n# Plot with error bars\nbp &lt;- barplot(gene_means, ylim = c(0, max(gene_means + gene_sds)))\narrows(bp, gene_means - gene_sds, bp, gene_means + gene_sds, \n       angle = 90, code = 3)\n\n\n\n\nTask: Create a list containing:\n\nA character vector of 3 gene names\nA numeric matrix of expression values\nA logical vector indicating pathway membership\nA nested list with lab metadata"
  },
  {
    "objectID": "ch/rbasics/firststeps.html#part-1-factor-variables-categorical-data",
    "href": "ch/rbasics/firststeps.html#part-1-factor-variables-categorical-data",
    "title": "Basic R",
    "section": "Part 1: Factor Variables (Categorical Data)",
    "text": "Part 1: Factor Variables (Categorical Data)\nCreating Factors\nFactors are used to represent categorical data in R. They are particularly important for biological data like genotypes, phenotypes, and experimental conditions.\n\n# Simple factor: DNA sample origins\norigins &lt;- c(\"Human\", \"Mouse\", \"Human\", \"Zebrafish\", \"Mouse\", \"Human\")\norigins_factor &lt;- factor(origins)\norigins_factor\n\n[1] Human     Mouse     Human     Zebrafish Mouse     Human    \nLevels: Human Mouse Zebrafish\n\n# Check levels (categories)\nlevels(origins_factor)\n\n[1] \"Human\"     \"Mouse\"     \"Zebrafish\"\n\n# Create a factor with predefined levels\ntreatment_groups &lt;- factor(c(\"Control\", \"Low_dose\", \"High_dose\", \"Control\", \"Low_dose\"),\n                         levels = c(\"Control\", \"Low_dose\", \"High_dose\"))\ntreatment_groups\n\n[1] Control   Low_dose  High_dose Control   Low_dose \nLevels: Control Low_dose High_dose\n\n# Ordered factors (important for severity, stages, etc.)\ndisease_severity &lt;- factor(c(\"Mild\", \"Severe\", \"Moderate\", \"Mild\", \"Critical\"),\n                         levels = c(\"Mild\", \"Moderate\", \"Severe\", \"Critical\"),\n                         ordered = TRUE)\ndisease_severity\n\n[1] Mild     Severe   Moderate Mild     Critical\nLevels: Mild &lt; Moderate &lt; Severe &lt; Critical\n\n# Compare with ordered factors\ndisease_severity[1] &lt; disease_severity[2]  # Is Mild less severe than Severe?\n\n[1] TRUE\n\n\nFactor Operations\n\n# Count frequencies\ntable(origins_factor)\n\norigins_factor\n    Human     Mouse Zebrafish \n        3         2         1 \n\n# Calculate proportions\nprop.table(table(origins_factor))\n\norigins_factor\n    Human     Mouse Zebrafish \n0.5000000 0.3333333 0.1666667 \n\n# Change reference level (important for statistical models)\norigins_factor_relevel &lt;- relevel(origins_factor, ref = \"Mouse\")\norigins_factor_relevel\n\n[1] Human     Mouse     Human     Zebrafish Mouse     Human    \nLevels: Mouse Human Zebrafish\n\n# Convert to character\nas.character(origins_factor)\n\n[1] \"Human\"     \"Mouse\"     \"Human\"     \"Zebrafish\" \"Mouse\"     \"Human\"    \n\n# Plot factors - Basic barplot\nbarplot(table(origins_factor), \n        col = c(\"blue\", \"green\", \"red\"),\n        main = \"Sample Origins\",\n        ylab = \"Count\")\n\n\n\n# More advanced plot with factors\n# Create sample data\ngene_expr &lt;- c(5.2, 7.8, 4.5, 12.3, 8.1, 3.7)\nnames(gene_expr) &lt;- as.character(origins)\n\n# Boxplot by factor\nboxplot(gene_expr ~ origins, \n        col = \"lightblue\",\n        main = \"Gene Expression by Sample Origin\", \n        xlab = \"Origin\", \n        ylab = \"Expression Level\")\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nKeep noticing the output formats. Sometimes the output is just a number, sometimes a vector or table or list, etc. Check prop.table(table(origins_factor)). How is it?\n\n\n\n\n\n\n\n\nGot it?\n\n\n\n\n\nprop &lt;- prop.table(table(origins_factor)) – is a named numeric vector (atomic vector). prop$Human or similar won’t work. Check this way: prop &lt;- prop.table(table(origins_factor)) prop prop[“Human”]; prop[“Mouse”]; prop[“Zebrafish”]\nOr make it a data frame (df) first, then try to use normal way of handling df.\n\n\n\nAccessing the Output:\n\nprop &lt;- prop.table(table(origins_factor))\nprop\n\norigins_factor\n    Human     Mouse Zebrafish \n0.5000000 0.3333333 0.1666667 \n\nprop[\"Human\"]; prop[\"Mouse\"]; prop[\"Zebrafish\"]\n\nHuman \n  0.5 \n\n\n    Mouse \n0.3333333 \n\n\nZebrafish \n0.1666667"
  },
  {
    "objectID": "ch/rbasics/firststeps.html#part-2-subsetting-data",
    "href": "ch/rbasics/firststeps.html#part-2-subsetting-data",
    "title": "Basic R",
    "section": "Part 2: Subsetting Data",
    "text": "Part 2: Subsetting Data\nVectors\n\n# Create a vector\nexpression_data &lt;- c(3.2, 4.5, 2.1, 6.7, 5.9, 3.3, 7.8, 2.9)\nnames(expression_data) &lt;- paste0(\"Sample_\", 1:8)\nexpression_data\n\nSample_1 Sample_2 Sample_3 Sample_4 Sample_5 Sample_6 Sample_7 Sample_8 \n     3.2      4.5      2.1      6.7      5.9      3.3      7.8      2.9 \n\n# Subset by position\nexpression_data[3]             # Single element\n\nSample_3 \n     2.1 \n\nexpression_data[c(1, 3, 5)]    # Multiple elements\n\nSample_1 Sample_3 Sample_5 \n     3.2      2.1      5.9 \n\nexpression_data[2:5]           # Range\n\nSample_2 Sample_3 Sample_4 Sample_5 \n     4.5      2.1      6.7      5.9 \n\n# Subset by name\nexpression_data[\"Sample_6\"]\n\nSample_6 \n     3.3 \n\nexpression_data[c(\"Sample_1\", \"Sample_8\")]\n\nSample_1 Sample_8 \n     3.2      2.9 \n\n# Subset by condition\nexpression_data[expression_data &gt; 5]              # Values &gt; 5\n\nSample_4 Sample_5 Sample_7 \n     6.7      5.9      7.8 \n\nexpression_data[expression_data &gt;= 3 & expression_data &lt;= 6]  # Values between 3 and 6\n\nSample_1 Sample_2 Sample_5 Sample_6 \n     3.2      4.5      5.9      3.3 \n\n\nData Frames\n\n# Create a data frame\ngene_df &lt;- data.frame(\n  gene_id = c(\"BRCA1\", \"TP53\", \"MYC\", \"EGFR\", \"GAPDH\"),\n  expression = c(8.2, 6.1, 9.5, 7.0, 10.0),\n  mutation = factor(c(\"Yes\", \"No\", \"Yes\", \"No\", \"No\")),\n  pathway = c(\"DNA Repair\", \"Apoptosis\", \"Cell Cycle\", \"Signaling\", \"Metabolism\")\n)\n\ngene_df\n\n  gene_id expression mutation    pathway\n1   BRCA1        8.2      Yes DNA Repair\n2    TP53        6.1       No  Apoptosis\n3     MYC        9.5      Yes Cell Cycle\n4    EGFR        7.0       No  Signaling\n5   GAPDH       10.0       No Metabolism\n\n# Subsetting by row index\ngene_df[1:3, ]         # First three rows, all columns\n\n  gene_id expression mutation    pathway\n1   BRCA1        8.2      Yes DNA Repair\n2    TP53        6.1       No  Apoptosis\n3     MYC        9.5      Yes Cell Cycle\n\n# Subsetting by column index\ngene_df[, c(1, 2)]     # All rows, first two columns\n\n  gene_id expression\n1   BRCA1        8.2\n2    TP53        6.1\n3     MYC        9.5\n4    EGFR        7.0\n5   GAPDH       10.0\n\n# Subsetting by column name\ngene_df[, c(\"gene_id\", \"mutation\")]\n\n  gene_id mutation\n1   BRCA1      Yes\n2    TP53       No\n3     MYC      Yes\n4    EGFR       No\n5   GAPDH       No\n\n# Using the $ operator\ngene_df$expression\n\n[1]  8.2  6.1  9.5  7.0 10.0\n\ngene_df$mutation\n\n[1] Yes No  Yes No  No \nLevels: No Yes\n\n# Subsetting by condition\ngene_df[gene_df$expression &gt; 8, ]\n\n  gene_id expression mutation    pathway\n1   BRCA1        8.2      Yes DNA Repair\n3     MYC        9.5      Yes Cell Cycle\n5   GAPDH       10.0       No Metabolism\n\ngene_df[gene_df$mutation == \"Yes\", ]\n\n  gene_id expression mutation    pathway\n1   BRCA1        8.2      Yes DNA Repair\n3     MYC        9.5      Yes Cell Cycle\n\n# Multiple conditions\ngene_df[gene_df$expression &gt; 7 & gene_df$mutation == \"No\", ]\n\n  gene_id expression mutation    pathway\n5   GAPDH         10       No Metabolism\n\n\nLogical Operators\n\n\nOperator\nMeaning\nExample\n\n\n\n==\nEqual to\nx == 5\n\n\n!=\nNot equal\nx != 5\n\n\n&lt;\nLess than\nx &lt; 5\n\n\n&gt;\nGreater than\nx &gt; 5\n\n\n&lt;=\nLess or equal\nx &lt;= 5\n\n\n&gt;=\nGreater or equal\nx &gt;= 5\n\n\n!\nNot\n!(x &lt; 5)\n\n\n|\nOR\nx &lt; 5 | x &gt; 10\n\n\n&\nAND\nx &gt; 5 & x &lt; 10\n\n\nRow Names in Data Frames\nRow names are particularly important in bioinformatics where genes, proteins, or samples are often used as identifiers.\n\n# Setting row names for gene_df\nrownames(gene_df) &lt;- gene_df$gene_id\ngene_df\n\n      gene_id expression mutation    pathway\nBRCA1   BRCA1        8.2      Yes DNA Repair\nTP53     TP53        6.1       No  Apoptosis\nMYC       MYC        9.5      Yes Cell Cycle\nEGFR     EGFR        7.0       No  Signaling\nGAPDH   GAPDH       10.0       No Metabolism\n\n# We can now drop the gene_id column if desired\ngene_df_clean &lt;- gene_df[, -1]  # Remove the first column\ngene_df_clean\n\n      expression mutation    pathway\nBRCA1        8.2      Yes DNA Repair\nTP53         6.1       No  Apoptosis\nMYC          9.5      Yes Cell Cycle\nEGFR         7.0       No  Signaling\nGAPDH       10.0       No Metabolism\n\n# Access rows by name\ngene_df_clean[\"TP53\", ]\n\n     expression mutation   pathway\nTP53        6.1       No Apoptosis\n\n# Check if row names are unique\nany(duplicated(rownames(gene_df_clean)))\n\n[1] FALSE\n\n# Handle potential duplicated row names\n# NOTE: R doesn't allow duplicate row names by default\ndup_genes &lt;- data.frame(\n  expression = c(5.2, 6.3, 5.2, 8.1),\n  mutation = c(\"Yes\", \"No\", \"Yes\", \"No\")\n)\n\n# This would cause an error:\n# rownames(dup_genes) &lt;- c(\"BRCA1\", \"BRCA1\", \"TP53\", \"EGFR\")\n\n# Instead, we can preemptively make them unique:\nproposed_names &lt;- c(\"BRCA1\", \"BRCA1\", \"TP53\", \"EGFR\")\nunique_names &lt;- make.unique(proposed_names)\nunique_names  # Show the generated unique names\n\n[1] \"BRCA1\"   \"BRCA1.1\" \"TP53\"    \"EGFR\"   \n\n# Now we can safely assign them\nrownames(dup_genes) &lt;- unique_names\ndup_genes\n\n        expression mutation\nBRCA1          5.2      Yes\nBRCA1.1        6.3       No\nTP53           5.2      Yes\nEGFR           8.1       No\n\n# Another approach: allow duplicates but with a warning\n# Using row.names argument during creation (internally calls make.unique)\n#dup_genes2 &lt;- data.frame(\n#  expression = c(5.2, 6.3, 5.2, 8.1),\n#  mutation = c(\"Yes\", \"No\", \"Yes\", \"No\"),\n#  row.names = c(\"BRCA1\", \"BRCA1\", \"TP53\", \"EGFR\")\n#)\n#dup_genes2  # Notice how R handles the duplicates automatically"
  },
  {
    "objectID": "ch/rbasics/firststeps.html#part-3-handling-missingwrong-values",
    "href": "ch/rbasics/firststeps.html#part-3-handling-missingwrong-values",
    "title": "Basic R",
    "section": "Part 3: Handling Missing/Wrong Values",
    "text": "Part 3: Handling Missing/Wrong Values\nIdentifying Issues\n\n# Create data with missing values\nclinical_data &lt;- data.frame(\n  patient_id = 1:5,\n  age = c(25, 99, 30, -5, 40),    # -5 is wrong, 99 is suspect\n  bp = c(120, NA, 115, 125, 118),  # NA is missing\n  weight = c(65, 70, NA, 68, -1)   # -1 is wrong\n)\nclinical_data\n\n  patient_id age  bp weight\n1          1  25 120     65\n2          2  99  NA     70\n3          3  30 115     NA\n4          4  -5 125     68\n5          5  40 118     -1\n\n# Check for missing values\nis.na(clinical_data)\n\n     patient_id   age    bp weight\n[1,]      FALSE FALSE FALSE  FALSE\n[2,]      FALSE FALSE  TRUE  FALSE\n[3,]      FALSE FALSE FALSE   TRUE\n[4,]      FALSE FALSE FALSE  FALSE\n[5,]      FALSE FALSE FALSE  FALSE\n\ncolSums(is.na(clinical_data))  # Count NAs by column\n\npatient_id        age         bp     weight \n         0          0          1          1 \n\n# Check for impossible values\nclinical_data$age &lt; 0\n\n[1] FALSE FALSE FALSE  TRUE FALSE\n\nclinical_data$weight &lt; 0\n\n[1] FALSE FALSE    NA FALSE  TRUE\n\n# Find indices of problematic values\nwhich(clinical_data$age &lt; 0 | clinical_data$age &gt; 90)\n\n[1] 2 4\n\n\nFixing Data\n\n# Replace impossible values with NA\nclinical_data$age[clinical_data$age &lt; 0 | clinical_data$age &gt; 90] &lt;- NA\nclinical_data$weight[clinical_data$weight &lt; 0] &lt;- NA\nclinical_data\n\n  patient_id age  bp weight\n1          1  25 120     65\n2          2  NA  NA     70\n3          3  30 115     NA\n4          4  NA 125     68\n5          5  40 118     NA\n\n# Replace NAs with mean (common in biological data)\nclinical_data$bp[is.na(clinical_data$bp)] &lt;- mean(clinical_data$bp, na.rm = TRUE)\nclinical_data$weight[is.na(clinical_data$weight)] &lt;- mean(clinical_data$weight, na.rm = TRUE)\nclinical_data\n\n  patient_id age    bp   weight\n1          1  25 120.0 65.00000\n2          2  NA 119.5 70.00000\n3          3  30 115.0 67.66667\n4          4  NA 125.0 68.00000\n5          5  40 118.0 67.66667\n\n# Replace NAs with median (better for skewed data)\nclinical_data$age[is.na(clinical_data$age)] &lt;- median(clinical_data$age, na.rm = TRUE)\nclinical_data\n\n  patient_id age    bp   weight\n1          1  25 120.0 65.00000\n2          2  30 119.5 70.00000\n3          3  30 115.0 67.66667\n4          4  30 125.0 68.00000\n5          5  40 118.0 67.66667"
  },
  {
    "objectID": "ch/rbasics/firststeps.html#part-4-data-transformation",
    "href": "ch/rbasics/firststeps.html#part-4-data-transformation",
    "title": "Basic R",
    "section": "Part 4: Data Transformation",
    "text": "Part 4: Data Transformation\nIntroduction to Outliers\nOutliers can significantly affect statistical analyses, especially in biological data where sample variation can be high.\n\n# Create data with outliers\nexpression_levels &lt;- c(2.3, 2.7, 3.1, 2.9, 2.5, 3.0, 15.2, 2.8)\nboxplot(expression_levels, \n        main = \"Expression Levels with Outlier\",\n        ylab = \"Expression\")\n\n\n\n\nIdentifying Outliers\n\n# Statistical approach: Values beyond 1.5*IQR\ndata_summary &lt;- summary(expression_levels)\ndata_summary\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  2.300   2.650   2.850   4.312   3.025  15.200 \n\nIQR_value &lt;- IQR(expression_levels)\nupper_bound &lt;- data_summary[\"3rd Qu.\"] + 1.5 * IQR_value\nlower_bound &lt;- data_summary[\"1st Qu.\"] - 1.5 * IQR_value\n\n# Find outliers\noutliers &lt;- expression_levels[expression_levels &gt; upper_bound | \n                             expression_levels &lt; lower_bound]\noutliers\n\n[1] 15.2\n\n\nTransforming Vectors\nMathematical transformations can normalize data, reduce outlier effects, and make data more suitable for statistical analyses.\n\n# Original data\ngene_exp &lt;- c(15, 42, 87, 115, 320, 560, 1120)\nhist(gene_exp, main = \"Original Expression Values\", xlab = \"Expression\")\n\n\n\n# Log transformation (common in gene expression analysis)\nlog_exp &lt;- log2(gene_exp)\nhist(log_exp, main = \"Log2 Transformed Expression\", xlab = \"Log2 Expression\")\n\n\n\n# Square root transformation (less aggressive than log)\nsqrt_exp &lt;- sqrt(gene_exp)\nhist(sqrt_exp, main = \"Square Root Transformed Expression\", xlab = \"Sqrt Expression\")\n\n\n\n# Z-score normalization (standardization)\nz_exp &lt;- scale(gene_exp)\nhist(z_exp, main = \"Z-score Normalized Expression\", xlab = \"Z-score\")\n\n\n\n# Compare transformations\npar(mfrow = c(2, 2))\nhist(gene_exp, main = \"Original\")\nhist(log_exp, main = \"Log2\")\nhist(sqrt_exp, main = \"Square Root\")\nhist(z_exp, main = \"Z-score\")\n\n\n\npar(mfrow = c(1, 1))  # Reset plotting layout\n\nLogical Expressions\n\n# Create gene expression vector\nexp_data &lt;- c(5.2, 3.8, 7.1, 2.9, 6.5, 8.0, 4.3)\nnames(exp_data) &lt;- paste0(\"Gene_\", 1:7)\n\n# Basic comparisons\nexp_data &gt; 5    # Which genes have expression &gt; 5?\n\nGene_1 Gene_2 Gene_3 Gene_4 Gene_5 Gene_6 Gene_7 \n  TRUE  FALSE   TRUE  FALSE   TRUE   TRUE  FALSE \n\nexp_data &lt;= 4   # Which genes have expression &lt;= 4?\n\nGene_1 Gene_2 Gene_3 Gene_4 Gene_5 Gene_6 Gene_7 \n FALSE   TRUE  FALSE   TRUE  FALSE  FALSE  FALSE \n\n# Store results in logical vector\nhigh_exp &lt;- exp_data &gt; 6\nhigh_exp\n\nGene_1 Gene_2 Gene_3 Gene_4 Gene_5 Gene_6 Gene_7 \n FALSE  FALSE   TRUE  FALSE   TRUE   TRUE  FALSE \n\n# Use logical vectors for subsetting\nexp_data[high_exp]  # Get high expression values\n\nGene_3 Gene_5 Gene_6 \n   7.1    6.5    8.0 \n\n\nLogical Operators\n\n# Combining conditions with AND (&)\nexp_data &gt; 4 & exp_data &lt; 7  # Expression between 4 and 7\n\nGene_1 Gene_2 Gene_3 Gene_4 Gene_5 Gene_6 Gene_7 \n  TRUE  FALSE  FALSE  FALSE   TRUE  FALSE   TRUE \n\n# Combining conditions with OR (|)\nexp_data &lt; 4 | exp_data &gt; 7  # Expression less than 4 OR greater than 7\n\nGene_1 Gene_2 Gene_3 Gene_4 Gene_5 Gene_6 Gene_7 \n FALSE   TRUE   TRUE   TRUE  FALSE   TRUE  FALSE \n\n# Using NOT (!)\n!high_exp  # Not high expression\n\nGene_1 Gene_2 Gene_3 Gene_4 Gene_5 Gene_6 Gene_7 \n  TRUE   TRUE  FALSE   TRUE  FALSE  FALSE   TRUE \n\n# Subsetting with combined conditions\nexp_data[exp_data &gt; 4 & exp_data &lt; 7]  # Get values between 4 and 7\n\nGene_1 Gene_5 Gene_7 \n   5.2    6.5    4.3 \n\n\nLogical Functions\n\n# all() - Are all values TRUE?\nall(exp_data &gt; 0)  # Are all expressions positive?\n\n[1] TRUE\n\n# any() - Is at least one value TRUE?\nany(exp_data &gt; 7)  # Is any expression greater than 7?\n\n[1] TRUE\n\n# which() - Get indices of TRUE values\nwhich(exp_data &gt; 6)  # Which elements have expressions &gt; 6?\n\nGene_3 Gene_5 Gene_6 \n     3      5      6 \n\n# %in% operator - Test for membership\ntest_genes &lt;- c(\"Gene_1\", \"Gene_5\", \"Gene_9\")\nnames(exp_data) %in% test_genes  # Which names match test_genes?\n\n[1]  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE\n\n\nConditionals\n\n# if-else statement\ngene_value &lt;- 6.8\n\nif(gene_value &gt; 6) {\n  cat(\"High expression\\n\")\n} else if(gene_value &gt; 4) {\n  cat(\"Medium expression\\n\")\n} else {\n  cat(\"Low expression\\n\")\n}\n\nHigh expression\n\n# ifelse() for vectors\nexpression_levels &lt;- c(2.5, 5.8, 7.2, 3.1, 6.9)\nexpression_category &lt;- ifelse(expression_levels &gt; 6, \n                             \"High\", \n                             ifelse(expression_levels &gt; 4, \"Medium\", \"Low\"))\nexpression_category\n\n[1] \"Low\"    \"Medium\" \"High\"   \"Low\"    \"High\""
  },
  {
    "objectID": "ch/rbasics/firststeps.html#part-5-practical-session",
    "href": "ch/rbasics/firststeps.html#part-5-practical-session",
    "title": "Basic R",
    "section": "Part 5: Practical Session",
    "text": "Part 5: Practical Session\nCheck out this repo: https://github.com/genomicsclass/dagdata/\n\n# Download small example dataset\ndownload.file(\"https://github.com/genomicsclass/dagdata/raw/master/inst/extdata/msleep_ggplot2.csv\",\n              destfile = \"msleep_data.csv\")\n\n# Load data\nmsleep &lt;- read.csv(\"msleep_data.csv\")\n\nIn-class Tasks:\n\nConvert ‘vore’ column to factor and plot its distribution.\n\nCreate a matrix of sleep data columns and add row names.\n\nFind and handle any missing values.\n\nCalculate mean sleep time by diet category (vore).\n\nIdentify outliers in sleep_total.\n\n##Part 6: Summary of Today’s Lesson\nIn today’s class, we covered:\n\n\nFactor Variables: Essential for categorical data in biology (genotypes, treatments, etc.)\n\nCreation, levels, ordering, and visualization\n\n\n\nSubsetting Techniques: Critical for data extraction and analysis\n\nVector and data frame subsetting with various methods\nUsing row names effectively for biological identifiers\n\n\n\nMatrix Operations: Fundamental for expression data\n\nCreation, manipulation, and biological applications\nCalculating fold changes and other common operations\n\n\n\nMissing Values: Practical approaches for real-world biological data\n\nIdentification and appropriate replacement methods\n\n\n\nData Transformation: Making data suitable for statistical analysis\n\nLog, square root, and z-score transformations\nOutlier identification and handling\n\n\n\nLogical Operations: For data filtering and decision making\n\nConditions, combinations, and applications\n\n\n\nThese skills form the foundation for the more advanced visualization techniques we’ll cover in future lessons.\n\nWe will know more about conditionals, R packages to handle data and visualization in a better and efficient way.\n\n##Part 7: Homework\n\n\nMatrix Operations:\n\nCreate a gene expression matrix with 8 genes and 4 conditions\nCalculate the mean expression for each gene\nCalculate fold change between condition 4 and condition 1\nCreate a heatmap of your matrix\n\n\n\nFactor Analysis:\n\nUsing the iris dataset, convert Species to an ordered factor\nCreate boxplots showing Sepal.Length by Species\nCalculate mean petal length for each species level\n\n\n\nData Cleaning Challenge:\n\nIn the downloaded msleep_data.csv:\n\nIdentify all columns with missing values\nReplace missing values appropriately\nCreate a new categorical variable “sleep_duration” with levels “Short”, “Medium”, “Long”\n\n\n\n\n\nComplete Documentation:\n\nWrite all code in R Markdown\nInclude comments explaining your approach\nPush to GitHub\n\n\n\nDue date: Friday 10pm BD Time"
  },
  {
    "objectID": "ch/python/AI.html",
    "href": "ch/python/AI.html",
    "title": "Artificial Intelegence",
    "section": "",
    "text": "CitationBibTeX citation:@online{rasheduzzaman2025,\n  author = {Md Rasheduzzaman},\n  title = {Artificial {Intelegence}},\n  date = {2025-04-11},\n  langid = {en},\n  abstract = {Tensor, etc.}\n}\nFor attribution, please cite this work as:\nMd Rasheduzzaman. 2025. “Artificial Intelegence.” April 11,\n2025."
  },
  {
    "objectID": "ch/python/panda.html",
    "href": "ch/python/panda.html",
    "title": "Panda Dataframe, scypy, numpy, etc.",
    "section": "",
    "text": "CitationBibTeX citation:@online{rasheduzzaman2024,\n  author = {Md Rasheduzzaman},\n  title = {Panda {Dataframe,} Scypy, Numpy, Etc.},\n  date = {2024-08-13},\n  langid = {en},\n  abstract = {Panda df}\n}\nFor attribution, please cite this work as:\nMd Rasheduzzaman. 2024. “Panda Dataframe, Scypy, Numpy,\nEtc.” August 13, 2024."
  },
  {
    "objectID": "ch/genomics/pipeline.html",
    "href": "ch/genomics/pipeline.html",
    "title": "Bioinformatics Pipelines Using Snakemake",
    "section": "",
    "text": "Here is a nice repo to learn snakemake workflows. Just try some to learn.\n\n\n\n\n\nCitationBibTeX citation:@online{rasheduzzaman2025,\n  author = {Md Rasheduzzaman},\n  title = {Bioinformatics {Pipelines} {Using} {Snakemake}},\n  date = {2025-04-11},\n  langid = {en},\n  abstract = {Automating pipelines, snakemake, HPC cluster, etc.}\n}\nFor attribution, please cite this work as:\nMd Rasheduzzaman. 2025. “Bioinformatics Pipelines Using\nSnakemake.” April 11, 2025."
  },
  {
    "objectID": "ch/genomics/advanced.html",
    "href": "ch/genomics/advanced.html",
    "title": "Advanced Genomics",
    "section": "",
    "text": "CitationBibTeX citation:@online{rasheduzzaman2024,\n  author = {Md Rasheduzzaman},\n  title = {Advanced {Genomics}},\n  date = {2024-08-14},\n  langid = {en},\n  abstract = {conda environment, HPC cluster, quality control, trimming\n    and filtering, Genome assembly, mapping, alignment, classification,\n    contamination removal, pangenomics, Illumina, ONT, PacBio}\n}\nFor attribution, please cite this work as:\nMd Rasheduzzaman. 2024. “Advanced Genomics.” August 14,\n2024."
  },
  {
    "objectID": "ch/blogs/en/index.html",
    "href": "ch/blogs/en/index.html",
    "title": "English Blogs",
    "section": "",
    "text": "Welcome to the English blog archive! ✍️📚\n\n\n\n\n\n\n\n\n\n\n\n\nPlace Holder\n\n\n\n\n\n\n\n\n\n\n\n\nApr 24, 2025\n\n\nMd Rasheduzzaman\n\n\n\n\n\n\nNo matching items\n\nCitationBibTeX citation:@online{rasheduzzaman2025,\n  author = {Md Rasheduzzaman},\n  title = {English {Blogs}},\n  date = {2025-04-24},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nMd Rasheduzzaman. 2025. “English Blogs.” April 24, 2025."
  },
  {
    "objectID": "ch/blogs/bn/roshun.html",
    "href": "ch/blogs/bn/roshun.html",
    "title": "এক বিধবার গল্প",
    "section": "",
    "text": "নাম তার Alium sativum। খালাত বোন Alium cepa-র সাথে তার অনেক মিল। তাই তারা একই ফ্যামিলিতে আছে। অবশ্য অমিলও আছে অনেক। Alium sativum এর গায়ে সেই আজন্ম বাল্যবৈধব্যের সাজ, আর Alium cepa-র লাল টুকটুকে বিয়ের সাজ আজও ঘোচে নি।\nআজ থেকে প্রায় ২-৩ বছর আগে, একদিন দেখি আমার ছোট বোন এক আঁটি ফুল (flower stalk) নিয়ে আসছে। মনে হল পিয়াজের। কিন্তু কাছে আসতে মনে হল— না, ওগুলো রসুনের হবে। রসুন রসুন গন্ধ বেরুচ্ছে। তবু জিজ্ঞাসা করলাম, “ওগুলো কি?” সে বলল, “রসুনের ঢেঁপ।” হাতে নিয়ে অবাক হয়ে দেখতে লাগলাম। জিবনের এতোগুলো বছর পাড়ি দিলাম, গ্রামেই বাস, ফসলের মাঠের সাথে লুটোপুটি খেতে খেতে বড় হলাম, অথচ রসুনের ফুলই আমি দেখি নি এর আগে!!! দেখলাম কিছু পুষ্পদন্ড ( scape বা ঢেঁপ) কিছুটা প্যাঁচানো, আর কিছু সোজা। আসলে কিছুটা প্যাঁচানোগুলো ছিল বেশি কচি, আর সোজাগুলো ছিল একটু ম্যাচিউর। যখন আরো ভাল করে দেখতে লাগলাম আমার তো চোখ চড়ক গাছ হবার পালা। একি! এর umbel বা ক্যাপসুলের ভিতরে দেখি ছোট ছোট রসুনের কোয়া!!! বাহ্, মাটির নিচেও রসুন, বাতাসেও রসুন, ভাল না?? Umbel এর ভিতরের এই কোয়াগুলোকে বলে bulbils। আর মাটির নিচেরগুলোকে বলে cloves। Clove-গুলো মিলে গঠন করে bulb (বাতি)। আসলে দেখতে বাতির মত বলেই এর নাম হয়েছে bulb. এই bulb আর bulbils দিয়ে রসুনের অঙ্গজ জনন ঘটে। রসুনের umbel এর ভিতরে আবার অনেক ফুলও আছে। আসলে রসুনের inflorescence (পুষ্পবিন্যাস) এর নিচের দিকটা তৈরি করে bulbils, আর উপরের দিকটা হয়ে যায় ফুল। যাই হোক, আমি এতোদিন রসুনের এই রূপের কিছুই দেখি নি। শুধু মায়ের হাতের রান্নায় রসুনের ব্যবহার দেখেছি। জ্বর হলে ওষুধের সাথে সাথে চাল ভাজা, মরিচ, আদা, রসুনের ঝাল চাটনি খেয়ে ফোঁপাতে ফোঁপাতে জ্বর সারার আশা করেছি। রসুনের গন্ধযুক্ত নিঃশ্বাস (garlic breath) ছেড়েছি—- হরেক রকম ফুলও আমি দেখেছি, অস্বীকার করছি না— কিন্তু রসুনের ফুল আমি এর আগে দেখি নি।\nআমি যেমন রসুনের ফুলের ব্যাপারে ছিলাম লাওয়াকিফ, ঠিক তেমনি আগে ভাবা হত এর ফুল sterile (বন্ধ্যা)। কিন্তু এগুলো আসলে বন্ধ্যা নয়। ১৮৭৫ সালে Eduard Regel সর্বপ্রথম রসুনের এই অনন্য ফুলধারণ পদ্ধতির বর্ণনা দেন।\nএখন তাহলে আমরা বলতেই পারি রসুনের প্রজননের মাধ্যম কয়টি। বলুন তো কি কি? হ্যাঁ, cloves, bulbils আর বীজ। তাহলে শুধু cloves দিয়ে আমাদের দেশের কৃষকেরা চাষ করে কেন এই প্রশ্নটা আপনাদের মনে জাগতে পারে। আমারও জেগেছিল। এর সহজ উত্তর হচ্ছে বীজ ও bulbils এর কন্ট্রোলিং, আবাদ করা বেশ ঝক্কির ব্যাপার।তাছাড়া এগুলো থেকে রসুন পেতে লেগে যাবে অনেক বেশি সময়, শ্রমও লাগবে বেশি। অর্থ উপার্জন, দেশভর্তি মানুষের চাহিদা মেটানো যেখানে কৃষকদের প্রধান ও প্রথম লক্ষ্য সেখানে এমন সময় ও শ্রমসাপেক্ষ কাজ করা নিশ্চই কৃষকদের কাজ নয়। তবুও প্রশ্ন থেকেই যায় bulbils বা বীজ দিয়ে কী আবাদ করার দরকার পড়বে কখনো?\nহ্যাঁ, এর উত্তরটা অনেক important. রসুন প্রজাতীর স্বকীয়তা রক্ষা করা, জাত উন্নয়ন, বংশনাশের হাত থেকে রক্ষা করা সবকিছুর সমাধান দেবে এই উত্তরটিই।\nযদিও রসুন স্বাভাবিকভাবেই অযৌন জনন প্রক্রিয়ায় (bulb বা bulbils দিয়ে) বংশ বৃদ্ধি করে, বীজ উৎপাদন হার ও অঙ্কুরোদগম হার অনেক কম তবুও আমরা যদি বীজ পাবার জন্য চাষ করতে শুরু করি ধীরে ধীরে বীজ উৎপাদন হার বাড়তে থাকবে। অযৌন বা অঙ্গজ জনন পদ্ধতি মাতৃ উদ্ভিদের হুবহু কপি (clone) তৈরি করে। অর্থাৎ, কোনো গাছের যা বৈশিষ্ট্য, অঙ্গজ প্রজননের মাধ্যমে পাওয়া গাছেরও ঠিক একই বৈশিষ্ট্য হবে। কাজেই যদি মিউটেশন বা ভাইরাল ইনফেকশনের কারণে কোনো ক্ষতিকর বৈশিষ্ট্যের আগমন ঘটে তাহলে সেটাও যতবার এই পদ্ধতিতে আবাদ করবেন ততবারই বাহিত হবে। এতে হয়তো একটা নির্দিষ্ট এলাকায় (পরিসর অনেক বড়ও হতে পারে) রসুনের চাষই হয়তো বন্ধ হয়ে যাবে। অবশ্য umbel এর ভিতরে সুরক্ষিত থাকায় bulbils এ এই ধরণের পরিবর্তন খুব কমই হয়। তবু চান্স তো থেকেই যায়। কিন্তু বীজ দিয়ে চাষ করলে এই সম্ভাবনা আমরা এড়াতে পারি। কেননা দেহকোষের মিউটেশনের প্রভাব বীজে বাহিত হয় না। কাজেই আমরা যদি হুমকির হাত থেকে রসুনকে বাঁচাতে চাই, সহজেই জাত উন্নয়ন করতে চাই (hybridization বা crossing এর মাধ্যমে), কিংবা যদি নিদেনপক্ষে এর চমৎকার ফুলধারণ দেখে মন জুড়াতে চাই, তাহলে আসুন সেটা কীভাবে করা যায় দেখে নিই। বাগানের একখন্ড জমিতে রসুনের cloves লাগিয়ে ফেলুন। জায়গার অভাব থাকলে টবে কিংবা ছাদে মাটি দিয়ে কাজটা করে ফেলুন।\nজাত উন্নয়ন বা হাইব্রিডাইজেশনের জন্য প্যারেন্ট উদ্ভিতের অন্তত একটা নির্দিষ্ট এলাকায় খুব ভালভাবে বেঁচে থাকার সক্ষমতা (adaptability) থাকতে হবে, বীজ দিয়ে বংশবৃদ্ধি করা গাছগুলোর বেঁচে থাকতে হবে। কিন্তু রসুনের তা খুবই কম। তাই আগে রসুনের এই adaptability নিয়ে আসার জন্য বেশ কিছু প্রজন্ম ধরে বীজ দিয়ে চাষ করতে থাকতে হবে।\nরসুনের ফুল protandrous ধরণের, অর্থাৎ এর stigma (গর্ভমুন্ড) পরাগগ্রাহী (receptive) হবার আগেই পরাগরেণু (pollen grain) ম্যাচিউর হয়ে যায়। তাই এদের স্বনিষেক (self-fertilization) ঘটে না। তবে একই umbel এর অন্যান্য ফুলকে নিষিক্ত করতে পারে। মৌমাছির মত অন্যান্য কীটপতঙ্গেরা এতে সাহায্য করে ফুলে ফুলে ঘুরে মধু আহরণের চারিত্রিক বৈশিষ্ট্য দিয়ে। রসুনের গর্ভাশয়ে থাকে তিনটি seed chamber. প্রতি চ্যাম্বারে আছে দুইটি করে ডিম্বক (ovule— যা বীজে পরিণত হয়।). সুতরাং, রসুনের একটি ফুল থেকেই আমরা পেয়ে যাব ছয়টি বীজ। প্রতি umbel থেকে কয়েক শ’।\nএখন সমস্যা হচ্ছে ফুল ও bulbils পুষ্টি পাবার লড়াইয়ে নামে। প্রাকৃতিকভাবে bulbils-ই জেতে। তাই বীজ পেতে চাইলে আগে এদেরকে ছাড়ানো দরকার। ভ্যারিটিভেদে bulbils এর সংখ্যা ও প্রকৃতির তারতম্য আছে। সংখ্যা কম ও আকারে বড় হলে ছাড়ানোটা সহজ হয়। তবে সংখ্যায় বেশি ও আকারে ছোট হলে প্রথমে বাইরের দিকেরগুলো ছাড়িয়ে নিয়ে কয়েকদিন পর ভিতরের দিকেরগুলো ছাড়াতে হবে। নজর রাখতে হবে যেন ফুলের কোনো ক্ষতি না হয়। আমাদের দেশে যেগুলো চাষ হয় সেগুলোতে bulbils এর সংখ্যা কম আর আকারেও বড়। কাজেই কাজটা সহজই হবে। পানি, সার ও পরিচর্যা অব্যাহত রাখতে হবে। পরাগায়ন হবার ৪৫-৬০ দিনের মধ্যেই বীজ পরিপক্ব হয়ে যায়। বীজ পরিপক্ব হবার আগেই যদি গাছ বুড়িয়ে যায় তাহলে scape টা কেটে নিয়ে পানিতে ডুবিয়ে রাখতে হবে— পাতাবাহারের ডালকে যেভাবে বাঁচিয়ে রাখা হয়, ঠিক সেভাবেই।তাহলেই আপনি বীজ পেয়ে যাবেন। এরপর এভাবে বীজ উৎপাদনের মাধ্যমে উপর্যুপরি আবাদ করতে থাকলে একটা অভিযোজিত (well adapted) ভ্যারিটি পেয়ে যাব আমরা। এরপর ক্রসিং বা হাইব্রিডাইজেশনের বিভিন্ন টেকনিক কাজে লাগিয়ে আমরা পেয়ে যাব অনেক উন্নত জাত। আর এই উন্নত জাতগুলোরও তো bulb, bulbils থাকবেই, এদের দিয়ে আমরা প্রতিটি নতুন জাত বা ভ্যারিটিকে সংরক্ষণ করতে পারি। যৌন জননের পাশাপাশি অঙ্গজ বা অযৌন জনন থাকার এটাই এক বিশাল সুবিধা। কাজেই আসুন আমরা নতুনভাবে প্রকৃতিটাকে দেখতে শুরু করি। একবীজপত্রী ও দ্বিবীজপত্রী উদ্ভিদের অযৌন ও যৌন জনন পদ্ধতিগুলো নিয়ে ভাবতে থাকি।পদ্ধতিগুলোর পার্থক্যগুলোও ভাবতে থাকি। পথ চলতে চলতে যে গাছগুলো চোখে পড়ে সেগুলোর কান্ড, পাতা, ফুল, ফলের মিল-অমিলগুলো নিয়ে ভাবতে থাকি। তাহলেই উদ্ভিদবিদ্যা জানার উৎসাহ-উদ্দীপনা, আনন্দ দ্বিগুণ হয়ে যাবে বলে আমি মন করি।\n← Back to all Bangla Blogs\n\n\n\n\n\nCitationBibTeX citation:@online{rasheduzzaman2025,\n  author = {Md Rasheduzzaman},\n  title = {এক বিধবার গল্প},\n  date = {2025-04-24},\n  langid = {bn}\n}\nFor attribution, please cite this work as:\nMd Rasheduzzaman. 2025. “এক বিধবার গল্প.” April 24, 2025."
  },
  {
    "objectID": "ch/blogs/bn/index.html",
    "href": "ch/blogs/bn/index.html",
    "title": "বাংলা ব্লগ",
    "section": "",
    "text": "স্বাগতম বাংলা ব্লগ আর্কাইভে! ✍️📚\n\n\n\n\n\n\n\n\n\n\n\n\nজীবজগতে অভিভাবকত্ব\n\n\n\n\n\n\n\n\n\n\n\n\nApr 24, 2025\n\n\nMd Rasheduzzaman\n\n\n\n\n\n\n\n\nএক বিধবার গল্প\n\n\n\n\n\n\n\n\n\n\n\n\nApr 24, 2025\n\n\nMd Rasheduzzaman\n\n\n\n\n\n\nNo matching items\n\nCitationBibTeX citation:@online{rasheduzzaman2025,\n  author = {Md Rasheduzzaman},\n  title = {বাংলা {ব্লগ}},\n  date = {2025-04-24},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nMd Rasheduzzaman. 2025. “বাংলা ব্লগ.” April 24, 2025."
  },
  {
    "objectID": "ch/blogs/bn/gurdian.html",
    "href": "ch/blogs/bn/gurdian.html",
    "title": "জীবজগতে অভিভাবকত্ব",
    "section": "",
    "text": "আমাদের পোষা গৃহপালিত প্রাণিদের মধ্যে পাখিরা ডিম থেকে বাচ্চা দেয়। যেমন, হাঁস, মুরগি, কবুতর, কোয়েল, টার্কি, টিয়া, ময়না, মুনিয়া ইত্যাদি। এরা বেশ কয়েক সপ্তাহ ধরে ডিমে তা’ দিয়ে বাচ্চা ফুটায়। বন্য পরিবেশে বাস করা পাখিরাও ঠিক একইভাবে ডিম থেকেই বাচ্চা ফুটায়। এরকম একটি পাখি হল এম্পেরর পেঙ্গুইন (emperor penguin)। না, এরা গৃহপালিত নয়। এদের একমাত্র বাসস্থান একেবারে পৃথিবীর এক মেরুতে—এন্টার্কটিকায়।\nপৃথিবীতে যত প্রজাতির পেঙ্গুইন আছে এরা আকারে তাদের সবার চেয়ে বড়, ওজনে সবচেয়ে ভারী। এরা মানুষের মত খাড়াভাবে হাঁটে। দূর থেকে দেখলে মনে হবে যেন কোটপরুয়া কোন ভদ্রলোক হেঁটে চলেছেন। তার ছোট ডানাজোড়ার একটা যদি একটু পাশ দিয়ে প্রসারিত করে রাখে তাহলে মনে হবে লোকটার হাতে একটা ব্রিফ কেসও আছে। কোন শীতের দেশে সে বরফ ডিঙ্গিয়ে অফিসে চলেছে। হ্যাঁ, তার অফিসের নাম দক্ষিণ মহাসাগর। সেখানে গিয়ে সে অফিসের কাজকর্ম সারে, মানে আহার খুঁজে। ক্রিল, স্কুইড, ছোট বড় বিভিন্ন মাছ খেয়ে সে পেট ভরায়। তারপর পরিবারের জন্য খাবার নিয়ে ফিরে আসে তার বাসস্থানে। কিন্তু আমরা আপাতদৃষ্টিতে হয়তো দেখব না যে সে খাবার নিয়ে ফিরেছে। আসলে খাবারটা সে নিয়ে আসে তার পাকস্থলিতে করে।\nযেসব প্রাণী সমুদ্রের গভীরে খাবার খুঁজতে যায় তাদের প্রথম চ্যালেঞ্জ হল চাপ সহ্য করা। কেননা প্রতি ১০.০৬ মিটার বা ৩৩ ফুট গভীরতায় চাপ বেড়ে দ্বিগুণ হয়ে যায়। তাই তাদের হাড়ের গঠন হয় আলাদা রকম। এদের হাড়ের সংযোগস্থলে তরুনাস্থি থাকে যা চাপ সহ্য করতে সাহায্য করে। এদের হিমোগ্লোবিনের গঠনও একটু আলাদা; যেন এতো গভীরতায় অক্সিজেন পরিবহণে কোন বাধা-বিপত্তি না ঘটে। আর এদের পালকগুলো এমন যেন পানি লাগলেই তা শরীরের সাথে লেপটে যায়।\nআমাদের গৃহপালিত পাখিগুলো হয় স্ত্রী-পুরুষ পালা করে ডিমে তা দেয়, কিংবা শুধু স্ত্রী পাখিই এ কাজ করে। সন্তান উৎপাদনের জন্য এদের সবচেয়ে বড় চ্যালেঞ্জ হল ডিমে তা’ দেয়া। স্ত্রী এম্পেরর পেঙ্গুইন একটিমাত্র ডিম পাড়ে একেবারে শীতকালে। ডিম পাড়ার পর তাতে তা’ দিয়ে ফুটানোর মত আর কোন শক্তি তার দেহে অবশিষ্ট থাকে না। তাই সে সাগরে পাড়ি জমায় খাবার খেতে। এসময় পরিবেশের তাপমাত্রা থাকে -২০ ডিগ্রি সেলসিয়াস। তাই এই ডিম থেকে বাচ্চা ফুটানো একটা বিশাল চ্যালেঞ্জ। তাহলে কি পেঙ্গুইনের বাচ্চা হবেনা? তার ধারা শেষ হয়ে যাবে? না, তখন বাকি কাজ করে পুরুষ এম্পেরর পেঙ্গুইন। ডিমকে দুই পায়ের পাতায় রেখে পেটের একটা থলিতে করে আগলে রাখে সে। তাই এসময় তারা সাধারণত যেভাবে হাঁটে সেভাবে হাঁটতেও পারে না। কিন্তু কয়দিন পরেই পরিবেশের তাপমাত্রা কমে -৬০ ডিগ্রি সেলসিয়াসে নেমে যায়। তখন কি তার শরীরের তাপমাত্রা পারবে ডিমকে ফুটানোর মত তাপ যোগাতে? আসলে কোন এম্পেরর পেঙ্গুইন বাবাই একা একা এত কম তাপমাত্রা ও প্রচন্ড বাতাসের সাথে লড়াই করে পারত না। তাই অন্য সব পুরুষ পেঙ্গুইনেরা মিলে একটা কলোনি তৈরি করে। একজন আরেকজনের সাথে গায়ে গা ঘেঁষে দাড়ায়, যেন তাপ না হারায়। আর যে পেঙ্গুইনেরা একেবারে বাহিরে পরিধির দিকে থাকে তারা শত মেইল বেগে ধেয়ে আসা ঠান্ডা বাতাস সহ্য করে। তাহলে তাদের তাপের সুষম সমাধান কিভাবে হল? আসলে তারা সবসময় গায়ে গা ঘেঁষে ঘুরতে থাকে। যারা ভিতরের দিকে ছিল তারা পরিধির দিকে আসে, আর যারা পরিধির দিকে ছিল তারা ভিতরে চলে যায়। এভাবে তারা তাপ বণ্টনের সুষ্ঠু সমাধান করে ফেলে। যেন কারো ডিম তাপের অভাবে নষ্ট না হয়। এই দীর্ঘ এক মাস তারা পৃথিবীর সবচেয়ে অন্ধকারাচ্ছন্ন ঠান্ডা আবহাওয়াকে হারিয়ে দেয় দলগত প্রচেষ্টায়।\nতারপর সূর্যের দেখা মিলবার সময় হয়। আর প্রকৃতির সাথে তাল মিলিয়ে এই সময় এদের ডিম ফুটে বাচ্চা বেরিয়ে আসে। বাচ্চাটা যেহেতু অতো বেশি ঠান্ডা সহ্য করতে পারবে না তাই এই যথোপযুক্ত সময়টা খুবই গুরুত্বপূর্ণ। আর ডিমকে তা’ দিতে শুরু করার দিন থেকেই পিতা পেঙ্গুইন একবেলার মাত্র আহার নিজের পাকস্থলিতে জমা করে রাখে অনাগত শিশুটির জন্য। বাচ্চা হওয়ার পর পরম আদরে সেটা বাচ্চার মুখে তুলে দেয়। এরপর শুধুই অপেক্ষা। মা ফিরে আসার অপেক্ষা। মা ফিরে আসে তার সঙ্গীর উদ্দেশ্যে ডাক ছেড়ে। পরস্পরের ডাক শুনে এভাবেই তারা একে অপরকে চিনে নেয়। বাবা তখন তার আদরের ছানাকে মায়ের দায়িত্বে দিয়ে দেয়। ৪ মাসের দীর্ঘ লড়াইয়ের পর বাচ্চার মুখ দেখা স্নেহবাৎসল বাবা অতোটা সহজে সন্তানকে ছাড়তে চায়না। তবু, ক্ষুধার চেয়ে কঠিন কিছু মনে হয় নেই! মাকে সন্তান লালন-পালনের দায়িত্ব দিয়ে বাবা তখন সাগরে যায় খাবার খেতে। কেননা সে দীর্ঘ ৪ মাস ধরে কোন খাবারই খায়নি! আর মা যদি ফিরে না আসে, যদি শিকারী প্রাণীর হাতে ধরা পড়ে, কিংবা যদি খাড়া ঢাল থেকে পড়ে মারা যায় তাহলে ভবিষ্যত অনিশ্চিত। বাবাকে বেঁচে থাকার জন্য যেতেই হবে সাগরে। বাচ্চাটা তখন অন্য সব মায়েদের কাছে যায় খাবারের জন্য। কিন্তু তাদের তো পরিবার আছে, তারা আর কাউকে সহ্য করেনা। আর মা যদি এসে দেখে যে তার ডিমটি ফু্টে নি কিংবা ছোট্ট ছানাটি মরে গেছে তাহলে মায়ের আর কষ্ট দেখে কে! যেসব বাচ্চার মা নাই তাদেরকে দত্তক নেয়ার জন্য তারা উঠেপড়ে লাগে, অন্য সন্তানহারা মায়েদের সাথে প্রতিযোগিতা শুরু করে দেয় তারা। এতে করে অনেক সময় বাচ্চা প্রাণ হারায় ওইসব প্রতিযোগী মায়েদের প্রচণ্ড মাতৃত্ববোধের চাপে।\nজীবজগতে সব প্রাণিদেরই বাবা-মা যেমন আছে, ঠিক তেমনি আছে সন্তানের প্রতি মা-বাবার স্নেহ-ভালবাসা, আদর-যত্ন এবং মঙ্গলচিন্তা। সন্তানেরও আত্মচিন্তার উর্ধ্বে ভালবাসা ও মঙ্গলাকাঙ্ক্ষা আছে মা-বাবা কিংবা পরিবার নিয়ে, তবে সেটা আসবে অনেক পরে। শৈশবে পিতা-মাতার প্রতি সন্তানের ভালবাসা মনে হয় সবচেয়ে আত্মকেন্দ্রিক–বেঁচে থাকার তাগিদে। আর মা-বাবা তাদের উপর সন্তানের এই নির্ভরশীলতার মধ্য দিয়ে বুনতে থাকেন সন্তানের মধ্য দিয়ে নিজেকে অমর করে রেখে যাবার সুপ্তবাসনা। শুধু যে মানুষের মধ্যেই এসব ব্যাপার আছে তা কিন্তু নয়। আবার অন্যান্য জীবে এই ব্যাপারগুলো আছে বলে মানুষের এই দিকগুলো কোনভাবে খাটো হয়েছে এমনটাও নয়। ঠিক তেমনিভাবে তাদের অভিভাবকত্ব বা সন্তান বাৎসল্যকেও ছোট করে দেখবার কোন উপায় নেই। সন্তান তো সন্তানই, মা-বাবা তো মা-বাবাই। এর কোন জাতিভেদ চলে না। এ যেন একে অপরকে জানতে পারার, বুঝতে পারার জন্য বিধাতার এক অন্তর্নিহিত নিদর্শন। আমাদের বুঝতে হবে, খুঁজে নিতে হবে সেগুলো।।\n← Back to all Bangla Blogs\n\n\n\n\n\nCitationBibTeX citation:@online{rasheduzzaman2025,\n  author = {Md Rasheduzzaman},\n  title = {জীবজগতে অভিভাবকত্ব},\n  date = {2025-04-24},\n  langid = {bn}\n}\nFor attribution, please cite this work as:\nMd Rasheduzzaman. 2025. “জীবজগতে অভিভাবকত্ব.” April 24,\n2025."
  },
  {
    "objectID": "ch/blogs/en/example.html",
    "href": "ch/blogs/en/example.html",
    "title": "Place Holder",
    "section": "",
    "text": "bla bla bla…….\n← Back to all English Blogs\n\n\n\n\n\nCitationBibTeX citation:@online{rasheduzzaman2025,\n  author = {Md Rasheduzzaman},\n  title = {Place {Holder}},\n  date = {2025-04-24},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nMd Rasheduzzaman. 2025. “Place Holder.” April 24, 2025."
  },
  {
    "objectID": "ch/genomics/basics.html",
    "href": "ch/genomics/basics.html",
    "title": "Basic Genomics",
    "section": "",
    "text": "CitationBibTeX citation:@online{rasheduzzaman2024,\n  author = {Md Rasheduzzaman},\n  title = {Basic {Genomics}},\n  date = {2024-08-14},\n  langid = {en},\n  abstract = {Genome, -omics, data formats, platforms}\n}\nFor attribution, please cite this work as:\nMd Rasheduzzaman. 2024. “Basic Genomics.” August 14, 2024."
  },
  {
    "objectID": "ch/python/MLA.html",
    "href": "ch/python/MLA.html",
    "title": "Machine Learning",
    "section": "",
    "text": "CitationBibTeX citation:@online{rasheduzzaman2025,\n  author = {Md Rasheduzzaman},\n  title = {Machine {Learning}},\n  date = {2025-04-11},\n  langid = {en},\n  abstract = {Supervised and Unsupervised ML}\n}\nFor attribution, please cite this work as:\nMd Rasheduzzaman. 2025. “Machine Learning.” April 11, 2025."
  },
  {
    "objectID": "ch/python/basics.html",
    "href": "ch/python/basics.html",
    "title": "Python Basics",
    "section": "",
    "text": "print(\"Hello, world!\")\n\nHello, world!"
  },
  {
    "objectID": "ch/python/basics.html#intro",
    "href": "ch/python/basics.html#intro",
    "title": "Python Basics",
    "section": "",
    "text": "print(\"Hello, world!\")\n\nHello, world!"
  },
  {
    "objectID": "ch/python/basics.html#np-array",
    "href": "ch/python/basics.html#np-array",
    "title": "Python Basics",
    "section": "np array",
    "text": "np array\n\n# Your Python code\n#py_install(\"numpy\"\")\nimport numpy as np\n\narr = np.array([1, 2, 3, 4, 5])\nprint(arr * 2)\n\n[ 2  4  6  8 10]"
  },
  {
    "objectID": "ch/rbasics/correlation_regression.html",
    "href": "ch/rbasics/correlation_regression.html",
    "title": "Correlation & Regression",
    "section": "",
    "text": "CitationBibTeX citation:@online{rasheduzzaman2025,\n  author = {Md Rasheduzzaman},\n  title = {Correlation \\& {Regression}},\n  date = {2025-04-24},\n  langid = {en},\n  abstract = {Correlation and simple linear regression (with and without\n    intercept).}\n}\nFor attribution, please cite this work as:\nMd Rasheduzzaman. 2025. “Correlation & Regression.”\nApril 24, 2025."
  },
  {
    "objectID": "ch/rbasics/baddata.html",
    "href": "ch/rbasics/baddata.html",
    "title": "Bad data & Outliers",
    "section": "",
    "text": "CitationBibTeX citation:@online{rasheduzzaman2025,\n  author = {Md Rasheduzzaman},\n  title = {Bad Data \\& {Outliers}},\n  date = {2025-04-24},\n  langid = {en},\n  abstract = {Cleaning data, dealing with missing data and comparing\n    results for correlation and regression before vs. after removing an\n    outlier from the data.}\n}\nFor attribution, please cite this work as:\nMd Rasheduzzaman. 2025. “Bad Data & Outliers.” April\n24, 2025."
  },
  {
    "objectID": "ch/rbasics/tidyverse.html",
    "href": "ch/rbasics/tidyverse.html",
    "title": "The tidyverse",
    "section": "",
    "text": "CitationBibTeX citation:@online{rasheduzzaman2025,\n  author = {Md Rasheduzzaman},\n  title = {The Tidyverse},\n  date = {2025-04-24},\n  langid = {en},\n  abstract = {Pipe (\\%\\textgreater\\%), Tibbles, dplyr-verbs, long/wide\n    format and more.}\n}\nFor attribution, please cite this work as:\nMd Rasheduzzaman. 2025. “The Tidyverse.” April 24, 2025."
  },
  {
    "objectID": "ch/linux-and-ctl/basics.html",
    "href": "ch/linux-and-ctl/basics.html",
    "title": "Linux Basics",
    "section": "",
    "text": "Try to use Linux to do better in life. The black screen of Linux is way more powerful than you (probably) know till now. Follow this step-by-step guide to install Ubuntu (a Linux distribution).\nFollow this pages to install Windows Subsystem for Linux if you are using Windows. Then you can use the WSL just like a native Linux using your system. You can’t do anything except using Linux to analyse Genomic (sequencing) data. So, better start now.\nFollow link1 & link2 to get step-by-step guideline to do it.\nThe problem here is, I am not using Windows. So, I might not be able to help you if there is any issue you are facing while installing WSL2. But I can try. A tip will be update your kernel first and then try."
  },
  {
    "objectID": "ch/linux-and-ctl/basics.html#linux-and-wsl2",
    "href": "ch/linux-and-ctl/basics.html#linux-and-wsl2",
    "title": "Linux Basics",
    "section": "",
    "text": "Try to use Linux to do better in life. The black screen of Linux is way more powerful than you (probably) know till now. Follow this step-by-step guide to install Ubuntu (a Linux distribution).\nFollow this pages to install Windows Subsystem for Linux if you are using Windows. Then you can use the WSL just like a native Linux using your system. You can’t do anything except using Linux to analyse Genomic (sequencing) data. So, better start now.\nFollow link1 & link2 to get step-by-step guideline to do it.\nThe problem here is, I am not using Windows. So, I might not be able to help you if there is any issue you are facing while installing WSL2. But I can try. A tip will be update your kernel first and then try."
  },
  {
    "objectID": "ch/linux-and-ctl/basics.html#intro",
    "href": "ch/linux-and-ctl/basics.html#intro",
    "title": "Linux Basics",
    "section": "Intro",
    "text": "Intro\n\n# Your Linux/Bash code here \necho \"Hello from Bash!\" \nls -l\n\nHello from Bash!\ntotal 24\n-rw-r--r--  1 md.rasheduzzaman  staff   870 Apr 23 13:13 advanced.qmd\n-rw-r--r--  1 md.rasheduzzaman  staff  1254 Apr 24 18:43 basics.qmd\n-rw-r--r--  1 md.rasheduzzaman  staff  1258 Apr 25 21:28 basics.rmarkdown\ndrwxr-xr-x  3 md.rasheduzzaman  staff    96 Apr 25 21:28 basics_files\n\n\nLearn a lot from https://github.com/hbctraining"
  },
  {
    "objectID": "ch/prob_stat/prob_basic.html",
    "href": "ch/prob_stat/prob_basic.html",
    "title": "Probabilty Basics",
    "section": "",
    "text": "CitationBibTeX citation:@online{rasheduzzaman2024,\n  author = {Md Rasheduzzaman},\n  title = {Probabilty {Basics}},\n  date = {2024-08-14},\n  langid = {en},\n  abstract = {Experiment, trial, distribution, PMF, PDF, CDF, etc.}\n}\nFor attribution, please cite this work as:\nMd Rasheduzzaman. 2024. “Probabilty Basics.” August 14,\n2024."
  },
  {
    "objectID": "ch/rbasics/firststeps.html#using-r-as-a-calculator",
    "href": "ch/rbasics/firststeps.html#using-r-as-a-calculator",
    "title": "Basic R",
    "section": "",
    "text": "Let’s do some basic calculation.\n\n5+3\n\n[1] 8\n\n3+2\n\n[1] 5\n\n3-2\n\n[1] 1\n\n3*2\n\n[1] 6\n\n3/2 #normal division\n\n[1] 1.5\n\n7 %/% 2 #integer division, only the quotient\n\n[1] 3\n\n5 %% 3 #modulus division, the remainder\n\n[1] 2\n\n(10-5)*(2+4) #use of parentheses\n\n[1] 30\n\n10-5*2+4 #Noticed BODMAS?\n\n[1] 4\n\n(10-5)*(2+4) #Noticed BODMAS\n\n[1] 30\n\n7/(1+3); 7/1+3 #multi-line codes, separated with semi-colon\n\n[1] 1.75\n\n\n[1] 10\n\n1+2; log(1); 1/10 #more multi-line codes\n\n[1] 3\n\n\n[1] 0\n\n\n[1] 0.1"
  },
  {
    "objectID": "ch/rbasics/firststeps.html#variables-and-assignments",
    "href": "ch/rbasics/firststeps.html#variables-and-assignments",
    "title": "Basic R",
    "section": "",
    "text": "Variables are variable. We have freedom to name them as we wish. But make any variable name meaningful and identifiable.\n\na &lt;- 5 #assign value 5 to a \nb = 10\na\n\n[1] 5\n\nb\n\n[1] 10\n\na &lt;- a + 10\nb = b + 15\na\n\n[1] 15\n\na^2 #a squared\n\n[1] 225\n\na**2 #a squared again, in a different way.\n\n[1] 225\n\na^3 #a qubed\n\n[1] 3375\n\n\n\n\n\n\n\n\nNote\n\n\n\n&lt;- and = are used to assign values. It is not mathematical equality. b &lt;- b + 15 might make better sense than b = b + 15.\n\n\n\nDo some more practice.\n\n7/3\n\n[1] 2.333333\n\n7%/%3\n\n[1] 2\n\n7%%3\n\n[1] 1"
  },
  {
    "objectID": "ch/rbasics/firststeps.html#rounding",
    "href": "ch/rbasics/firststeps.html#rounding",
    "title": "Basic R",
    "section": "",
    "text": "Some important functions we apply on numerical values\n\nx &lt;- 9/4\nfloor(x)\n\n[1] 2\n\nceiling(x)\n\n[1] 3\n\nround(x)\n\n[1] 2\n\nround(x, 2) #round till 2 decimal points\n\n[1] 2.25"
  },
  {
    "objectID": "ch/rbasics/firststeps.html#logical-operations",
    "href": "ch/rbasics/firststeps.html#logical-operations",
    "title": "Basic R",
    "section": "",
    "text": "Get to know TRUE/FALSE in R.\n\na = 5\nb = 7\nc = 10\nd = 3\na == b #is a equal to b? Ans: No/FALSE\n\n[1] FALSE\n\na != b #is a not equal to b? Ans: Yes/TRUE\n\n[1] TRUE\n\na &gt; b #is a greater than b? Ans: FALSE\n\n[1] FALSE\n\na &lt; b #is a less than b? Ans: TRUE\n\n[1] TRUE\n\na &gt;= b #is a greater than or equal to b? Ans: FALSE\n\n[1] FALSE\n\na &lt;= b #is a less than or equal to b? Ans: TRUE\n\n[1] TRUE\n\na &lt; b | d &gt; b #is a less than b OR d greater than b?\n\n[1] TRUE\n\n#It's answer will be TRUE OR FALSE --&gt; So, TRUE\na &lt; b & c &gt; d #is a less than b AND a greater than b? It's answer will be TRUE AND TRUE --&gt; So, TRUE\n\n[1] TRUE\n\na &lt; b & d &gt; c #is a less than b AND a greater than b? It's answer will be TRUE AND FALSE --&gt; So, FALSE\n\n[1] FALSE"
  },
  {
    "objectID": "ch/rbasics/firststeps.html#help-and-documentation",
    "href": "ch/rbasics/firststeps.html#help-and-documentation",
    "title": "Basic R",
    "section": "",
    "text": "But how to know more about a function? The package/library developer have written helpful documentation for us.\n\n?log\nexample(log)\n\n\nlog&gt; log(exp(3))\n[1] 3\n\nlog&gt; log10(1e7) # = 7\n[1] 7\n\nlog&gt; x &lt;- 10^-(1+2*1:9)\n\nlog&gt; cbind(deparse.level=2, # to get nice column names\nlog+       x, log(1+x), log1p(x), exp(x)-1, expm1(x))\n          x   log(1 + x)     log1p(x)   exp(x) - 1     expm1(x)\n [1,] 1e-03 9.995003e-04 9.995003e-04 1.000500e-03 1.000500e-03\n [2,] 1e-05 9.999950e-06 9.999950e-06 1.000005e-05 1.000005e-05\n [3,] 1e-07 1.000000e-07 1.000000e-07 1.000000e-07 1.000000e-07\n [4,] 1e-09 1.000000e-09 1.000000e-09 1.000000e-09 1.000000e-09\n [5,] 1e-11 1.000000e-11 1.000000e-11 1.000000e-11 1.000000e-11\n [6,] 1e-13 9.992007e-14 1.000000e-13 9.992007e-14 1.000000e-13\n [7,] 1e-15 1.110223e-15 1.000000e-15 1.110223e-15 1.000000e-15\n [8,] 1e-17 0.000000e+00 1.000000e-17 0.000000e+00 1.000000e-17\n [9,] 1e-19 0.000000e+00 1.000000e-19 0.000000e+00 1.000000e-19\n\n?log()"
  },
  {
    "objectID": "ch/rbasics/firststeps.html#working-with-vectors",
    "href": "ch/rbasics/firststeps.html#working-with-vectors",
    "title": "Basic R",
    "section": "",
    "text": "What is a vector? See the example and think.\n\nx &lt;- c(1, 2, 3, 4, 5) #c means concatenate\nz &lt;- 1:5 #consecutively, from 1 through 5. A short-hand notation using :\ny &lt;- c(3, 6, 9, 12, 15, 20)\nlength(x)\n\n[1] 5\n\nmode(x)\n\n[1] \"numeric\"\n\nis(x)\n\n[1] \"numeric\" \"vector\" \n\nx[1] #first entry in vector y\n\n[1] 1\n\nx[2:5] #2nd to 5th entries in vector y\n\n[1] 2 3 4 5\n\nDNA &lt;- c(\"A\", \"T\", \"G\", \"C\") #character vector. Notice the quotation marks.\ndec &lt;- c(10.0, 20.5, 30, 60, 80.9, 90, 100.7, 50, 40, 45, 48, 56, 55) #vector of floats. All numbers became floats, it's called coercion\ndec[c(1:3, 7:length(dec))] #1st to 3rd and then 7th till the end of vector `dec`. Output as a vector.\n\n [1]  10.0  20.5  30.0 100.7  50.0  40.0  45.0  48.0  56.0  55.0\n\n\n\nNotice the element-wise or index-wise mathematical operations (+, /, log2(), round(), etc.). Noticed?\n\nx &lt;- 1:10\ny &lt;- 2:11\n#x and y are of same length\nx + y\n\n [1]  3  5  7  9 11 13 15 17 19 21\n\ny / x\n\n [1] 2.000000 1.500000 1.333333 1.250000 1.200000 1.166667 1.142857 1.125000\n [9] 1.111111 1.100000\n\nlog2(x)\n\n [1] 0.000000 1.000000 1.584963 2.000000 2.321928 2.584963 2.807355 3.000000\n [9] 3.169925 3.321928\n\nround(log2(x), 1) #log2 of all the values of `x`, 1 digit after decimal to round.\n\n [1] 0.0 1.0 1.6 2.0 2.3 2.6 2.8 3.0 3.2 3.3\n\nround(log2(x), 3) #same logic\n\n [1] 0.000 1.000 1.585 2.000 2.322 2.585 2.807 3.000 3.170 3.322\n\n\n\n\n\n\n\n\nNote\n\n\n\nNested functions work inside out. Think again about round(log2(x), 1) and you will see it. At first, it is making log2 of vector x and then it is rounding the log2 values to one digit after decimal. Got it?"
  },
  {
    "objectID": "ch/rbasics/firststeps.html#data-frame",
    "href": "ch/rbasics/firststeps.html#data-frame",
    "title": "Basic R",
    "section": "",
    "text": "Now, it’s time to use vectors to make data sets…..\n\nnames &lt;- c(\"Mina\", \"Raju\", \"Mithu\", \"Lali\")\ngender &lt;- c(\"Female\", \"Male\", \"Female\", \"Female\")\nage &lt;- c(15, 12, 2, 3)\nis_human &lt;- c(TRUE, TRUE, FALSE, FALSE)\ncartoon &lt;- data.frame(names, gender, age, is_human)\nwrite.table(cartoon, \"cartoon.csv\", sep = \",\", col.names = TRUE)\ndf &lt;- read.table(\"cartoon.csv\", header = TRUE, sep = \",\")\ndim(df) #`dim` means dimension. so, rows * columns\n\n[1] 4 4\n\nstr(df) #structure of `df`\n\n'data.frame':   4 obs. of  4 variables:\n $ names   : chr  \"Mina\" \"Raju\" \"Mithu\" \"Lali\"\n $ gender  : chr  \"Female\" \"Male\" \"Female\" \"Female\"\n $ age     : int  15 12 2 3\n $ is_human: logi  TRUE TRUE FALSE FALSE\n\n\nWe made the vectors first, and the used them to make the cartton data frame or table. We learned how to export the data frame using write.table function. Also, we learned to import or read back the table using read.table function. What are the sep, col.names, header arguments there? Why do we need them? Think. Try thinking of different properties of a data set.\n\n\ngene_expr &lt;- data.frame(\n  genes = c(\"TP53\", \"BRCA1\", \"MYC\", \"EGFR\", \"GAPDH\", \"CDC2\"),\n  sample1 = c(8.2, 6.1, 9.5, 7.0, 10.0, 12),\n  Sample2 = c(5.9, 3.9, 7.2, 4.8, 7.9, 9),\n  Sample3 = c(8.25, 6.15, 9.6, 7.1, 10.1, 11.9),\n  pathways = c(\"Apoptosis\", \"DNA Repair\", \"Cell Cycle\", \"Signaling\", \"Housekeeping\", \"Cell Division\")\n)\nwrite.table(gene_expr, \"gene_expr.csv\", sep = \",\", col.names = TRUE)\ngene_set &lt;- read.table(\"gene_expr.csv\", header = TRUE, sep = \",\")\n\n\n\n\n\n\n\nNote\n\n\n\nHere, we directly used the vectors as different columns while making the data frame. Did you notice that? Also, the syntax is different here. We can’t assign the vectors with the assignment operator (means we can’t use &lt;- sign. We have to use the = sign). Try using the &lt;- sign. Did you notice the column names?"
  },
  {
    "objectID": "ch/rbasics/firststeps.html#getting-started",
    "href": "ch/rbasics/firststeps.html#getting-started",
    "title": "Basic R",
    "section": "Getting Started",
    "text": "Getting Started\nInstallation of R Markdown\nWe will use rmarkdown to have the flexibility of writing codes like the one you are reading now. If you haven’t installed the rmarkdown package yet, you can do so with:\n\n# Install rmarkdown package\n#install.packages(\"rmarkdown\")\nlibrary(rmarkdown)\n# Other useful packages we might use\n#install.packages(\"dplyr\")    # Data manipulation\nlibrary(dplyr)\n#install.packages(\"readr\")    # Reading CSV files\nlibrary(readr)\n\nRemove the hash sign before the install.packages(\"rmarkdown\"), install.packages(\"dplyr\"), install.packages(\"readr\") if the library loading fails. That means the package is not there to be loaded. We need to download/install first.\n\n\n\n\n\n\nNote\n\n\n\nDo you remember this book by Hadley Wickham?. Try to follow it to get the hold on the basic R syntax and lexicon.\n\n\nBasic Setup for Today’s Session\n\n# Clear environment\nrm(list = ls())\n\n# Check working directory\ngetwd()\n\n# Set working directory if needed\n# setwd(\"path/to/your/directory\")  # Uncomment and modify as needed\n\nBuilding on Last HW:\n\ncartoon &lt;- data.frame(\n  names = c(\"Mina\", \"Raju\", \"Mithu\", \"Lali\"),\n  gender = c(\"Female\", \"Male\", \"Female\", \"Female\"),\n  age = c(15, 12, 2, 3),\n  is_human = c(TRUE, TRUE, FALSE, FALSE)\n)\ncartoon\n\n  names gender age is_human\n1  Mina Female  15     TRUE\n2  Raju   Male  12     TRUE\n3 Mithu Female   2    FALSE\n4  Lali Female   3    FALSE\n\ndim(cartoon)\n\n[1] 4 4\n\nstr(cartoon)\n\n'data.frame':   4 obs. of  4 variables:\n $ names   : chr  \"Mina\" \"Raju\" \"Mithu\" \"Lali\"\n $ gender  : chr  \"Female\" \"Male\" \"Female\" \"Female\"\n $ age     : num  15 12 2 3\n $ is_human: logi  TRUE TRUE FALSE FALSE\n\nlength(cartoon$names)\n\n[1] 4\n\n##subseting\ncartoon[1:2, 2:3] #row 1-2, column 2-3\n\n  gender age\n1 Female  15\n2   Male  12\n\ncartoon[c(1, 3), c(1:3)] #row 1-3, column 1-3\n\n  names gender age\n1  Mina Female  15\n3 Mithu Female   2\n\n#condition for selecting only male characters\nmale_df &lt;- cartoon[cartoon$gender == \"Male\", ]\nmale_df\n\n  names gender age is_human\n2  Raju   Male  12     TRUE\n\n#condition for selecting female characters with age more than 2 years\nfemale_age &lt;- cartoon[cartoon$gender == \"Female\" & cartoon$age &gt; 2, ]\nfemale_age\n\n  names gender age is_human\n1  Mina Female  15     TRUE\n4  Lali Female   3    FALSE\n\nsum(female_age$age) #sum of age of female_age dataset\n\n[1] 18\n\nsd(cartoon$age) #standard deviation of age of main cartoon dataset\n\n[1] 6.480741\n\nmean(cartoon$age) #mean of age of main cartoon dataset\n\n[1] 8\n\n\nCheck your colleague’s repo for the Q3.\nLogical Operators\n\n\nOperator\nMeaning\nExample\n\n\n\n==\nEqual to\nx == 5\n\n\n!=\nNot equal\nx != 5\n\n\n&lt;\nLess than\nx &lt; 5\n\n\n&gt;\nGreater than\nx &gt; 5\n\n\n&lt;=\nLess or equal\nx &lt;= 5\n\n\n&gt;=\nGreater or equal\nx &gt;= 5\n\n\n!\nNot\n!(x &lt; 5)\n\n\n|\nOR\nx &lt; 5 | x &gt; 10\n\n\n&\nAND\nx &gt; 5 & x &lt; 10\n\n\nPreamble on random variables (RV):\nRV is so fundamental of an idea to interpret and do better in any kind of data analyses. But what is it? Let’s imagine this scenario first. You got 30 mice to do an experiment to check anti-diabetic effect of a plant extract. You randomly assigned them into 3 groups. control, treat1 (meaning insulin receivers), and treat2 (meaning your plant extract receivers). Then you kept testing and measuring. You have mean glucose level of every mouse and show whether the mean value of treat1 is equal to treat2 or not. So, are you done? Not really. Be fastidious about the mice. What if you got some other 30 mice? Are they the same? Will their mean glucose level be the same? No, right. We would end up with different mean value. We call this type of quantities RV. Mean, Standard deviation, median, variance, etc. all are RVs. Do you see the logic? That’s why we put this constraint and look for p-value, confidence interval (or CI), etc. by (null) hypothesis testing and sample distribution analyses. We will get into these stuffs later. But let’s check what I meant. Also ponder about sample vs population.\nLet’s download the data first.\n\n# Download small example dataset\ndownload.file(\"https://raw.githubusercontent.com/genomicsclass/dagdata/master/inst/extdata/femaleControlsPopulation.csv\",\n              destfile = \"mice.csv\")\n\n# Load data\nmice &lt;- read.csv(\"mice.csv\")\n\nLet’s check now.\n\ncontrol &lt;- sample(mice$Bodyweight,12)\nmean(control)\n\n[1] 24.6725\n\ncontrol1 &lt;- sample(mice$Bodyweight,12)\nmean(control1)\n\n[1] 24.73417\n\ncontrol2 &lt;- sample(mice$Bodyweight,12)\nmean(control2)\n\n[1] 26.68917\n\n\nDo you see the difference in the mean value now?\nBasic Stuffs: Atomic Vector\n\natomic_vec &lt;- c(Human=0.5, Mouse=0.33)\n\nIt is fast, but has limited access methods.\nHow to access elements here?\n\natomic_vec[\"Human\"]\n\nHuman \n  0.5 \n\natomic_vec[\"Mouse\"]\n\nMouse \n 0.33 \n\n\nBasic Stuffs: Matrices\nMatrices are essential for biologists working with expression data, distance matrices, and other numerical data.\n\n# Create a gene expression matrix: rows=genes, columns=samples\nexpr_matrix &lt;- matrix(\n  c(12.3, 8.7, 15.2, 6.8,\n    9.5, 11.2, 13.7, 7.4,\n    5.6, 6.8, 7.9, 6.5),\n  nrow = 3, ncol = 4, byrow = TRUE\n)\n\n# Add dimension names\nrownames(expr_matrix) &lt;- c(\"BRCA1\", \"TP53\", \"GAPDH\")\ncolnames(expr_matrix) &lt;- c(\"Control_1\", \"Control_2\", \"Treatment_1\", \"Treatment_2\")\nexpr_matrix\n\n      Control_1 Control_2 Treatment_1 Treatment_2\nBRCA1      12.3       8.7        15.2         6.8\nTP53        9.5      11.2        13.7         7.4\nGAPDH       5.6       6.8         7.9         6.5\n\n# Matrix dimensions\ndim(expr_matrix)       # Returns rows and columns\n\n[1] 3 4\n\nnrow(expr_matrix)      # Number of rows\n\n[1] 3\n\nncol(expr_matrix)      # Number of columns\n\n[1] 4\n\n# Matrix subsetting\nexpr_matrix[2, ]       # One gene, all samples\n\n  Control_1   Control_2 Treatment_1 Treatment_2 \n        9.5        11.2        13.7         7.4 \n\nexpr_matrix[, 3:4]     # All genes, treatment samples only\n\n      Treatment_1 Treatment_2\nBRCA1        15.2         6.8\nTP53         13.7         7.4\nGAPDH         7.9         6.5\n\nexpr_matrix[\"TP53\", c(\"Control_1\", \"Treatment_1\")]  # Specific gene and samples\n\n  Control_1 Treatment_1 \n        9.5        13.7 \n\n# Matrix calculations (useful for bioinformatics)\n# Mean expression per gene\ngene_means &lt;- rowMeans(expr_matrix)\ngene_means\n\nBRCA1  TP53 GAPDH \n10.75 10.45  6.70 \n\n# Mean expression per sample\nsample_means &lt;- colMeans(expr_matrix)\nsample_means\n\n  Control_1   Control_2 Treatment_1 Treatment_2 \n   9.133333    8.900000   12.266667    6.900000 \n\n# Calculate fold change (Treatment vs Control)\ncontrol_means &lt;- rowMeans(expr_matrix[, 1:2])\ntreatment_means &lt;- rowMeans(expr_matrix[, 3:4])\nfold_change &lt;- treatment_means / control_means\nfold_change\n\n   BRCA1     TP53    GAPDH \n1.047619 1.019324 1.161290 \n\n# Matrix visualization\n# Heatmap of expression data\nheatmap(expr_matrix, \n        Colv = NA,         # Don't cluster columns\n        scale = \"row\",     # Scale by row (gene)\n        col = heat.colors(16),\n        main = \"Gene Expression Heatmap\")\n\n\n\n\nMore Matrix Practice:\n\n#Create a simple Gene Expression matrix (RNA-seq style)\n\nGene_Expression &lt;- matrix(c(\n  5.2, 3.1, 8.5,   # Sample 1\n  6.0, 2.8, 7.9    # Sample 2\n), nrow = 2, byrow = TRUE)\n\nrownames(Gene_Expression) &lt;- c(\"Sample_1\", \"Sample_2\")\ncolnames(Gene_Expression) &lt;- c(\"GeneA\", \"GeneB\", \"GeneC\")\n\nprint(\"Gene Expression Matrix:\")\n\n[1] \"Gene Expression Matrix:\"\n\nprint(Gene_Expression)\n\n         GeneA GeneB GeneC\nSample_1   5.2   3.1   8.5\nSample_2   6.0   2.8   7.9\n\n#1. Transpose: Genes become rows, Samples become columns\n\nGene_Expression_T &lt;- t(Gene_Expression)\nprint(\"Transpose of Gene Expression Matrix:\")\n\n[1] \"Transpose of Gene Expression Matrix:\"\n\nprint(Gene_Expression_T)\n\n      Sample_1 Sample_2\nGeneA      5.2      6.0\nGeneB      3.1      2.8\nGeneC      8.5      7.9\n\n#2. Matrix multiplication\n# Suppose each gene has an associated \"gene weight\" (e.g., biological importance)\n\nGene_Weights &lt;- matrix(c(0.8, 1.2, 1.0), nrow = 3, byrow = TRUE)\nrownames(Gene_Weights) &lt;- c(\"GeneA\", \"GeneB\", \"GeneC\")\ncolnames(Gene_Weights) &lt;- c(\"Weight\")\n\nTotal_Weighted_Expression &lt;- Gene_Expression %*% Gene_Weights\nprint(\"Total Weighted Expression per Sample:\")\n\n[1] \"Total Weighted Expression per Sample:\"\n\nprint(Total_Weighted_Expression)\n\n         Weight\nSample_1  16.38\nSample_2  16.06\n\n# 3. Matrix addition\n# Hypothetically increase expression by 1 TPM everywhere (technical adjustment)\n\nAdjusted_Expression &lt;- Gene_Expression + 1\nprint(\"Expression Matrix after adding 1 TPM:\")\n\n[1] \"Expression Matrix after adding 1 TPM:\"\n\nprint(Adjusted_Expression)\n\n         GeneA GeneB GeneC\nSample_1   6.2   4.1   9.5\nSample_2   7.0   3.8   8.9\n\n# 4. Identity matrix \nI &lt;- diag(3)\nrownames(I) &lt;- c(\"GeneA\", \"GeneB\", \"GeneC\")\ncolnames(I) &lt;- c(\"GeneA\", \"GeneB\", \"GeneC\")\n\nprint(\"Identity Matrix (for genes):\")\n\n[1] \"Identity Matrix (for genes):\"\n\nprint(I)\n\n      GeneA GeneB GeneC\nGeneA     1     0     0\nGeneB     0     1     0\nGeneC     0     0     1\n\n# Multiplying Gene Expression by Identity\nIdentity_Check &lt;- Gene_Expression %*% I\nprint(\"Gene Expression multiplied by Identity Matrix:\")\n\n[1] \"Gene Expression multiplied by Identity Matrix:\"\n\nprint(Identity_Check)\n\n         GeneA GeneB GeneC\nSample_1   5.2   3.1   8.5\nSample_2   6.0   2.8   7.9\n\n# 5. Scalar multiplication \n# Suppose you want to simulate doubling expression values\n\nDoubled_Expression &lt;- 2 * Gene_Expression\nprint(\"Doubled Gene Expression:\")\n\n[1] \"Doubled Gene Expression:\"\n\nprint(Doubled_Expression)\n\n         GeneA GeneB GeneC\nSample_1  10.4   6.2  17.0\nSample_2  12.0   5.6  15.8\n\n# 6. Summations \n\n# Total expression per sample\nTotal_Expression_Per_Sample &lt;- rowSums(Gene_Expression)\nprint(\"Total Expression per Sample:\")\n\n[1] \"Total Expression per Sample:\"\n\nprint(Total_Expression_Per_Sample)\n\nSample_1 Sample_2 \n    16.8     16.7 \n\n# Total expression per gene\nTotal_Expression_Per_Gene &lt;- colSums(Gene_Expression)\nprint(\"Total Expression per Gene:\")\n\n[1] \"Total Expression per Gene:\"\n\nprint(Total_Expression_Per_Gene)\n\nGeneA GeneB GeneC \n 11.2   5.9  16.4 \n\n# 7. Simple plots \n\n# Barplot: Total expression per sample\nbarplot(Total_Expression_Per_Sample, main=\"Total Expression per Sample\", ylab=\"TPM\", col=c(\"skyblue\", \"salmon\"))\n\n\n\n# Barplot: Total expression per gene\nbarplot(Total_Expression_Per_Gene, main=\"Total Expression per Gene\", ylab=\"TPM\", col=c(\"lightgreen\", \"orange\", \"violet\"))\n\n\n\n# Heatmap: Expression matrix\nheatmap(Gene_Expression, Rowv=NA, Colv=NA, col=heat.colors(256), scale=\"column\", main=\"Gene Expression Heatmap\")\n\n\n\n\nAnother Example: You have counts of cells in different organs for two animal species.\nYou also have a matrix with average cell sizes (micrometer, µm²) for each organ.\nYou can then multiply count × size to get total cell area for each species in each organ.\n\n# Create a matrix: Cell counts\nCell_Counts &lt;- matrix(c(500, 600, 300, 400, 700, 800), nrow = 2, byrow = TRUE)\nrownames(Cell_Counts) &lt;- c(\"Mouse\", \"Rat\")\ncolnames(Cell_Counts) &lt;- c(\"Heart\", \"Liver\", \"Brain\")\n\nprint(\"Cell Counts Matrix:\")\n\n[1] \"Cell Counts Matrix:\"\n\nprint(Cell_Counts)\n\n      Heart Liver Brain\nMouse   500   600   300\nRat     400   700   800\n\n# Create a matrix: Average cell size in µm²\nCell_Size &lt;- matrix(c(50, 200, 150), nrow = 3, byrow = TRUE)\nrownames(Cell_Size) &lt;- c(\"Heart\", \"Liver\", \"Brain\")\ncolnames(Cell_Size) &lt;- c(\"Avg_Cell_Size\")\n\nprint(\"Cell Size Matrix (µm²):\")\n\n[1] \"Cell Size Matrix (µm²):\"\n\nprint(Cell_Size)\n\n      Avg_Cell_Size\nHeart            50\nLiver           200\nBrain           150\n\n# 1. Transpose of Cell Counts\nCell_Counts_T &lt;- t(Cell_Counts)\nprint(\"Transpose of Cell Counts:\")\n\n[1] \"Transpose of Cell Counts:\"\n\nprint(Cell_Counts_T)\n\n      Mouse Rat\nHeart   500 400\nLiver   600 700\nBrain   300 800\n\n# 2. Matrix multiplication: Total cell area\n# (2x3) %*% (3x1) =&gt; (2x1)\nTotal_Cell_Area &lt;- Cell_Counts %*% Cell_Size\ncolnames(Total_Cell_Area) &lt;- \"Cell_area\"\nprint(\"Total Cell Area (Counts × Size) (µm²):\")\n\n[1] \"Total Cell Area (Counts × Size) (µm²):\"\n\nprint(Total_Cell_Area)\n\n      Cell_area\nMouse    190000\nRat      280000\n\n# 3. Matrix addition: Add 10 cells artificially to all counts (for example)\nAdded_Cells &lt;- Cell_Counts + 10\nprint(\"Cell Counts after adding 10 artificial cells:\")\n\n[1] \"Cell Counts after adding 10 artificial cells:\"\n\nprint(Added_Cells)\n\n      Heart Liver Brain\nMouse   510   610   310\nRat     410   710   810\n\n# 4. Identity matrix\nI &lt;- diag(3)\nrownames(I) &lt;- c(\"Heart\", \"Liver\", \"Brain\")\ncolnames(I) &lt;- c(\"Heart\", \"Liver\", \"Brain\")\n\nprint(\"Identity Matrix:\")\n\n[1] \"Identity Matrix:\"\n\nprint(I)\n\n      Heart Liver Brain\nHeart     1     0     0\nLiver     0     1     0\nBrain     0     0     1\n\n# 5. Multiplying Cell Counts by Identity Matrix (no real change but shows dimension rules)\nCheck_Identity &lt;- Cell_Counts %*% I\nprint(\"Cell Counts multiplied by Identity Matrix:\")\n\n[1] \"Cell Counts multiplied by Identity Matrix:\"\n\nprint(Check_Identity)\n\n      Heart Liver Brain\nMouse   500   600   300\nRat     400   700   800\n\n# 6. Scalar multiplication: double the counts (hypothetical growth)\nDouble_Cell_Counts &lt;- 2 * Cell_Counts\nprint(\"Doubled Cell Counts:\")\n\n[1] \"Doubled Cell Counts:\"\n\nprint(Double_Cell_Counts)\n\n      Heart Liver Brain\nMouse  1000  1200   600\nRat     800  1400  1600\n\n# Total number of cells per animal (row sums)\nTotal_Cells_Per_Species &lt;- rowSums(Cell_Counts)\nprint(\"Total number of cells per species:\")\n\n[1] \"Total number of cells per species:\"\n\nprint(Total_Cells_Per_Species)\n\nMouse   Rat \n 1400  1900 \n\n# Total number of cells per organ (column sums)\nTotal_Cells_Per_Organ &lt;- colSums(Cell_Counts)\nprint(\"Total number of cells per organ:\")\n\n[1] \"Total number of cells per organ:\"\n\nprint(Total_Cells_Per_Organ)\n\nHeart Liver Brain \n  900  1300  1100 \n\n# --- Simple plots ---\n\n# Bar plot of total cells per species\nbarplot(Total_Cells_Per_Species, main=\"Total Cell Counts per Species\", ylab=\"Number of Cells\", col=c(\"lightblue\", \"lightgreen\"))\n\n\n\n# Bar plot of total cells per organ\nbarplot(Total_Cells_Per_Organ, main=\"Total Cell Counts per Organ\", ylab=\"Number of Cells\", col=c(\"pink\", \"lightyellow\", \"lightgray\"))\n\n\n\n# Heatmap of the original Cell Counts matrix\nheatmap(Cell_Counts, Rowv=NA, Colv=NA, col=heat.colors(256), scale=\"column\", main=\"Heatmap of Cell Counts\")\n\n\n\n\n\n\n\n\n\n\n\nOperation\nExplanation\nR Function/Example\n\n\n\nMatrix Creation\nCreate gene expression matrix\nmatrix()\n\n\nTranspose\nFlip genes and samples\nt(Gene_Expression)\n\n\nMatrix Multiplication\nCalculate weighted sums\nGene_Expression %*% Gene_Weights\n\n\nMatrix Addition\nAdjust counts\nGene_Expression + 1\n\n\nIdentity Matrix\nSpecial neutral matrix\ndiag(3)\n\n\nScalar Multiplication\nSimulate overall increase\n2 * Gene_Expression\n\n\nRow/Column Summation\nTotal per sample/gene\n\nrowSums(), colSums()\n\n\n\nPlotting\nVisualize expression patterns\n\nbarplot(), heatmap()\n\n\n\nBasic Stuffs: List\nLists are the most flexible data structure in R - they can hold any combination of data types, including other lists! This makes them essential for biological data analysis where we often deal with mixed data types.\n\n# A list storing different types of genomic data\ngenomics_data &lt;- list(\n  gene_names = c(\"TP53\", \"BRCA1\", \"MYC\"),               # Character vector\n  expression = matrix(c(1.2, 3.4, 5.6, 7.8, 9.1, 2.3), nrow=3),    # Numeric matrix\n  is_cancer_gene = c(TRUE, TRUE, FALSE),                 # Logical vector\n  metadata = list(                                       # Nested list!\n    lab = \"CRG\",\n    date = \"2023-05-01\"\n  )\n)\n\nHow to Access Elements of a List?\n\n# Method 1: Double brackets [[ ]] for single element\ngenomics_data[[1]]  # Returns gene_names vector\n\n[1] \"TP53\"  \"BRCA1\" \"MYC\"  \n\n# Method 2: $ operator with names (when elements are named)\ngenomics_data$expression  # Returns the matrix\n\n     [,1] [,2]\n[1,]  1.2  7.8\n[2,]  3.4  9.1\n[3,]  5.6  2.3\n\n# Method 3: Single bracket [ ] returns a sublist\ngenomics_data[1:2]  # Returns list with first two elements\n\n$gene_names\n[1] \"TP53\"  \"BRCA1\" \"MYC\"  \n\n$expression\n     [,1] [,2]\n[1,]  1.2  7.8\n[2,]  3.4  9.1\n[3,]  5.6  2.3\n\n\nKey Difference from Vectors:\n\n# Compare to your prop.table() example:\natomic_vec[\"Human\"]    # Returns named numeric (vector)\n\nHuman \n  0.5 \n\natomic_vec[\"Mouse\"]\n\nMouse \n 0.33 \n\ngenomics_data[1] # Returns list containing the vector\n\n$gene_names\n[1] \"TP53\"  \"BRCA1\" \"MYC\"  \n\n\nWhy Biologists Need Lists?lm(), prcomp() functions, RNAseq analysis packages produces list. So, we need to learn how to handle lists.\nSee these examples:\nA. Storing BLAST results\n\nblast_hits &lt;- list(\n  query_id = \"GeneX\",\n  hit_ids = c(\"NP_123\", \"NP_456\"),\n  e_values = c(1e-50, 3e-12),\n  alignment = matrix(c(\"ATG...\", \"CTA...\"), ncol=1))\n\nB. Handling Mixed Data\n\npatient_data &lt;- list(\n  id = \"P1001\",\n  tests = data.frame(\n    test = c(\"WBC\", \"RBC\"),\n    value = c(4.5, 5.1)\n  ),\n  has_mutation = TRUE\n)\n\nCommon List Operations\n\n# Add new element\ngenomics_data$sequencer &lt;- \"Illumina\"\n\n# Remove element\ngenomics_data$is_cancer_gene &lt;- NULL\n\n# Check structure (critical for complex lists)\nstr(genomics_data)\n\nList of 4\n $ gene_names: chr [1:3] \"TP53\" \"BRCA1\" \"MYC\"\n $ expression: num [1:3, 1:2] 1.2 3.4 5.6 7.8 9.1 2.3\n $ metadata  :List of 2\n  ..$ lab : chr \"CRG\"\n  ..$ date: chr \"2023-05-01\"\n $ sequencer : chr \"Illumina\"\n\n\nBy the way, how would you add more patients?\n\n# Add new patient\npatient_data$P1002 &lt;- list(\n  id = \"P1002\",\n  tests = data.frame(\n    test = c(\"WBC\", \"RBC\", \"Platelets\"),\n    value = c(6.2, 4.8, 150)\n  ),\n  has_mutation = FALSE\n)\n# Access specific patient\npatient_data$P1001$test\n\nNULL\n\n\nFor Batch Processing:\n\npatients &lt;- list(\n  list(\n    id = \"P1001\",\n    tests = data.frame(test = c(\"WBC\", \"RBC\"), value = c(4.5, 5.1)),\n    has_mutation = TRUE\n  ),\n  list(\n    id = \"P1002\",\n    tests = data.frame(test = c(\"WBC\", \"RBC\", \"Platelets\"), value = c(6.2, 4.8, 150)),\n    has_mutation = FALSE\n  )\n)\n\n# Access 2nd patient's WBC value\npatients[[2]]$tests$value[patients[[2]]$tests$test == \"WBC\"]\n\n[1] 6.2\n\n\nConverting Between Structures\n\n# List → Vector\nunlist(genomics_data[1:3])\n\n  gene_names1   gene_names2   gene_names3   expression1   expression2 \n       \"TP53\"       \"BRCA1\"         \"MYC\"         \"1.2\"         \"3.4\" \n  expression3   expression4   expression5   expression6  metadata.lab \n        \"5.6\"         \"7.8\"         \"9.1\"         \"2.3\"         \"CRG\" \nmetadata.date \n \"2023-05-01\" \n\n\nVisualization\n\n# Base R plot from list data\nbarplot(unlist(genomics_data[2]),\n        names.arg = genomics_data[[1]])\n\nThis code won’t work if you run. unlist(genomics_data[2] creates a vector of length 6 from our 3*2 matrix but genomics_data[[1]] has 3 things inside the gene_names vector. Debug like this:\n\ndim(genomics_data$expression)  # e.g., 2 rows x 2 cols\n\n[1] 3 2\n\nlength(genomics_data$gene_names) # e.g., 3 genes\n\n[1] 3\n\n\nA. Gene-Centric (Mean Expression)\n\nbarplot(rowMeans(genomics_data$expression),\n        names.arg = genomics_data$gene_names,\n        col = \"steelblue\",\n        ylab = \"Mean Expression\",\n        main = \"Average Gene Expression\")\n\n\n\n\nB. Sample-Centric (All Measurements)\n\nbarplot(genomics_data$expression,\n        beside = TRUE,\n        names.arg = paste0(\"Sample_\", 1:ncol(genomics_data$expression)),\n        legend.text = genomics_data$gene_names,\n        args.legend = list(x = \"topright\", bty = \"n\"),\n        col = c(\"blue\", \"red\", \"green\"),\n        main = \"Expression Across Samples\")\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThis matches real-world scenarios:\nRNA-seq: Rows=genes, cols=samples\nrowMeans() = average expression per gene\nbeside=TRUE =&gt; compare samples within genes\nProteomics: Rows=proteins, cols=replicates\nSame principles apply\n\n\n\n# Calculate stats\ngene_means &lt;- rowMeans(genomics_data$expression)\ngene_sds &lt;- apply(genomics_data$expression, 1, sd)\n\n# Plot with error bars\nbp &lt;- barplot(gene_means, ylim = c(0, max(gene_means + gene_sds)))\narrows(bp, gene_means - gene_sds, bp, gene_means + gene_sds, \n       angle = 90, code = 3)\n\n\n\n\nTask: Create a list containing:\n\nA character vector of 3 gene names\nA numeric matrix of expression values\nA logical vector indicating pathway membership\nA nested list with lab metadata"
  },
  {
    "objectID": "ch/rbasics/firststeps.html#factor-variables-categorical-data",
    "href": "ch/rbasics/firststeps.html#factor-variables-categorical-data",
    "title": "Basic R",
    "section": "Factor Variables (Categorical Data)",
    "text": "Factor Variables (Categorical Data)\nCreating Factors\nFactors are used to represent categorical data in R. They are particularly important for biological data like genotypes, phenotypes, and experimental conditions.\n\n# Simple factor: DNA sample origins\norigins &lt;- c(\"Human\", \"Mouse\", \"Human\", \"Zebrafish\", \"Mouse\", \"Human\")\norigins_factor &lt;- factor(origins)\norigins_factor\n\n[1] Human     Mouse     Human     Zebrafish Mouse     Human    \nLevels: Human Mouse Zebrafish\n\n# Check levels (categories)\nlevels(origins_factor)\n\n[1] \"Human\"     \"Mouse\"     \"Zebrafish\"\n\n# Create a factor with predefined levels\ntreatment_groups &lt;- factor(c(\"Control\", \"Low_dose\", \"High_dose\", \"Control\", \"Low_dose\"),\n                         levels = c(\"Control\", \"Low_dose\", \"High_dose\"))\ntreatment_groups\n\n[1] Control   Low_dose  High_dose Control   Low_dose \nLevels: Control Low_dose High_dose\n\n# Ordered factors (important for severity, stages, etc.)\ndisease_severity &lt;- factor(c(\"Mild\", \"Severe\", \"Moderate\", \"Mild\", \"Critical\"),\n                         levels = c(\"Mild\", \"Moderate\", \"Severe\", \"Critical\"),\n                         ordered = TRUE)\ndisease_severity\n\n[1] Mild     Severe   Moderate Mild     Critical\nLevels: Mild &lt; Moderate &lt; Severe &lt; Critical\n\n# Compare with ordered factors\ndisease_severity[1] &lt; disease_severity[2]  # Is Mild less severe than Severe?\n\n[1] TRUE\n\n\nFactor Operations\n\n# Count frequencies\ntable(origins_factor)\n\norigins_factor\n    Human     Mouse Zebrafish \n        3         2         1 \n\n# Calculate proportions\nprop.table(table(origins_factor))\n\norigins_factor\n    Human     Mouse Zebrafish \n0.5000000 0.3333333 0.1666667 \n\n# Change reference level (important for statistical models)\norigins_factor_relevel &lt;- relevel(origins_factor, ref = \"Mouse\")\norigins_factor_relevel\n\n[1] Human     Mouse     Human     Zebrafish Mouse     Human    \nLevels: Mouse Human Zebrafish\n\n# Convert to character\nas.character(origins_factor)\n\n[1] \"Human\"     \"Mouse\"     \"Human\"     \"Zebrafish\" \"Mouse\"     \"Human\"    \n\n# Plot factors - Basic barplot\nbarplot(table(origins_factor), \n        col = c(\"blue\", \"green\", \"red\"),\n        main = \"Sample Origins\",\n        ylab = \"Count\")\n\n\n\n# More advanced plot with factors\n# Create sample data\ngene_expr &lt;- c(5.2, 7.8, 4.5, 12.3, 8.1, 3.7)\nnames(gene_expr) &lt;- as.character(origins)\n\n# Boxplot by factor\nboxplot(gene_expr ~ origins, \n        col = \"lightblue\",\n        main = \"Gene Expression by Sample Origin\", \n        xlab = \"Origin\", \n        ylab = \"Expression Level\")\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nKeep noticing the output formats. Sometimes the output is just a number, sometimes a vector or table or list, etc. Check prop.table(table(origins_factor)). How is it?\n\n\n\n\n\n\n\n\nGot it?\n\n\n\n\n\nprop &lt;- prop.table(table(origins_factor)) – is a named numeric vector (atomic vector). prop$Human or similar won’t work. Check this way: prop &lt;- prop.table(table(origins_factor)) prop prop[“Human”]; prop[“Mouse”]; prop[“Zebrafish”]\nOr make it a data frame (df) first, then try to use normal way of handling df.\n\n\n\nAccessing the Output:\n\nprop &lt;- prop.table(table(origins_factor))\nprop\n\norigins_factor\n    Human     Mouse Zebrafish \n0.5000000 0.3333333 0.1666667 \n\nprop[\"Human\"]; prop[\"Mouse\"]; prop[\"Zebrafish\"]\n\nHuman \n  0.5 \n\n\n    Mouse \n0.3333333 \n\n\nZebrafish \n0.1666667"
  },
  {
    "objectID": "ch/rbasics/firststeps.html#subsetting-data",
    "href": "ch/rbasics/firststeps.html#subsetting-data",
    "title": "Basic R",
    "section": "Subsetting Data",
    "text": "Subsetting Data\nVectors\n\n# Create a vector\nexpression_data &lt;- c(3.2, 4.5, 2.1, 6.7, 5.9, 3.3, 7.8, 2.9)\nnames(expression_data) &lt;- paste0(\"Sample_\", 1:8)\nexpression_data\n\nSample_1 Sample_2 Sample_3 Sample_4 Sample_5 Sample_6 Sample_7 Sample_8 \n     3.2      4.5      2.1      6.7      5.9      3.3      7.8      2.9 \n\n# Subset by position\nexpression_data[3]             # Single element\n\nSample_3 \n     2.1 \n\nexpression_data[c(1, 3, 5)]    # Multiple elements\n\nSample_1 Sample_3 Sample_5 \n     3.2      2.1      5.9 \n\nexpression_data[2:5]           # Range\n\nSample_2 Sample_3 Sample_4 Sample_5 \n     4.5      2.1      6.7      5.9 \n\n# Subset by name\nexpression_data[\"Sample_6\"]\n\nSample_6 \n     3.3 \n\nexpression_data[c(\"Sample_1\", \"Sample_8\")]\n\nSample_1 Sample_8 \n     3.2      2.9 \n\n# Subset by condition\nexpression_data[expression_data &gt; 5]              # Values &gt; 5\n\nSample_4 Sample_5 Sample_7 \n     6.7      5.9      7.8 \n\nexpression_data[expression_data &gt;= 3 & expression_data &lt;= 6]  # Values between 3 and 6\n\nSample_1 Sample_2 Sample_5 Sample_6 \n     3.2      4.5      5.9      3.3 \n\n\nData Frames\n\n# Create a data frame\ngene_df &lt;- data.frame(\n  gene_id = c(\"BRCA1\", \"TP53\", \"MYC\", \"EGFR\", \"GAPDH\"),\n  expression = c(8.2, 6.1, 9.5, 7.0, 10.0),\n  mutation = factor(c(\"Yes\", \"No\", \"Yes\", \"No\", \"No\")),\n  pathway = c(\"DNA Repair\", \"Apoptosis\", \"Cell Cycle\", \"Signaling\", \"Metabolism\")\n)\n\ngene_df\n\n  gene_id expression mutation    pathway\n1   BRCA1        8.2      Yes DNA Repair\n2    TP53        6.1       No  Apoptosis\n3     MYC        9.5      Yes Cell Cycle\n4    EGFR        7.0       No  Signaling\n5   GAPDH       10.0       No Metabolism\n\n# Subsetting by row index\ngene_df[1:3, ]         # First three rows, all columns\n\n  gene_id expression mutation    pathway\n1   BRCA1        8.2      Yes DNA Repair\n2    TP53        6.1       No  Apoptosis\n3     MYC        9.5      Yes Cell Cycle\n\n# Subsetting by column index\ngene_df[, 1:2]     # All rows, first two columns\n\n  gene_id expression\n1   BRCA1        8.2\n2    TP53        6.1\n3     MYC        9.5\n4    EGFR        7.0\n5   GAPDH       10.0\n\n# Subsetting by column name\ngene_df[, c(\"gene_id\", \"mutation\")]\n\n  gene_id mutation\n1   BRCA1      Yes\n2    TP53       No\n3     MYC      Yes\n4    EGFR       No\n5   GAPDH       No\n\n# Using the $ operator\ngene_df$expression\n\n[1]  8.2  6.1  9.5  7.0 10.0\n\ngene_df$mutation\n\n[1] Yes No  Yes No  No \nLevels: No Yes\n\n# Subsetting by condition\ngene_df[gene_df$expression &gt; 8, ]\n\n  gene_id expression mutation    pathway\n1   BRCA1        8.2      Yes DNA Repair\n3     MYC        9.5      Yes Cell Cycle\n5   GAPDH       10.0       No Metabolism\n\ngene_df[gene_df$mutation == \"Yes\", ]\n\n  gene_id expression mutation    pathway\n1   BRCA1        8.2      Yes DNA Repair\n3     MYC        9.5      Yes Cell Cycle\n\n# Multiple conditions\ngene_df[gene_df$expression &gt; 7 & gene_df$mutation == \"No\", ]\n\n  gene_id expression mutation    pathway\n5   GAPDH         10       No Metabolism\n\n\nLogical Operators\n\n\nOperator\nMeaning\nExample\n\n\n\n==\nEqual to\nx == 5\n\n\n!=\nNot equal\nx != 5\n\n\n&lt;\nLess than\nx &lt; 5\n\n\n&gt;\nGreater than\nx &gt; 5\n\n\n&lt;=\nLess or equal\nx &lt;= 5\n\n\n&gt;=\nGreater or equal\nx &gt;= 5\n\n\n!\nNot\n!(x &lt; 5)\n\n\n|\nOR\nx &lt; 5 | x &gt; 10\n\n\n&\nAND\nx &gt; 5 & x &lt; 10\n\n\nRow Names in Data Frames\nRow names are particularly important in bioinformatics where genes, proteins, or samples are often used as identifiers.\n\n# Setting row names for gene_df\nrownames(gene_df) &lt;- gene_df$gene_id\ngene_df\n\n      gene_id expression mutation    pathway\nBRCA1   BRCA1        8.2      Yes DNA Repair\nTP53     TP53        6.1       No  Apoptosis\nMYC       MYC        9.5      Yes Cell Cycle\nEGFR     EGFR        7.0       No  Signaling\nGAPDH   GAPDH       10.0       No Metabolism\n\n\nWe can now drop the gene_id column, if required.\n\ngene_df_clean &lt;- gene_df[, -1]  # Remove the first column\ngene_df_clean\n\n      expression mutation    pathway\nBRCA1        8.2      Yes DNA Repair\nTP53         6.1       No  Apoptosis\nMYC          9.5      Yes Cell Cycle\nEGFR         7.0       No  Signaling\nGAPDH       10.0       No Metabolism\n\n# Access rows by name\ngene_df_clean[\"TP53\", ]\n\n     expression mutation   pathway\nTP53        6.1       No Apoptosis\n\n# Check if row names are unique\nany(duplicated(rownames(gene_df_clean)))\n\n[1] FALSE\n\n# Handle potential duplicated row names\n# NOTE: R doesn't allow duplicate row names by default\ndup_genes &lt;- data.frame(\n  expression = c(5.2, 6.3, 5.2, 8.1),\n  mutation = c(\"Yes\", \"No\", \"Yes\", \"No\")\n)\n\n# This would cause an error:\n#rownames(dup_genes) &lt;- c(\"BRCA1\", \"BRCA1\", \"TP53\", \"EGFR\")\n\n# Instead, we can preemptively make them unique:\nproposed_names &lt;- c(\"BRCA1\", \"BRCA1\", \"TP53\", \"EGFR\")\nunique_names &lt;- make.unique(proposed_names)\nunique_names  # Show the generated unique names\n\n[1] \"BRCA1\"   \"BRCA1.1\" \"TP53\"    \"EGFR\"   \n\n# Now we can safely assign them\nrownames(dup_genes) &lt;- unique_names\ndup_genes\n\n        expression mutation\nBRCA1          5.2      Yes\nBRCA1.1        6.3       No\nTP53           5.2      Yes\nEGFR           8.1       No\n\n\n\n\n\n\n\n\nNote\n\n\n\nWhy is unique name important for us? Imagine this meaningful biological scenario: one gene might transcribed into many transcript isoforms and hence many protein isoforms. From RNAseq data, we might get alignment count for each gene. But then we can separate the count for each transcript. One gene has one name or ID, but the transcripts are many for the same gene! So, we can denote, for example, 21 isoform of geneA like genA.1, geneA.2, geneA.3,……., geneA.21. See this link for MBP gene. How many transcript isoforms does it have?"
  },
  {
    "objectID": "ch/rbasics/firststeps.html#handling-missingwrong-values",
    "href": "ch/rbasics/firststeps.html#handling-missingwrong-values",
    "title": "Basic R",
    "section": "Handling Missing/Wrong Values",
    "text": "Handling Missing/Wrong Values\nIdentifying Issues\n\n# Create data with missing values\nclinical_data &lt;- data.frame(\n  patient_id = 1:5,\n  age = c(25, 99, 30, -5, 40),    # -5 is wrong, 99 is suspect\n  bp = c(120, NA, 115, 125, 118),  # NA is missing\n  weight = c(65, 70, NA, 68, -1)   # -1 is wrong\n)\nclinical_data\n\n  patient_id age  bp weight\n1          1  25 120     65\n2          2  99  NA     70\n3          3  30 115     NA\n4          4  -5 125     68\n5          5  40 118     -1\n\n# Check for missing values\nis.na(clinical_data)\n\n     patient_id   age    bp weight\n[1,]      FALSE FALSE FALSE  FALSE\n[2,]      FALSE FALSE  TRUE  FALSE\n[3,]      FALSE FALSE FALSE   TRUE\n[4,]      FALSE FALSE FALSE  FALSE\n[5,]      FALSE FALSE FALSE  FALSE\n\ncolSums(is.na(clinical_data))  # Count NAs by column\n\npatient_id        age         bp     weight \n         0          0          1          1 \n\n# Check for impossible values\nclinical_data$age &lt; 0\n\n[1] FALSE FALSE FALSE  TRUE FALSE\n\nclinical_data$weight &lt; 0\n\n[1] FALSE FALSE    NA FALSE  TRUE\n\n# Find indices of problematic values\nwhich(clinical_data$age &lt; 0 | clinical_data$age &gt; 90)\n\n[1] 2 4\n\n\nFixing Data\n\n# Replace impossible values with NA\nclinical_data$age[clinical_data$age &lt; 0 | clinical_data$age &gt; 90] &lt;- NA\nclinical_data$weight[clinical_data$weight &lt; 0] &lt;- NA\nclinical_data\n\n  patient_id age  bp weight\n1          1  25 120     65\n2          2  NA  NA     70\n3          3  30 115     NA\n4          4  NA 125     68\n5          5  40 118     NA\n\n# Replace NAs with mean (common in biological data)\nclinical_data$bp[is.na(clinical_data$bp)] &lt;- mean(clinical_data$bp, na.rm = TRUE)\nclinical_data$weight[is.na(clinical_data$weight)] &lt;- mean(clinical_data$weight, na.rm = TRUE)\nclinical_data\n\n  patient_id age    bp   weight\n1          1  25 120.0 65.00000\n2          2  NA 119.5 70.00000\n3          3  30 115.0 67.66667\n4          4  NA 125.0 68.00000\n5          5  40 118.0 67.66667\n\n# Replace NAs with median (better for skewed data)\nclinical_data$age[is.na(clinical_data$age)] &lt;- median(clinical_data$age, na.rm = TRUE)\nclinical_data\n\n  patient_id age    bp   weight\n1          1  25 120.0 65.00000\n2          2  30 119.5 70.00000\n3          3  30 115.0 67.66667\n4          4  30 125.0 68.00000\n5          5  40 118.0 67.66667"
  },
  {
    "objectID": "ch/rbasics/firststeps.html#data-transformation",
    "href": "ch/rbasics/firststeps.html#data-transformation",
    "title": "Basic R",
    "section": "Data Transformation",
    "text": "Data Transformation\nIntroduction to Outliers\nOutliers can significantly affect statistical analyses, especially in biological data where sample variation can be high.\n\n# Create data with outliers\nexpression_levels &lt;- c(2.3, 2.7, 3.1, 2.9, 2.5, 3.0, 15.2, 2.8)\nboxplot(expression_levels, \n        main = \"Expression Levels with Outlier\",\n        ylab = \"Expression\")\n\n\n\n\nIdentifying Outliers\n\n# Statistical approach: Values beyond 1.5*IQR\ndata_summary &lt;- summary(expression_levels)\ndata_summary\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  2.300   2.650   2.850   4.312   3.025  15.200 \n\nIQR_value &lt;- IQR(expression_levels)\nupper_bound &lt;- data_summary[\"3rd Qu.\"] + 1.5 * IQR_value\nlower_bound &lt;- data_summary[\"1st Qu.\"] - 1.5 * IQR_value\n\n# Find outliers\noutliers &lt;- expression_levels[expression_levels &gt; upper_bound | \n                             expression_levels &lt; lower_bound]\noutliers\n\n[1] 15.2\n\n\nTransforming Vectors\nMathematical transformations can normalize data, reduce outlier effects, and make data more suitable for statistical analyses.\n\n# Original data\ngene_exp &lt;- c(15, 42, 87, 115, 320, 560, 1120)\nhist(gene_exp, main = \"Original Expression Values\", xlab = \"Expression\")\n\n\n\n# Log transformation (common in gene expression analysis)\nlog_exp &lt;- log2(gene_exp)\nhist(log_exp, main = \"Log2 Transformed Expression\", xlab = \"Log2 Expression\")\n\n\n\n# Square root transformation (less aggressive than log)\nsqrt_exp &lt;- sqrt(gene_exp)\nhist(sqrt_exp, main = \"Square Root Transformed Expression\", xlab = \"Sqrt Expression\")\n\n\n\n# Z-score normalization (standardization)\nz_exp &lt;- scale(gene_exp)\nhist(z_exp, main = \"Z-score Normalized Expression\", xlab = \"Z-score\")\n\n\n\n# Compare transformations\npar(mfrow = c(2, 2))\nhist(gene_exp, main = \"Original\")\nhist(log_exp, main = \"Log2\")\nhist(sqrt_exp, main = \"Square Root\")\nhist(z_exp, main = \"Z-score\")\n\n\n\npar(mfrow = c(1, 1))  # Reset plotting layout\n\nLogical Expressions\n\n# Create gene expression vector\nexp_data &lt;- c(5.2, 3.8, 7.1, 2.9, 6.5, 8.0, 4.3)\nnames(exp_data) &lt;- paste0(\"Gene_\", 1:7)\n\n# Basic comparisons\nexp_data &gt; 5    # Which genes have expression &gt; 5?\n\nGene_1 Gene_2 Gene_3 Gene_4 Gene_5 Gene_6 Gene_7 \n  TRUE  FALSE   TRUE  FALSE   TRUE   TRUE  FALSE \n\nexp_data &lt;= 4   # Which genes have expression &lt;= 4?\n\nGene_1 Gene_2 Gene_3 Gene_4 Gene_5 Gene_6 Gene_7 \n FALSE   TRUE  FALSE   TRUE  FALSE  FALSE  FALSE \n\n# Store results in logical vector\nhigh_exp &lt;- exp_data &gt; 6\nhigh_exp\n\nGene_1 Gene_2 Gene_3 Gene_4 Gene_5 Gene_6 Gene_7 \n FALSE  FALSE   TRUE  FALSE   TRUE   TRUE  FALSE \n\n# Use logical vectors for subsetting\nexp_data[high_exp]  # Get high expression values\n\nGene_3 Gene_5 Gene_6 \n   7.1    6.5    8.0 \n\n\nLogical Operators\n\n# Combining conditions with AND (&)\nexp_data &gt; 4 & exp_data &lt; 7  # Expression between 4 and 7\n\nGene_1 Gene_2 Gene_3 Gene_4 Gene_5 Gene_6 Gene_7 \n  TRUE  FALSE  FALSE  FALSE   TRUE  FALSE   TRUE \n\n# Combining conditions with OR (|)\nexp_data &lt; 4 | exp_data &gt; 7  # Expression less than 4 OR greater than 7\n\nGene_1 Gene_2 Gene_3 Gene_4 Gene_5 Gene_6 Gene_7 \n FALSE   TRUE   TRUE   TRUE  FALSE   TRUE  FALSE \n\n# Using NOT (!)\n!high_exp  # Not high expression\n\nGene_1 Gene_2 Gene_3 Gene_4 Gene_5 Gene_6 Gene_7 \n  TRUE   TRUE  FALSE   TRUE  FALSE  FALSE   TRUE \n\n# Subsetting with combined conditions\nexp_data[exp_data &gt; 4 & exp_data &lt; 7]  # Get values between 4 and 7\n\nGene_1 Gene_5 Gene_7 \n   5.2    6.5    4.3 \n\n\nLogical Functions\n\n# all() - Are all values TRUE?\nall(exp_data &gt; 0)  # Are all expressions positive?\n\n[1] TRUE\n\n# any() - Is at least one value TRUE?\nany(exp_data &gt; 7)  # Is any expression greater than 7?\n\n[1] TRUE\n\n# which() - Get indices of TRUE values\nwhich(exp_data &gt; 6)  # Which elements have expressions &gt; 6?\n\nGene_3 Gene_5 Gene_6 \n     3      5      6 \n\n# %in% operator - Test for membership\ntest_genes &lt;- c(\"Gene_1\", \"Gene_5\", \"Gene_9\")\nnames(exp_data) %in% test_genes  # Which names match test_genes?\n\n[1]  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE\n\n\nPractical Session\nCheck out this repo: https://github.com/genomicsclass/dagdata/\n\n# Download small example dataset\ndownload.file(\"https://github.com/genomicsclass/dagdata/raw/master/inst/extdata/msleep_ggplot2.csv\",\n              destfile = \"msleep_data.csv\")\n\n# Load data\nmsleep &lt;- read.csv(\"msleep_data.csv\")\n\n\nConvert ‘vore’ column to factor and plot its distribution.\nCreate a matrix of sleep data columns and add row names.\nFind and handle any missing values.\nCalculate mean sleep time by diet category (vore).\nIdentify outliers in sleep_total."
  },
  {
    "objectID": "ch/rbasics/firststeps.html#practical-session",
    "href": "ch/rbasics/firststeps.html#practical-session",
    "title": "Basic R",
    "section": "Practical Session",
    "text": "Practical Session\nCheck out this repo: https://github.com/genomicsclass/dagdata/\n\n# Download small example dataset\ndownload.file(\"https://github.com/genomicsclass/dagdata/raw/master/inst/extdata/msleep_ggplot2.csv\",\n              destfile = \"msleep_data.csv\")\n\n# Load data\nmsleep &lt;- read.csv(\"msleep_data.csv\")\n\nIn-class Tasks:\n\nConvert ‘vore’ column to factor and plot its distribution.\nCreate a matrix of sleep data columns and add row names.\nFind and handle any missing values.\nCalculate mean sleep time by diet category (vore).\nIdentify outliers in sleep_total."
  },
  {
    "objectID": "ch/rbasics/firststeps.html#summary-of-todays-lesson",
    "href": "ch/rbasics/firststeps.html#summary-of-todays-lesson",
    "title": "Basic R",
    "section": "Summary of Today’s Lesson",
    "text": "Summary of Today’s Lesson\nIn today’s class, we covered:\n\n\nFactor Variables: Essential for categorical data in biology (genotypes, treatments, etc.)\n\n\nCreation, levels, ordering, and visualization\n\n\n\nSubsetting Techniques: Critical for data extraction and analysis\n\n\nVector and data frame subsetting with various methods\nUsing row names effectively for biological identifiers\n\n\n\nMatrix Operations: Fundamental for expression data\n\n\nCreation, manipulation, and biological applications\nCalculating fold changes and other common operations\n\n\n\nMissing Values: Practical approaches for real-world biological data\n\n\nIdentification and appropriate replacement methods\n\n\n\nData Transformation: Making data suitable for statistical analysis\n\n\nLog, square root, and z-score transformations\nOutlier identification and handling\n\n\n\nLogical Operations: For data filtering and decision making\n\n\nConditions, combinations, and applications\n\nThese skills form the foundation for the more advanced visualization techniques we’ll cover in future lessons.\n\nWe will know more about conditionals, R packages to handle data and visualization in a better and efficient way.\nList: Fundamental for many biological data and packages’ output.\n\n\nProperties, accessing, and applications"
  },
  {
    "objectID": "ch/rbasics/firststeps.html#homework",
    "href": "ch/rbasics/firststeps.html#homework",
    "title": "Basic R",
    "section": "Homework",
    "text": "Homework\n\n\nMatrix Operations:\n\n\nCreate a gene expression matrix with 8 genes and 4 conditions\nCalculate the mean expression for each gene\nCalculate fold change between condition 4 and condition 1\nCreate a heatmap of your matrix\n\n\n\nFactor Analysis:\n\n\nUsing the iris dataset, convert Species to an ordered factor\nCreate boxplots showing Sepal.Length by Species\nCalculate mean petal length for each species level\n\n\n\nData Cleaning Challenge:\n\n\nIn the downloaded msleep_data.csv:\nIdentify all columns with missing values\nReplace missing values appropriately\nCreate a new categorical variable “sleep_duration” with levels “Short”, “Medium”, “Long”\n\n\n\nList challenge:\n\n\nMake your own lists\nReplicate all the tasks we did\nYou may ask AI to give you beginner-level questions but don’t ask to solve the questions programmatically. Tell AI not to provide answers.\n\n\n\nComplete Documentation:\n\n\nWrite all code in R Markdown\nInclude comments explaining your approach\nPush to GitHub\n\nDue date: Friday 10pm BD Time"
  },
  {
    "objectID": "ch/rbasics/firststeps.html#variables",
    "href": "ch/rbasics/firststeps.html#variables",
    "title": "Basic R",
    "section": "",
    "text": "Variables are variable. We have freedom to name them as we wish. But make any variable name meaningful and identifiable.\n\na &lt;- 5 #assign value 5 to a \nb = 10\na\n\n[1] 5\n\nb\n\n[1] 10\n\na &lt;- a + 10\nb = b + 15\na\n\n[1] 15\n\na^2 #a squared\n\n[1] 225\n\na**2 #a squared again, in a different way.\n\n[1] 225\n\na^3 #a qubed\n\n[1] 3375\n\n\n\n\n\n\n\n\nNote\n\n\n\n&lt;- and = are used to assign values. It is not mathematical equality. b &lt;- b + 15 might make better sense than b = b + 15.\n\n\n\nDo some more practice.\n\n7/3\n\n[1] 2.333333\n\n7%/%3\n\n[1] 2\n\n7%%3\n\n[1] 1"
  },
  {
    "objectID": "ch/rbasics/firststeps.html#factor-variables",
    "href": "ch/rbasics/firststeps.html#factor-variables",
    "title": "Basic R",
    "section": "Factor Variables",
    "text": "Factor Variables\nImportant for categorical data\nCreating Factors\nFactors are used to represent categorical data in R. They are particularly important for biological data like genotypes, phenotypes, and experimental conditions.\n\n# Simple factor: DNA sample origins\norigins &lt;- c(\"Human\", \"Mouse\", \"Human\", \"Zebrafish\", \"Mouse\", \"Human\")\norigins_factor &lt;- factor(origins, levels = c(\"Human\", \"Zebrafish\", \"Mouse\"))\norigins_factor\n\n[1] Human     Mouse     Human     Zebrafish Mouse     Human    \nLevels: Human Zebrafish Mouse\n\n# Check levels (categories)\nlevels(origins_factor)\n\n[1] \"Human\"     \"Zebrafish\" \"Mouse\"    \n\n# Create a factor with predefined levels\ntreatment_groups &lt;- factor(c(\"Control\", \"Low_dose\", \"High_dose\", \"Control\", \"Low_dose\"),\n                         levels = c(\"Control\", \"Low_dose\", \"High_dose\"))\ntreatment_groups\n\n[1] Control   Low_dose  High_dose Control   Low_dose \nLevels: Control Low_dose High_dose\n\n# Ordered factors (important for severity, stages, etc.)\ndisease_severity &lt;- factor(c(\"Mild\", \"Severe\", \"Moderate\", \"Mild\", \"Critical\"),\n                         levels = c(\"Mild\", \"Moderate\", \"Severe\", \"Critical\"),\n                         ordered = TRUE)\ndisease_severity\n\n[1] Mild     Severe   Moderate Mild     Critical\nLevels: Mild &lt; Moderate &lt; Severe &lt; Critical\n\n# Compare with ordered factors\ndisease_severity[1] &gt; disease_severity[2]  # Is Mild less severe than Severe?\n\n[1] FALSE\n\n\nFactor Operations\n\n# Count frequencies\nout &lt;- table(origins_factor)\nout\n\norigins_factor\n    Human Zebrafish     Mouse \n        3         1         2 \n\nout[\"Human\"]\n\nHuman \n    3 \n\n# Calculate proportions\nprop.table(out)\n\norigins_factor\n    Human Zebrafish     Mouse \n0.5000000 0.1666667 0.3333333 \n\n# Change reference level (important for statistical models)\norigins_factor_relevel &lt;- relevel(origins_factor, ref = \"Mouse\")\norigins_factor_relevel\n\n[1] Human     Mouse     Human     Zebrafish Mouse     Human    \nLevels: Mouse Human Zebrafish\n\n# Convert to character\norigins_char &lt;- as.character(origins_factor)\n\n# Plot factors - Basic barplot\nbarplot(table(origins_factor), \n        col = c(\"blue\", \"green\", \"red\"),\n        main = \"Sample Origins\",\n        ylab = \"Count\")\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nFactor level-ing and relevel-ing are different. relevel redefines what the reference should be. For example, in an experiment, you have control, treatment1, treatment2 groups. Your reference might be control. So, all of your comparisons/statistics are on the basis of control. But you might change the reference (by relevel to treatment1 and all of your comparison will be on the basis of treatment1 group. Got it?\n\n\nMore advanced plot with factors:\n\ngene_expr &lt;- c(5.2, 7.8, 4.5, 12.3, 8.1, 3.7)\nnames(gene_expr) &lt;- as.character(origins)\n\n# Boxplot by factor\nboxplot(gene_expr ~ origins, \n        col = \"lightblue\",\n        main = \"Gene Expression by Sample Origin\", \n        xlab = \"Origin\", \n        ylab = \"Expression Level\")\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nDid you notice how factor level-ing changes the appearance of the categories in the plots? See the barplot and the boxplot again. Where are Zebrafish and Mouse now in the plots? Why are their positions on the x-axis changed?\n\n\n\n\n\n\n\n\nNote\n\n\n\nKeep noticing the output formats. Sometimes the output is just a number, sometimes a vector or table or list, etc. Check prop.table(table(origins_factor)). How is it?\n\n\n\n\n\n\n\n\nGot it?\n\n\n\n\n\nprop &lt;- prop.table(table(origins_factor)) – is a named numeric vector (atomic vector). prop$Human or similar won’t work. Check this way: prop prop[\"Human\"]; prop[\"Mouse\"]; prop[\"Zebrafish\"]\nOr make it a data frame (df) first, then try to use normal way of handling df.\n\n\n\nAccessing the Output:\n\nprop &lt;- prop.table(table(origins_factor))\nprop #What do you see? A data frame? No difference?\n\norigins_factor\n    Human Zebrafish     Mouse \n0.5000000 0.1666667 0.3333333 \n\nprop[\"Human\"]; prop[\"Mouse\"]; prop[\"Zebrafish\"]\n\nHuman \n  0.5 \n\n\n    Mouse \n0.3333333 \n\n\nZebrafish \n0.1666667"
  },
  {
    "objectID": "ch/rbasics/firststeps.html#homeworks-1",
    "href": "ch/rbasics/firststeps.html#homeworks-1",
    "title": "Basic R",
    "section": "📘 Homeworks",
    "text": "📘 Homeworks\n🧪 Matrix Operation Assignment: Protein Concentration\nYou are given the following protein concentration matrix:\n[ =\n\\[\\begin{bmatrix}\n  5 & 3 & 2 \\\\\n  7 & 6 & 4 \\\\\n\\end{bmatrix}\\]\n]\n\nRows represent samples:\n\nSample1\nSample2\n\n\nColumns represent proteins:\n\nProteinX\nProteinY\nProteinZ\n\n\n\nYou are also given a weight (importance) matrix for the proteins:\n[ =\n\\[\\begin{bmatrix}\n  0.5 \\\\\n  1.0 \\\\\n  1.5 \\\\\n\\end{bmatrix}\\]\n]\n🔧 Tasks\n\n\nMake the matrices (with exact names) and multiply the ProteinMatrix by the WeightVector.\nThat is:\n[ ]\n\nTranspose the ProteinMatrix and show what it looks like.\nCreate the Identity matrix of compatible size and show what happens when you multiply: [ I ]\nDo the calculations (rowSums, colSums, etc.) and visualization (barplot, heatmap) as shown in the class.\n\n🧠 Interpretation Questions\n\nWhat does multiplying the protein levels by the weight vector mean biologically?\nWhat does the result tell you about total protein burden (or total protein impact) for each sample?\nWhat do the identity matrix represent in the context of protein interactions or measurement biases?\nIf you changed the weight of ProteinZ to 3.0, how would the result change?\n\n🧬 Gene-to-Protein Translation\nYou are given the following matrix representing normalized gene expression levels (e.g., TPM):\n[ =\n\\[\\begin{bmatrix}\n  10 &  8 &  5 \\\\\n  15 & 12 & 10 \\\\\n\\end{bmatrix}\\]\n]\n\nRows = Samples:\n\nSample1\n\nSample2\n\n\nColumns = Genes:\n\nGeneA\n\nGeneB\n\nGeneC\n\n\n\nEach gene translates into proteins with a certain efficiency. The efficiency of translation from each gene to its corresponding protein is given by the following diagonal matrix:\n[ =\n\\[\\begin{bmatrix}\n  1.5 & 0   & 0 \\\\\n  0   & 1.2 & 0 \\\\\n  0   & 0   & 1.8 \\\\\n\\end{bmatrix}\\]\n]\nThis means: - GeneA → ProteinA with 1.5× efficiency\n- GeneB → ProteinB with 1.2× efficiency\n- GeneC → ProteinC with 1.8× efficiency\n🔧 Tasks\n\n\nMake the matrices and multiply GeneExpression × TranslationMatrix to compute the resulting ProteinMatrix.\n\nShow the result step-by-step.\n\n\nTranspose the GeneExpression matrix. What does this new matrix represent?\nCreate the Identity matrix I₃ and multiply it with the TranslationMatrix. What happens?\n\nCreate a new matrix containing only the expression of GeneA and GeneB across both samples. Call this submatrix A.\n\nCompute the inverse A⁻¹ using solve() function.\nThen verify:\nA × A⁻¹ = I₂\n\n\n\n📊 Visualization Tasks\n\nPlot a MARplot-style scatter plot:\n\nx-axis: Gene expression values (GeneExpression matrix, flattened)\ny-axis: Corresponding Protein values (ProteinMatrix, flattened)\nLabel each point as “Sample-Gene”\n\n\nGenerate a heatmap of the ProteinMatrix using R’s heatmap() function.\n\nAdd meaningful row and column labels.\nEnable clustering by rows and columns.\n\n\n\n🧠 Interpretation Questions\n\nWhat does matrix multiplication represent biologically in this case?\nWhy does the diagonal TranslationMatrix make sense biologically?\nWhat does it mean if Sample2 has higher protein levels even with similar gene expression?\nHow does the MARplot help interpret translation efficiency?\nHow does clustering in the heatmap reveal relationships between samples and proteins?"
  },
  {
    "objectID": "ch/rbasics/firststeps.html#animal-breeding-economic-ranking-of-bulls-by-traits",
    "href": "ch/rbasics/firststeps.html#animal-breeding-economic-ranking-of-bulls-by-traits",
    "title": "Basic R",
    "section": "🐄 Animal Breeding – Economic Ranking of Bulls by Traits",
    "text": "🐄 Animal Breeding – Economic Ranking of Bulls by Traits\nYou are evaluating two bulls for use in a dairy breeding program. Their Estimated Breeding Values (EBVs) are:\n\\[\n\\text{BullEBVs} =\n\\begin{bmatrix}\n  400 & 1.2 & 0.8 \\\\\\\\\n  500 & 1.5 & 0.6 \\\\\\\\\n\\end{bmatrix}\n\\]\n\nRows:\n\nBull1\n\nBull2\n\n\nColumns:\n\nTrait1 = Milk yield (liters/year)\n\nTrait2 = Growth rate (kg/day)\n\nTrait3 = Fertility (calving interval adjustment)\n\n\n\nYou assign economic weights to each trait:\n\\[\n\\text{EconomicWeights} =\n\\begin{bmatrix}\n  0.002 \\\\\\\\\n  50 \\\\\\\\\n  100 \\\\\\\\\n\\end{bmatrix}\n\\]\n\n🔧 Tasks\n\n\nCompute:\n\\[\n\\text{TotalValue} = \\text{BullEBVs} \\times \\text{EconomicWeights}\n\\]\n\nWhat are the resulting values?\nWhich bull is more valuable economically?\n\n\nInterpret what multiplying by the economic weights means biologically.\n\nCreate the 3×3 identity matrix I₃ and multiply it with BullEBVs.\n\nWhat does it return?\nWhat does the identity matrix mean in this case?\n\n\n\nSubset the BullEBVs matrix to remove Trait1 (milk yield) and recalculate TotalValue.\n\nHow does this change the ranking?\n\n\n\n📊 Visualization Tasks\n\nCreate a bar plot comparing TotalValue for Bull1 and Bull2.\n\nCreate a heatmap of the EBVs.\n\nLabel rows and columns.\nEnable clustering.\n\n\n\n🧠 Interpretation Questions\n\nHow do economic weights affect trait importance?\nWhy might you ignore milk yield in some breeding programs?\nWhat is the value of heatmaps in visualizing multivariate trait data?\nCan this method be extended to more bulls and more traits?"
  },
  {
    "objectID": "ch/rbasics/firststeps.html#plant-breeding-trait-contributions-from-parental-lines",
    "href": "ch/rbasics/firststeps.html#plant-breeding-trait-contributions-from-parental-lines",
    "title": "Basic R",
    "section": "🌾 Plant Breeding – Trait Contributions from Parental Lines",
    "text": "🌾 Plant Breeding – Trait Contributions from Parental Lines\nYou are breeding a new rice variety from three parental lines. The key traits are:\n\nT1 = Drought resistance\n\nT2 = Yield\n\nT3 = Maturation time\n\nThe following trait values (normalized 1–10) have been measured:\n\\[\n\\text{ParentTraits} =\n\\begin{bmatrix}\n  7 & 5 & 3 \\\\\\\\\n  6 & 8 & 4 \\\\\\\\\n  5 & 6 & 6 \\\\\\\\\n\\end{bmatrix}\n\\]\n\nRows:\n\nP1 (Parent 1)\n\nP2 (Parent 2)\n\nP3 (Parent 3)\n\n\nColumns:\n\nT1 = Drought resistance\n\nT2 = Yield\n\nT3 = Maturation time\n\n\n\nYou design a hybrid with contributions from each parent as follows:\n\\[\n\\text{HybridWeights} =\n\\begin{bmatrix}\n  0.5 \\\\\\\\\n  0.3 \\\\\\\\\n  0.2 \\\\\\\\\n\\end{bmatrix}\n\\]\n\n🔧 Tasks\n\n\nCompute the HybridTrait vector by:\n\\[\n\\text{HybridTraits} = \\text{HybridWeights}^T \\times \\text{ParentTraits}\n\\]\nShow the steps and result.\n\nExplain what it means biologically when one parent contributes more to a particular trait.\n\nCreate an identity matrix I₃ and multiply it with ParentTraits.\n\nWhat do you observe?\nWhat does I × ParentTraits represent?\n\n\n\nSubset the ParentTraits matrix to include only T1 and T2. Recalculate the hybrid traits.\n\nDiscuss how removing a trait affects your outcome.\n\n\n\n📊 Visualization Tasks\n\nGenerate a heatmap of the ParentTraits matrix.\n\nLabel the rows with parent names and columns with trait names.\nEnable row/column clustering.\n\n\nCreate a bar plot showing the HybridTraits (T1, T2, T3).\n\nColor code each bar by trait.\nWhat trait contributes most?\n\n\n\n🧠 Interpretation Questions\n\nHow does the weighting of parents affect the hybrid’s performance?\nWhat does the identity matrix represent here?\nIf you used equal weights (⅓ for each), how would the hybrid traits change?\nWhat real-world limitations does this simplified model ignore?\n🧠 Managing Matrices and Weight Vectors Using Lists in R\nNow that you have completed four biological matrix problems — Protein concentration, gene-to-protein mapping, bull breeding value ranking, and plant trait combinations — it’s time to organize your data and weights using R’s list structure.\nIn this task, you will:\n\nGroup each example’s matrix and its corresponding weight vector inside a named list.\nCombine these named lists into a larger list called bioList.\nUse list indexing to repeat your earlier calculations and visualizations.\nReflect on the benefits and challenges of using structured data objects.\n\n📦 Step 1: Create a master list\nYou should now build a named list called bioList containing the following four elements:\n\nProteinConc = list(matrix = ProteinMatrix, weights = WeightVector)\nProteinMap = list(matrix = ProteinMapping, weights = TranslationWeights)\nPlant = list(matrix = ParentTraits, weights = HybridWeights)\nAnimal = list(matrix = BullEBVs, weights = EconomicWeights)\n\nHint: Each inner list should contain both:\n- matrix = the main data matrix\n- weights = the vector used for multiplication\nNo R code is required here (You have from previous part) — just structure your data like this in your workspace.\n🔧 Tasks\n\nList the full names of each component in bioList.\nWhat are the names of the top-level and nested components?\n\nAccess each matrix and its corresponding weights using list indexing.\n\nHow would you extract only the matrix of the Plant entry?\nHow would you extract the weights for the RNAseq entry?\n\n\n\nUse the correct matrix and weights to perform:\n\nRNAseq: Weighted gene expression score\nProteinMap: Contribution of transcripts to each protein\nPlant: Hybrid trait values\nAnimal: Bull total economic value\n\n\n\nSubset one matrix in each sublist (e.g., drop a trait or feature) and repeat the weighted calculation.\n\nWhat changes in the results?\nWhich traits/genes have the strongest influence?\n\n\n\n📊 Visualization Tasks\n\nGenerate one heatmap for any matrix stored in bioList.\n\nChoose one (e.g., ProteinMap or Plant)\nApply clustering to rows and/or columns\nLabel appropriately\n\n\nGenerate two bar plots:\n\nOne showing the result of weighted trait aggregation for the Plant hybrid\nOne showing the total breeding values for each bull\n\n\n\n🧠 Interpretation Questions\n\nHow does structuring your data using a list help with clarity and reproducibility?\nWhat risks or challenges might occur when accessing elements from nested lists?\nCould this structure be scaled for real datasets with many samples or traits?\nHow would you loop over all elements in bioList to apply the same function?\nHow can this list structure be useful for building automated bioinformatics pipelines?\n\n📝 Your Rmarkdown file(s) should include:\n- All matrix calculations (tasks). Also, name the rows and columns of each matrix accordingly.\n- All interpretation answers\n- All plots (screenshots or embedded code)\n- And your commentary blocks for each code chunk."
  },
  {
    "objectID": "ch/rbasics/firststeps.html#managing-matrices-and-weight-vectors-using-lists-in-r",
    "href": "ch/rbasics/firststeps.html#managing-matrices-and-weight-vectors-using-lists-in-r",
    "title": "Basic R",
    "section": "🧠 Managing Matrices and Weight Vectors Using Lists in R",
    "text": "🧠 Managing Matrices and Weight Vectors Using Lists in R\nNow that you have completed four biological matrix problems — Protein concentration, gene-to-protein mapping, bull breeding value ranking, and plant trait combinations — it’s time to organize your data and weights using R’s list structure.\nIn this task, you will:\n\nGroup each example’s matrix and its corresponding weight vector inside a named list.\nCombine these named lists into a larger list called bioList.\nUse list indexing to repeat your earlier calculations and visualizations.\nReflect on the benefits and challenges of using structured data objects.\n\n\n📦 Step 1: Create a master list\nYou should now build a named list called bioList containing the following four elements:\n\nRNAseq = list(matrix = RNAseqCounts, weights = GeneWeights)\nProteinMap = list(matrix = ProteinMapping, weights = TranslationWeights)\nPlant = list(matrix = ParentTraits, weights = HybridWeights)\nAnimal = list(matrix = BullEBVs, weights = EconomicWeights)\n\nHint: Each inner list should contain both: - matrix = the main data matrix - weights = the vector used for multiplication\nNo R code is required here — just structure your data like this in your workspace.\n🔧 Tasks\n\nList the full names of each component in bioList.\nWhat are the names of the top-level and nested components?\n\nAccess each matrix and its corresponding weights using list indexing.\n\nHow would you extract only the matrix of the Plant entry?\nHow would you extract the weights for the RNAseq entry?\n\n\n\nUse the correct matrix and weights to perform:\n\nRNAseq: Weighted gene expression score\nProteinMap: Contribution of transcripts to each protein\nPlant: Hybrid trait values\nAnimal: Bull total economic value\n\n\n\nSubset one matrix in each sublist (e.g., drop a trait or feature) and repeat the weighted calculation.\n\nWhat changes in the results?\nWhich traits/genes have the strongest influence?\n\n\n\n📊 Visualization Tasks\n\nGenerate one heatmap for any matrix stored in bioList.\n\nChoose one (e.g., ProteinMap or Plant)\nApply clustering to rows and/or columns\nLabel appropriately\n\n\nGenerate two bar plots:\n\nOne showing the result of weighted trait aggregation for the Plant hybrid\nOne showing the total breeding values for each bull\n\n\n\n🧠 Interpretation Questions\n\nHow does structuring your data using a list help with clarity and reproducibility?\nWhat risks or challenges might occur when accessing elements from nested lists?\nCould this structure be scaled for real datasets with many samples or traits?\nHow would you loop over all elements in bioList to apply the same function?\nHow can this list structure be useful for building automated bioinformatics pipelines?\n\n📝 Your Rmarkdown file(s) should include: - All matrix calculations (tasks) - All interpretation answers - All plots (screenshots or embedded code) - And your commentary blocks for each code chunk."
  },
  {
    "objectID": "ch/rbasics/firststeps.html#homeworks-matrix-operation-and-list",
    "href": "ch/rbasics/firststeps.html#homeworks-matrix-operation-and-list",
    "title": "Basic R",
    "section": "📘 Homeworks: Matrix Operation and List",
    "text": "📘 Homeworks: Matrix Operation and List\n🧪 Protein Concentration\nYou are given the following protein concentration matrix:\n[ =\n\\[\\begin{bmatrix}\n  5 & 3 & 2 \\\\\n  7 & 6 & 4 \\\\\n\\end{bmatrix}\\]\n]\n\nRows represent samples:\n\nSample1\nSample2\n\n\nColumns represent proteins:\n\nProteinX\nProteinY\nProteinZ\n\n\n\nYou are also given a weight (importance) matrix for the proteins:\n[ =\n\\[\\begin{bmatrix}\n  0.5 \\\\\n  1.0 \\\\\n  1.5 \\\\\n\\end{bmatrix}\\]\n]\n🔧 Tasks\n\n\nMake the matrices (with exact names) and multiply the ProteinMatrix by the WeightVector.\nThat is:\n[ ]\n\nTranspose the ProteinMatrix and show what it looks like.\nCreate the Identity matrix of compatible size and show what happens when you multiply: [ I ]\nDo the calculations (rowSums, colSums, etc.) and visualization (barplot, heatmap) as shown in the class.\n\n🧠 Interpretation Questions\n\nWhat does multiplying the protein levels by the weight vector mean biologically?\nWhat does the result tell you about total protein burden (or total protein impact) for each sample?\nWhat do the identity matrix represent in the context of protein interactions or measurement biases?\nIf you changed the weight of ProteinZ to 3.0, how would the result change?\n\n🧬 Gene-to-Protein Translation\nYou are given the following matrix representing normalized gene expression levels (e.g., TPM):\n[ =\n\\[\\begin{bmatrix}\n  10 &  8 &  5 \\\\\n  15 & 12 & 10 \\\\\n\\end{bmatrix}\\]\n]\n\nRows = Samples:\n\nSample1\n\nSample2\n\n\nColumns = Genes:\n\nGeneA\n\nGeneB\n\nGeneC\n\n\n\nEach gene translates into proteins with a certain efficiency. The efficiency of translation from each gene to its corresponding protein is given by the following diagonal matrix:\n[ =\n\\[\\begin{bmatrix}\n  1.5 & 0   & 0 \\\\\n  0   & 1.2 & 0 \\\\\n  0   & 0   & 1.8 \\\\\n\\end{bmatrix}\\]\n]\nThis means: - GeneA → ProteinA with 1.5× efficiency\n- GeneB → ProteinB with 1.2× efficiency\n- GeneC → ProteinC with 1.8× efficiency\n🔧 Tasks\n\n\nMake the matrices and multiply GeneExpression × TranslationMatrix to compute the resulting ProteinMatrix.\n\nShow the result step-by-step.\n\n\nTranspose the GeneExpression matrix. What does this new matrix represent?\nCreate the Identity matrix I₃ and multiply it with the TranslationMatrix. What happens?\n\nCreate a new matrix containing only the expression of GeneA and GeneB across both samples. Call this submatrix A.\n\nCompute the inverse A⁻¹ using solve() function.\nThen verify:\nA × A⁻¹ = I₂\n\n\n\n📊 Visualization Tasks\n\nPlot a MARplot-style scatter plot:\n\nx-axis: Gene expression values (GeneExpression matrix, flattened)\ny-axis: Corresponding Protein values (ProteinMatrix, flattened)\nLabel each point as “Sample-Gene”\n\n\nGenerate a heatmap of the ProteinMatrix using R’s heatmap() function.\n\nAdd meaningful row and column labels.\nEnable clustering by rows and columns.\n\n\n\n🧠 Interpretation Questions\n\nWhat does matrix multiplication represent biologically in this case?\nWhy does the diagonal TranslationMatrix make sense biologically?\nWhat does it mean if Sample2 has higher protein levels even with similar gene expression?\nHow does the MARplot help interpret translation efficiency?\nHow does clustering in the heatmap reveal relationships between samples and proteins?"
  },
  {
    "objectID": "ch/rbasics/firststeps.html#homeworks-matrix-and-list-operations",
    "href": "ch/rbasics/firststeps.html#homeworks-matrix-and-list-operations",
    "title": "Basic R",
    "section": "📘 Homeworks: Matrix and List Operations",
    "text": "📘 Homeworks: Matrix and List Operations\n🧪 Protein Quantification in Biological Samples\nYou are given the following protein concentration matrix:\n\\[\n\\text{ProteinMatrix} =\n\\begin{bmatrix}\n  5 & 3 & 2 \\\\\n  7 & 6 & 4 \\\\\n\\end{bmatrix}\n\\]\n\nRows represent samples:\n\nSample1\nSample2\n\n\nColumns represent proteins:\n\nProteinX\nProteinY\nProteinZ\n\n\n\nYou are also given a weight (importance) matrix for the proteins:\n\\[\n\\text{WeightVector} =\n\\begin{bmatrix}\n  0.5 \\\\\n  1.0 \\\\\n  1.5 \\\\\n\\end{bmatrix}\n\\]\n🔧 Tasks\n\nMake the matrices (with exact names) and multiply the ProteinMatrix by the WeightVector.\n\nThat is:\n\\[\n  \\text{ProteinMatrix} \\times \\text{WeightVector}\n  \\]\n\nTranspose the ProteinMatrix and show what it looks like.\nCreate the Identity matrix of compatible size and show what happens when you multiply: \\[\n\\text{ProteinMatrix} \\times I\n\\]\n\n4.Do the calculations (rowSums, colSums, etc.) and visualization (barplot, heatmap) as shown in the class.\n🧠 Interpretation Questions\n\nWhat does multiplying the protein levels by the weight vector mean biologically?\nWhat does the result tell you about total protein burden (or total protein impact) for each sample?\nWhat do the identity matrix represent in the context of protein interactions or measurement biases?\nIf you changed the weight of ProteinZ to 3.0, how would the result change?\n🧬 Gene-to-Protein Translation\nYou are given the following matrix representing normalized gene expression levels (e.g., TPM): \\[\n\\text{GeneExpression} =\n\\begin{bmatrix}\n  10 &  8 &  5 \\\\\n  15 & 12 & 10 \\\\\n\\end{bmatrix}\n\\]\n\nRows = Samples:\n\nSample1\nSample2\n\n\nColumns = Genes:\n\nGeneA\nGeneB\nGeneC\n\n\n\nEach gene translates into proteins with a certain efficiency. The efficiency of translation from each gene to its corresponding protein is given by the following diagonal matrix:\n\\[\n\\text{TranslationMatrix} =\n\\begin{bmatrix}\n  1.5 & 0   & 0 \\\\\n  0   & 1.2 & 0 \\\\\n  0   & 0   & 1.8 \\\\\n\\end{bmatrix}\n\\]\nThis means:\n\nGeneA → ProteinA with 1.5× efficiency\n\nGeneB → ProteinB with 1.2× efficiency\n\nGeneC → ProteinC with 1.8× efficiency\n🔧 Tasks\n\nMake the matrices and multiply GeneExpression × TranslationMatrix to compute the resulting ProteinMatrix.\n\n\nShow the result step-by-step.\n\n\nTranspose the GeneExpression matrix. What does this new matrix represent?\nCreate the Identity matrix I₃ and multiply it with the TranslationMatrix. What happens?\nCreate a new matrix containing only the expression of GeneA and GeneB across both samples. Call this submatrix A.\n\n\nCompute the inverse A⁻¹ using solve() function.\nThen verify:\nA × A⁻¹ = I₂\n📊 Visualization Tasks\n\nPlot a MARplot-style scatter plot:\n\n\nx-axis: Gene expression values (GeneExpression matrix, flattened)\ny-axis: Corresponding Protein values (ProteinMatrix, flattened)\nLabel each point as “Sample-Gene”\n\n\nGenerate a heatmap of the ProteinMatrix using R’s heatmap() function.\n\n\nAdd meaningful row and column labels.\nEnable clustering by rows and columns.\n🧠 Interpretation Questions\n\nWhat does matrix multiplication represent biologically in this case?\nWhy does the diagonal TranslationMatrix make sense biologically?\nWhat does it mean if Sample2 has higher protein levels even with similar gene expression?\nHow does the MARplot help interpret translation efficiency?\nHow does clustering in the heatmap reveal relationships between samples and proteins?\n🐄 Animal Breeding – Economic Ranking of Bulls by Traits\nYou are evaluating two bulls for use in a dairy breeding program. Their Estimated Breeding Values (EBVs) are:\n\\[\n\\text{BullEBVs} =\n\\begin{bmatrix}\n  400 & 1.2 & 0.8 \\\\\\\\\n  500 & 1.5 & 0.6 \\\\\\\\\n\\end{bmatrix}\n\\]\n\nRows:\n\nBull1\n\nBull2\n\n\nColumns:\n\nTrait1 = Milk yield (liters/year)\n\nTrait2 = Growth rate (kg/day)\n\nTrait3 = Fertility (calving interval adjustment)\n\n\n\nYou assign economic weights to each trait:\n\\[\n\\text{EconomicWeights} =\n\\begin{bmatrix}\n  0.002 \\\\\\\\\n  50 \\\\\\\\\n  100 \\\\\\\\\n\\end{bmatrix}\n\\]\n🔧 Tasks\n\nCompute:\n\n\\[\n  \\text{TotalValue} = \\text{BullEBVs} \\times \\text{EconomicWeights}\n  \\]\n\nWhat are the resulting values?\nWhich bull is more valuable economically?\n\n\nInterpret what multiplying by the economic weights means biologically.\nCreate the 3×3 identity matrix I₃ and multiply it with BullEBVs.\n\n\nWhat does it return?\nWhat does the identity matrix mean in this case?\n\n\nSubset the BullEBVs matrix to remove Trait1 (milk yield) and recalculate TotalValue.\n\n\nHow does this change the ranking?\n📊 Visualization Tasks\n\nCreate a bar plot comparing TotalValue for Bull1 and Bull2.\nCreate a heatmap of the EBVs.\n\n\nLabel rows and columns.\nEnable clustering.\n🧠 Interpretation Questions\n\nHow do economic weights affect trait importance?\nWhy might you ignore milk yield in some breeding programs?\nWhat is the value of heatmaps in visualizing multivariate trait data?\nCan this method be extended to more bulls and more traits?\n🌾 Plant Breeding – Trait Contributions from Parental Lines\nYou are breeding a new rice variety from three parental lines. The key traits are:\n\nT1 = Drought resistance\nT2 = Yield\nT3 = Maturation time\n\nThe following trait values (normalized 1–10) have been measured:\n\\[\n\\text{ParentTraits} =\n\\begin{bmatrix}\n  7 & 5 & 3 \\\\\\\\\n  6 & 8 & 4 \\\\\\\\\n  5 & 6 & 6 \\\\\\\\\n\\end{bmatrix}\n\\]\n\nRows:\n\nP1 (Parent 1)\nP2 (Parent 2)\nP3 (Parent 3)\n\n\nColumns:\n\nT1 = Drought resistance\nT2 = Yield\nT3 = Maturation time\n\n\n\nYou design a hybrid with contributions from each parent as follows:\n\\[\n\\text{HybridWeights} =\n\\begin{bmatrix}\n  0.5 \\\\\\\\\n  0.3 \\\\\\\\\n  0.2 \\\\\\\\\n\\end{bmatrix}\n\\]\n🔧 Tasks\n\nCompute the HybridTrait vector by:\n\n\\[\n  \\text{HybridTraits} = \\text{HybridWeights}^T \\times \\text{ParentTraits}\n  \\]\nShow the steps and result.\n\nExplain what it means biologically when one parent contributes more to a particular trait.\nCreate an identity matrix I₃ and multiply it with ParentTraits.\n\n\nWhat do you observe?\nWhat does I × ParentTraits represent?\n\n\nSubset the ParentTraits matrix to include only T1 and T2. Recalculate the hybrid traits.\n\n\nDiscuss how removing a trait affects your outcome.\n📊 Visualization Tasks\n\nGenerate a heatmap of the ParentTraits matrix.\n\n\nLabel the rows with parent names and columns with trait names.\nEnable row/column clustering.\n\n\nCreate a bar plot showing the HybridTraits (T1, T2, T3).\n\n\nColor code each bar by trait.\nWhat trait contributes most?\n🧠 Interpretation Questions\n\nHow does the weighting of parents affect the hybrid’s performance?\nWhat does the identity matrix represent here?\nIf you used equal weights (⅓ for each), how would the hybrid traits change?\nWhat real-world limitations does this simplified model ignore?\n🧠 Managing Matrices and Weight Vectors Using Lists in R\nNow that you have completed four biological matrix problems — Protein concentration, gene-to-protein mapping, bull breeding value ranking, and plant trait combinations — it’s time to organize your data and weights using R’s list structure.\nIn this task, you will:\n\nGroup each example’s matrix and its corresponding weight vector inside a named list.\nCombine these named lists into a larger list called bioList.\nUse list indexing to repeat your earlier calculations and visualizations.\nReflect on the benefits and challenges of using structured data objects.\n📦 Step 1: Create a master list\nYou should now build a named list called bioList containing the following four elements:\n\nProteinConc = list(matrix = ProteinMatrix, weights = WeightVector)\nProteinMap = list(matrix = ProteinMapping, weights = TranslationWeights)\nPlant = list(matrix = ParentTraits, weights = HybridWeights)\nAnimal = list(matrix = BullEBVs, weights = EconomicWeights)\n\nHint: Each inner list should contain both:\n\nmatrix = the main data matrix\nweights = the vector used for multiplication\n\nNo R code is required here (You have them from previous part, use inside same rmd/notebook file) — just structure your data like this in your workspace.\n🔧 Tasks\n\nList the full names of each component in bioList. What are the names of the top-level and nested components?\nAccess each matrix and its corresponding weights using list indexing.\n\n\nHow would you extract only the matrix of the Plant entry?\nHow would you extract the weights for the Protein concentration entry?\n\n\nUse the correct matrix and weights to perform:\n\n\nProteinConc: Weighted gene expression score\nProteinMap: Contribution of transcripts to each protein\nPlant: Hybrid trait values\nAnimal: Bull total economic value\n\n\nSubset one matrix in each sublist (e.g., drop a trait or feature) and repeat the weighted calculation.\n\n\nWhat changes in the results?\nWhich traits/genes have the strongest influence?\n📊 Visualization Tasks\n\nGenerate one heatmap for any matrix stored in bioList.\n\n\nChoose one (e.g., ProteinMap or Plant)\nApply clustering to rows and/or columns\nLabel appropriately\n\n\nGenerate two bar plots:\n\n\nOne showing the result of weighted trait aggregation for the Plant hybrid\nOne showing the total breeding values for each bull\n🧠 Interpretation Questions\n\nHow does structuring your data using a list help with clarity and reproducibility?\nWhat risks or challenges might occur when accessing elements from nested lists?\nCould this structure be scaled for real datasets with many samples or traits?\nHow would you loop over all elements in bioList to apply the same function?\nHow can this list structure be useful for building automated bioinformatics pipelines?\n\n📝 Your Rmarkdown file(s) should include:\n\nAll matrix calculations (tasks). Also, name the rows and columns of each matrix accordingly.\nAll interpretation answers\nAll plots (output from embedded code)\nAnd your commentary blocks for each code chunk\n\nknit your rmd (or Notebook) file as html/pdf file and push both the rmd (or Notebook) and html/pdf files"
  },
  {
    "objectID": "ch/rbasics/solutions.html",
    "href": "ch/rbasics/solutions.html",
    "title": "HW solutions",
    "section": "",
    "text": "We measured the concentration (in µg/µL) of three proteins (P1, P2, P3) in four samples (S1–S4):\n\n\n# Making Protein Matrix\nProteinMatrix &lt;- matrix(\n  c(5, 3, 2,\n    7, 6, 4),\n  nrow = 2, byrow = TRUE\n)\nrownames(ProteinMatrix) = c(\"Sample1\", \"Sample2\")\ncolnames(ProteinMatrix) = c(\"ProteinX\", \"ProteinY\", \"ProteinZ\")\nProteinMatrix\n\n        ProteinX ProteinY ProteinZ\nSample1        5        3        2\nSample2        7        6        4\n\n\nNow goes the weight matrix\n\n# Making weight matrix\nWeightVector &lt;- matrix(\n  c(0.5, 1.0, 1.5),\n  nrow=3, byrow = TRUE\n)\nrownames(WeightVector) = c(\"ProteinX\", \"ProteinY\", \"ProteinZ\")\ncolnames(WeightVector) = c(\"Weight\")\nWeightVector\n\n         Weight\nProteinX    0.5\nProteinY    1.0\nProteinZ    1.5\n\n\nNow, multiply them.\n\n# Multiplying Matrices\nTotalConc = ProteinMatrix %*% WeightVector\ncolnames(TotalConc) &lt;- \"Total_Protein_Conc\"\nprint(TotalConc)\n\n        Total_Protein_Conc\nSample1                8.5\nSample2               15.5\n\n\n\n\nProteinMatTranspose = t(ProteinMatrix)\nProteinMatTranspose\n\n         Sample1 Sample2\nProteinX       5       7\nProteinY       3       6\nProteinZ       2       4\n\n\n\n\nI &lt;- diag(3)\nIdentitycheck = ProteinMatrix %*% I\ncolnames(Identitycheck) &lt;- c(\"ProteinX\", \"ProteinY\", \"ProteinZ\")\nIdentitycheck\n\n        ProteinX ProteinY ProteinZ\nSample1        5        3        2\nSample2        7        6        4\n\n\n\n\nrowSums(ProteinMatrix)\n\nSample1 Sample2 \n     10      17 \n\n\n\n\ncolSums(ProteinMatrix)\n\nProteinX ProteinY ProteinZ \n      12        9        6 \n\n\n\n\nheatmap(ProteinMatrix, scale = \"none\", col = heat.colors(10))\n\n\n\n\n\n\nMultiplying the protein levels by the weight vector shows how much each protein contributes in a sample. The result shows total protein concentration per sample.\nThe result shows that sample S2 has the highest protein burden.\nThe identity matrix represents no protein interactions or measurement biases. It is a simple matrix calculation.\nNew calculation:\n\n\n# changing the weight of ProteinZ to 3.0\nnewweightvector = matrix(\n  c(0.5, 1.0, 3.0),\n  nrow=3, byrow = TRUE\n)\nrownames(WeightVector) = c(\"ProteinX\", \"ProteinY\", \"ProteinZ\")\ncolnames(WeightVector) = c(\"Weight\")\nnewTotalconc = ProteinMatrix %*% newweightvector\ncolnames(newTotalconc) &lt;- \"Total_Protein_Conc\"\nnewTotalconc\n\n        Total_Protein_Conc\nSample1               11.5\nSample2               21.5\n\n\nStill, S2 has more protein burden.\nBonus:\n\nHeatmap reveals PX is most abundant across all samples.\n\n\n\n# making  Gene Expression matrix\nGeneExpression &lt;- matrix(\n  c(10, 8, 5,\n    15, 12, 10),\n  nrow = 2, byrow = TRUE\n)\nrownames(GeneExpression) &lt;- c(\"Sample1\", \"Sample2\")\ncolnames(GeneExpression) &lt;- c(\"GeneA\", \"GeneB\", \"GeneC\")\nGeneExpression\n\n        GeneA GeneB GeneC\nSample1    10     8     5\nSample2    15    12    10\n\n\nTranslation efficiency:\n\n# making Translation Matrix\nTranslationMatrix &lt;- matrix(\n  c(1.5, 0 , 0,\n  0, 1.2, 0,\n  0, 0, 1.8),\nnrow = 3, byrow = TRUE\n)\n\nrownames(TranslationMatrix) &lt;- c(\"GeneA\", \"GeneB\", \"GeneC\")\ncolnames(TranslationMatrix) &lt;- c(\"protA\", \"protB\", \"protC\")\nTranslationMatrix\n\n      protA protB protC\nGeneA   1.5   0.0   0.0\nGeneB   0.0   1.2   0.0\nGeneC   0.0   0.0   1.8\n\n\n\n\n# computing Protein matrix\nProtein_matrix &lt;- GeneExpression %*% TranslationMatrix\ncolnames(Protein_matrix) &lt;- c(\"total_protA\", \"total_protB\", \"total_protC\")\nprint(Protein_matrix)\n\n        total_protA total_protB total_protC\nSample1        15.0         9.6           9\nSample2        22.5        14.4          18\n\n\n\n\n# Transpose of GeneExpression matrix\nGeneExpression_Transpose &lt;- t(GeneExpression)\nGeneExpression_Transpose\n\n      Sample1 Sample2\nGeneA      10      15\nGeneB       8      12\nGeneC       5      10\n\n\nThe new matrix represnts a matrix where the rows and columns of GeneExpression matrix have been interchanged.\n\n\n# Creating Identity matrix\nI &lt;- diag(3)\nI\n\n     [,1] [,2] [,3]\n[1,]    1    0    0\n[2,]    0    1    0\n[3,]    0    0    1\n\n\nNow, multiply:\n\nProduct_matrix = TranslationMatrix %*%  I \nProduct_matrix\n\n      [,1] [,2] [,3]\nGeneA  1.5  0.0  0.0\nGeneB  0.0  1.2  0.0\nGeneC  0.0  0.0  1.8\n\n\nThe product is identical to TranslationMatrix\n\n\n# making submatrix A\nA = matrix(\n  c(10, 8,\n    15, 12), nrow=2, byrow = TRUE\n)\nrownames(A) = c(\"sample1\", \"sample2\")\ncolnames(A) = c(\"GeneA\", \"GeneB\")\n\nA\n\n        GeneA GeneB\nsample1    10     8\nsample2    15    12\n\n# finding inverse of A\n#inv_A &lt;- solve(A)\n#inv_A\n\nThe inverse matrix could not be calculated since A is a singular matrix. So, A * A^-1 is also not possible.\n\n\n\nMARplot\n\n\n\n# generating MARplot-style scatter plot\nplot(GeneExpression, Protein_matrix, type=\"p\", main=\"Protein level vs. Gene Expression level\")\nlabels &lt;- \"Sample-Gene\"\ntext(GeneExpression, Protein_matrix, labels = labels, pos=3)\n\n\n\n# generating a heatmap\nheatmap(Protein_matrix, main= \"Heatmap of Protein Level\", Rowv = TRUE, Colv = TRUE, labRow= rownames(Protein_matrix), labCol= c(\"ProteinA\", \"ProteinB\", \"ProteinC\"), col=topo.colors(256) )\n\n\n\n\n\n\nHeatmap of Expression:\n\n\n\nheatmap(GeneExpression, col = terrain.colors(10), scale = \"column\")\n\n\n\n\n\n\nMatrix multiplication allows each gene in both samples to be multiplied to their respective translation efficiency. So, the product shows how successfully each gene is translated”)\nThe diagonal TranslationMatrix make sense biologically because they show translation efficiency of each gene and there is no other interaction between them. Although there could be interaction in real-world scenarios.\nIf Sample2 has higher protein levels even with similar gene expression, it means that more mRNAs are translated to proteins compared to Sample1”\nThe upward trend in MARplot may indicate an increase in translation efficacy and downward trend may indicate a decline in translation efficacy”\nClustering in the heatmap may suggest which samples are most similar to each other based on their prot.\n\n\n\n# Define Bull EBVs\nBullEBVs &lt;- matrix(c(\n  400, 1.2, 0.8,\n  500, 1.5, 0.6\n), nrow = 2, byrow = TRUE)\n\nrownames(BullEBVs) &lt;- c(\"Bull1\", \"Bull2\")\ncolnames(BullEBVs) &lt;- c(\"Milk_yield\", \"Growth_rate\", \"Fertility\")\nBullEBVs\n\n      Milk_yield Growth_rate Fertility\nBull1        400         1.2       0.8\nBull2        500         1.5       0.6\n\n# Define Economic Weights\nEconomicWeights &lt;- matrix(c(0.002, 50, 100), ncol = 1)\nrownames(EconomicWeights) &lt;- colnames(BullEBVs)\ncolnames(EconomicWeights) &lt;- c(\"Weight\")\nEconomicWeights\n\n            Weight\nMilk_yield   2e-03\nGrowth_rate  5e+01\nFertility    1e+02\n\n\n\n\nTotalValue &lt;- BullEBVs %*% EconomicWeights\ncolnames(TotalValue) &lt;- c(\"Merit\")\nTotalValue\n\n      Merit\nBull1 140.8\nBull2 136.0\n\n\nInterpretation\nBull1: (400 × 0.002) + (1.2 × 50) + (0.8 × 100) = 140.8\nBull2: (500 × 0.002) + (1.5 × 50) + (0.6 × 100) = 136.0\nBull1 is more valuable economically.\nBiological Interpretation\nEconomic weights convert genetic merit (EBVs, Estimated Breeding Values) into economic merit. Traits with higher financial importance have a larger impact, regardless of absolute EBV values.\n\n\nI3 &lt;- diag(3)\nrownames(I3) &lt;- colnames(BullEBVs)\ncolnames(I3) &lt;- colnames(BullEBVs)\nI3\n\n            Milk_yield Growth_rate Fertility\nMilk_yield           1           0         0\nGrowth_rate          0           1         0\nFertility            0           0         1\n\nBullEBVs_identity &lt;- BullEBVs %*% I3\nBullEBVs_identity\n\n      Milk_yield Growth_rate Fertility\nBull1        400         1.2       0.8\nBull2        500         1.5       0.6\n\n\nInterpretation\nMultiplying by identity matrix returns the original matrix. It confirms that EBV structure is preserved.\n\n\nBullEBVs_noMilk &lt;- BullEBVs[, -1]\nEconomicWeights_noMilk &lt;- EconomicWeights[2:3, , drop = FALSE]\n\nTotalValue_noMilk &lt;- BullEBVs_noMilk %*% EconomicWeights_noMilk\ncolnames(TotalValue_noMilk) &lt;- c(\"New_Merit\")\nTotalValue_noMilk\n\n      New_Merit\nBull1       140\nBull2       135\n\n\nInterpretation\nBull1: (1.2 × 50) + (0.8 × 100) = 140\nBull2: (1.5 × 50) + (0.6 × 100) = 135\nBull1 still ranks higher, but by a smaller margin.\n\n\nbarplot(\n  TotalValue,\n  beside = TRUE,\n  names.arg = rownames(BullEBVs),\n  col = c(\"skyblue\", \"orange\"),\n  main = \"Total Economic Value of Bulls\",\n  ylab = \"Total Value\"\n)\n\n\n\n\n\n\nheatmap(\n  BullEBVs,\n  Rowv = NA,\n  Colv = NA,\n  scale = \"none\",\n  col = heat.colors(256),\n  main = \"Heatmap of Bull EBVs\"\n)\n\n\n\n\n\n\nHow do economic weights affect trait importance?\n\nTraits with higher weights contribute more to the total economic value. This makes them more influential in ranking and selection.\n\nWhy might you ignore milk yield?\n\nMilk yield may be excluded in systems focusing on fertility, growth, or when it is no longer a limiting factor. Environmental or economic contexts may also shift trait priorities.\n\nWhat is the value of heatmaps?\n\nHeatmaps visually compare EBVs across bulls and traits.They help detect patterns, outliers, and clusters easily in multivariate data.\n\nCan this method be extended to more bulls and traits?\n\nYes. This method scales to any number of bulls or traits. Just ensure the EBVs matrix and economic weights are dimensionally compatible.\n\n\nParent trait values (normalized 1–10)\n\nParentTraits &lt;- matrix(c(\n  7, 5, 3,\n  6, 8, 4,\n  5, 6, 6\n), nrow = 3, byrow = TRUE)\n\nrownames(ParentTraits) &lt;- c(\"P1\", \"P2\", \"P3\")\ncolnames(ParentTraits) &lt;- c(\"Drought_resistance\", \"Yield\", \"Maturation_time\")\nParentTraits\n\n   Drought_resistance Yield Maturation_time\nP1                  7     5               3\nP2                  6     8               4\nP3                  5     6               6\n\n# Define Hybrid Weights\nHybridWeights &lt;- matrix(c(0.5, 0.3, 0.2), nrow = 1)\ncolnames(HybridWeights) &lt;- colnames(ParentTraits)\nrownames(HybridWeights) &lt;- c(\"Weight\")\nHybridWeights\n\n       Drought_resistance Yield Maturation_time\nWeight                0.5   0.3             0.2\n\n\n\n\nHybridTraits &lt;- HybridWeights %*% ParentTraits\nrownames(HybridTraits) &lt;- c(\"Contribution\")\ncolnames(HybridTraits) &lt;- rownames(ParentTraits)\nHybridTraits\n\n              P1  P2  P3\nContribution 6.3 6.1 3.9\n\n\nInterpretation\nHybridTraits = (0.5 × P1) + (0.3 × P2) + (0.2 × P3)\nDrought_resistance = (0.5 × 7) + (0.3 × 6) + (0.2 × 5) = 6.3\nYield = (0.5 × 5) + (0.3 × 8) + (0.2 × 6) = 6.1\nMaturation_time = (0.5 × 3) + (0.3 × 4) + (0.2 × 6) = 3.9\nThe hybrid is moderately strong in drought resistance and yield, and has a relatively shorter maturation time.\nBiological Meaning of Unequal Contribution\nWhen one parent contributes more to a trait, it suggests that the trait’s heritable strength comes disproportionately from that parent. Breeders can use this knowledge to amplify desirable traits using the best parent.\n\n\nI3 &lt;- diag(3)\nParentTraits_identity &lt;- ParentTraits %*% I3\ncolnames(ParentTraits_identity) &lt;- colnames(ParentTraits)\nParentTraits_identity\n\n   Drought_resistance Yield Maturation_time\nP1                  7     5               3\nP2                  6     8               4\nP3                  5     6               6\n\n\nInterpretation\nMultiplying by identity matrix returns the original matrix. This operation verifies structural consistency and dimensionality.\n\n\nParentTraits_T1T2 &lt;- ParentTraits[, 1:2]\nParentTraits_T1T2\n\n   Drought_resistance Yield\nP1                  7     5\nP2                  6     8\nP3                  5     6\n\nHybridTraits_T1T2 &lt;- HybridWeights %*% ParentTraits_T1T2\nHybridTraits_T1T2\n\n       Drought_resistance Yield\nWeight                6.3   6.1\n\n\nInterpretation\nDrought_resistance = (0.5 × 7) + (0.3 × 6) + (0.2 × 5) = 6.3\nYield = (0.5 × 5) + (0.3 × 8) + (0.2 × 6) = 6.1\nRemoving a trait (T3) changes the trait profile. Hybrid selection may now favor traits that remain.\n\n\nheatmap(\n  ParentTraits,\n  Rowv = NA,\n  Colv = NA,\n  scale = \"none\",\n  col = heat.colors(256),\n  main = \"Heatmap of Parent Traits\"\n)\n\n\n\n\n\n\nbarplot(\n  HybridTraits,\n  beside = TRUE,\n  names.arg = colnames(ParentTraits),\n  col = c(\"#66c2a5\", \"#fc8d62\", \"#8da0cb\"),\n  main = \"Hybrid Trait Profile\",\n  ylab = \"Trait Value\"\n)\n\n\n\n\n\n\n\nHow does the weighting of parents affect the hybrid’s performance?\nStronger weights mean more genetic contribution. Traits from highly weighted parents dominate the hybrid profile.\n\n\nWhat does the identity matrix represent here?\nIt represents a neutral transformation. It confirms data integrity when used in matrix multiplication.\n\n\nIf you used equal weights (⅓ for each), how would the hybrid traits change?\nTraits would reflect an even mix, potentially leading to balanced but less specialized performance.\n\n\nWhat real-world limitations does this simplified model ignore?\n\nNon-additive genetic effects (dominance, epistasis)\nEnvironmental interactions\nTrait heritability and correlations\nBreeding feasibility and cost\n\n\n\nNow that we’ve explored trait-based decisions using matrices, it’s time to organize our work using R’s list structure. Lists help bundle related objects like matrices and weight vectors, keeping the analysis modular and scalable.\n\n\n# Assuming previous matrices and weights are already defined:\n\n# Making a MasterList\nbioList = list(\n  ProteinConc = list(matrix = ProteinMatrix, weights = WeightVector),\n  ProteinMap  = list(matrix = GeneExpression, weights = TranslationMatrix),\n  Animal = list(matrix = BullEBVs, weights = EconomicWeights),\n  Plant = list(matrix = ParentTraits, weights = HybridWeights)\n)\n\nprint(bioList)\n\n$ProteinConc\n$ProteinConc$matrix\n        ProteinX ProteinY ProteinZ\nSample1        5        3        2\nSample2        7        6        4\n\n$ProteinConc$weights\n         Weight\nProteinX    0.5\nProteinY    1.0\nProteinZ    1.5\n\n\n$ProteinMap\n$ProteinMap$matrix\n        GeneA GeneB GeneC\nSample1    10     8     5\nSample2    15    12    10\n\n$ProteinMap$weights\n      protA protB protC\nGeneA   1.5   0.0   0.0\nGeneB   0.0   1.2   0.0\nGeneC   0.0   0.0   1.8\n\n\n$Animal\n$Animal$matrix\n      Milk_yield Growth_rate Fertility\nBull1        400         1.2       0.8\nBull2        500         1.5       0.6\n\n$Animal$weights\n            Weight\nMilk_yield   2e-03\nGrowth_rate  5e+01\nFertility    1e+02\n\n\n$Plant\n$Plant$matrix\n   Drought_resistance Yield Maturation_time\nP1                  7     5               3\nP2                  6     8               4\nP3                  5     6               6\n\n$Plant$weights\n       Drought_resistance Yield Maturation_time\nWeight                0.5   0.3             0.2\n\n\n\n\nnames(bioList)               # Top-level list names\n\n[1] \"ProteinConc\" \"ProteinMap\"  \"Animal\"      \"Plant\"      \n\nlengths(bioList)             # Number of components in each sublist\n\nProteinConc  ProteinMap      Animal       Plant \n          2           2           2           2 \n\n\nInterpretation\nEach top-level entry (e.g., ProteinConc, Plant) contains two components:\n\nA matrix (e.g., ProteinMatrix)\nA corresponding weight vector or matrix\n\n\n# Access the trait matrix for Plant\nbioList$Plant[[1]]\n\n   Drought_resistance Yield Maturation_time\nP1                  7     5               3\nP2                  6     8               4\nP3                  5     6               6\n\n#or\nbioList$Plant$matrix\n\n   Drought_resistance Yield Maturation_time\nP1                  7     5               3\nP2                  6     8               4\nP3                  5     6               6\n\n# Access the weight vector for ProteinConc\nbioList$ProteinConc[[2]]\n\n         Weight\nProteinX    0.5\nProteinY    1.0\nProteinZ    1.5\n\n#or\nbioList$ProteinConc$weights\n\n         Weight\nProteinX    0.5\nProteinY    1.0\nProteinZ    1.5\n\n\nInterpretation\nUse double brackets [[ ]] to extract unnamed list elements by position. But we named our list, so they are easily extractable using the $ notation.\n\n\n# Protein concentration score\nbioList$ProteinConc$matrix %*% bioList$ProteinConc$weights\n\n        Weight\nSample1    8.5\nSample2   15.5\n\n# Gene → Protein contribution\nbioList$ProteinMap$matrix %*% bioList$ProteinMap$weights\n\n        protA protB protC\nSample1  15.0   9.6     9\nSample2  22.5  14.4    18\n\n# Bull economic value\nbioList$Animal$matrix %*% bioList$Animal$weights\n\n      Weight\nBull1  140.8\nBull2  136.0\n\n# Hybrid trait value\nbioList$Plant$weights %*% bioList$Plant$matrix\n\n       Drought_resistance Yield Maturation_time\nWeight                6.3   6.1             3.9\n\n\n\n\n# Remove last trait from ParentTraits\nParentSubset &lt;- bioList$Plant$matrix[, 1:2]\nNewWeights &lt;- matrix(c(0.6, 0.4), nrow = 2)\n\n# Recalculated hybrid score\nSubsetHybridScore &lt;- ParentSubset %*% NewWeights\nSubsetHybridScore\n\n   [,1]\nP1  6.2\nP2  6.8\nP3  5.4\n\n\nInterpretation\nDropping a trait and reweighting highlights its influence in trait aggregation and selection.\n\n\n\nheatmap(\n  bioList$ProteinMap$matrix,\n  scale = \"none\",\n  col = heat.colors(256),\n  main = \"Gene Expression Heatmap\",\n  xlab = \"Proteins\",\n  ylab = \"Genes\"\n)\n\n\n\n\n\n\n\nbarplot(\n  bioList$Plant$weights %*% bioList$Plant$matrix,\n  beside = TRUE,\n  main = \"Hybrid Trait Contributions\",\n  col = \"#66c2a5\",\n  ylab = \"Score\"\n)\n\n\n\n\n\n\nbarplot(\n  bioList$Animal$matrix %*% bioList$Animal$weights,\n  beside = TRUE,\n  main = \"Bull EBVs (Economic Values)\",\n  col = \"#fc8d62\",\n  ylab = \"Score\"\n)\n\n\n\n\n\n\nWhy use a list structure?\n\nKeeps each dataset and its weights together. Facilitates automated workflows and reuse.\n\nWhat’s tricky about [[ ]] access?\n\nYou must remember the order ([[1]] = matrix, [[2]] = weights). No names means you can’t use $matrix, only positional access.\nLoop across all list entries\nWeighted scores for all entries lapply(bioList, function(x) x[[2]] %*% x[[1]])\n\nHow does this help in large-scale pipelines?\n\nYou can use this format with lapply(), purrr::map(), or in targets pipelines for reproducibility and modular processing.\n\n\nCharacter vs Factor\nA character vector simply holds string values, but a factor is a categorical variable with fixed levels, used especially in modeling.\nFor mutation_status, a factor ensures consistent categories (e.g., \"Yes\" or \"No\") and helps control level order and statistical reference groups.\nFactor Levels\n\n\nspecies &lt;- c(\"Lactobacillus\", \"Bacteroides\", \"Escherichia\", \"Bacteroides\", \"Lactobacillus\")\nspecies_factor &lt;- factor(species, levels = c(\"Bacteroides\", \"Escherichia\", \"Lactobacillus\"))\nlevels(species_factor)\n\n[1] \"Bacteroides\"   \"Escherichia\"   \"Lactobacillus\"\n\n\nBecause we defined the level order explicitly, R maintains that order regardless of data input.\n\nOrdered Factor Comparison\n\n\ndisease_severity &lt;- factor(c(\"Mild\", \"Severe\", \"Moderate\"), levels = c(\"Mild\", \"Moderate\", \"Severe\", \"Critical\"), ordered = TRUE)\ndisease_severity[1] &lt; disease_severity[2]\n\n[1] TRUE\n\n# TRUE\n\n“Mild” is less severe than “Severe” based on the defined order.\n\nProportion Extraction\n\n\nprop &lt;- prop.table(table(species_factor))\nprop[\"Escherichia\"]\n\nEscherichia \n        0.2 \n\n\nprop$Escherichia won’t work — named numeric vectors require bracket-based access.\n\nSubsetting by Conditions\n\n\ngene_df &lt;- data.frame(\n  gene_id = c(\"BRCA1\", \"TP53\", \"MYC\", \"EGFR\", \"GAPDH\"),\n  expression = c(8.2, 6.1, 9.5, 7.0, 10.0),\n  mutation = factor(c(\"Yes\", \"No\", \"Yes\", \"No\", \"No\")),\n  pathway = c(\"DNA Repair\", \"Apoptosis\", \"Cell Cycle\", \"Signaling\", \"Metabolism\")\n)\nrownames(gene_df) &lt;- gene_df$gene_id #name the rows by the gene IDs\ngene_df &lt;- gene_df[, -1] #remove the first column which is not needed anymore\n#gene_df\ngene_df[gene_df$expression &gt; 7 & gene_df$mutation == \"No\", ]\n\n      expression mutation    pathway\nGAPDH         10       No Metabolism\n\n\nReturns genes with high expression (&gt;7) and no mutation — potentially highly active but wild-type genes.\n\nGroup-wise Expression Summary\n\nThe given vectors are:\n\nsamples &lt;- c(\"WT\", \"KO\", \"WT\", \"KO\", \"WT\")\nexpression &lt;- c(5.2, 8.1, 4.3, 9.0, 5.7)\n\nThe solution would be:\n\ngroup_factor &lt;- factor(samples)\n\n# Mean expression\ntapply(expression, group_factor, mean) ## KO: 8.55, WT: 5.07\n\n      KO       WT \n8.550000 5.066667 \n\n# Plot\nbarplot(tapply(expression, group_factor, mean), \n        col = c(\"skyblue\", \"salmon\"),\n        ylab = \"Mean Expression\",\n        main = \"Group-wise Expression\")\n\n\n\n\n\nGene Subsetting\n\n\ngene_df[gene_df$expression &gt; 8 & \n        gene_df$pathway %in% c(\"Cell Cycle\", \"Signaling\"), ]\n\n    expression mutation    pathway\nMYC        9.5      Yes Cell Cycle\n\n\nIt filters for genes highly expressed and involved in key biological pathways.\n\nDisease Stage Visualization\n\n\nstages &lt;- c(\"Stage I\", \"Stage III\", \"Stage II\", \"Stage IV\", \"Stage I\")\ndisease_stage &lt;- factor(stages, \n                        levels = c(\"Stage I\", \"Stage II\", \"Stage III\", \"Stage IV\"), \n                        ordered = TRUE)\n\nbarplot(table(disease_stage), \n        col = \"lightgreen\", \n        main = \"Patient Count by Disease Stage\",\n        ylab = \"Count\")\n\n\n\n\nLet’s do the severity order check:\n\n# Comparison\ndisease_stage[2] &gt; disease_stage[1]  # TRUE\n\n[1] TRUE\n\n\nSo, “Stage III” is more sever than “Stage I”.\n\nOncogene Subsetting and Releveling\n\n\n# Define a small gene dataset\ngene_data &lt;- data.frame(\n  gene = c(\"TP53\", \"BRCA1\", \"MYC\", \"GAPDH\", \"EGFR\"),\n  expression = c(9.1, 7.3, 10.5, 5.2, 8.6),\n  type = factor(c(\"Tumor Suppressor\", \"Oncogene\", \"Oncogene\", \"Housekeeping\", \"Oncogene\"))\n)\n\n# Subset: Oncogene rows with expression &gt; 8\ngene_data[gene_data$type == \"Oncogene\" & gene_data$expression &gt; 8, ]\n\n  gene expression     type\n3  MYC       10.5 Oncogene\n5 EGFR        8.6 Oncogene\n\n\nLet’s relevel now, “Housekeeping” is the reference:\n\n# Relevel: make \"Housekeeping\" the reference level\ngene_data$type &lt;- relevel(gene_data$type, ref = \"Housekeeping\")\n\n# Check the new levels\nlevels(gene_data$type)\n\n[1] \"Housekeeping\"     \"Oncogene\"         \"Tumor Suppressor\"\n\n\n\nSimulated Expression by Tissue\n\n\nset.seed(42)\ngene_expr &lt;- rnorm(45, mean = 8, sd = 2)\ntissue &lt;- rep(c(\"brain\", \"liver\", \"kidney\"), each = 15)\ntissue_factor &lt;- factor(tissue, levels = c(\"liver\", \"brain\", \"kidney\"))\n\nboxplot(gene_expr ~ tissue_factor, \n        col = c(\"orange\", \"skyblue\", \"lightgreen\"), \n        main = \"Expression by Tissue\",\n        ylab = \"Expression Level\")\n\n\n\n\nLet’s calculate variability per tissue type now:\n\n# Variability\ntapply(gene_expr, tissue_factor, sd)\n\n   liver    brain   kidney \n2.713940 2.050487 1.993668 \n\n# Returns standard deviation per tissue group"
  },
  {
    "objectID": "ch/rbasics/solutions.html#task-1-protein-concentration-in-samples",
    "href": "ch/rbasics/solutions.html#task-1-protein-concentration-in-samples",
    "title": "HW solutions",
    "section": "",
    "text": "We measured the concentration (in µg/µL) of three proteins (P1, P2, P3) in four samples (S1–S4):\n\n\n# Making Protein Matrix\nProteinMatrix &lt;- matrix(\n  c(5, 3, 2,\n    7, 6, 4),\n  nrow = 2, byrow = TRUE\n)\nrownames(ProteinMatrix) = c(\"Sample1\", \"Sample2\")\ncolnames(ProteinMatrix) = c(\"ProteinX\", \"ProteinY\", \"ProteinZ\")\nProteinMatrix\n\n        ProteinX ProteinY ProteinZ\nSample1        5        3        2\nSample2        7        6        4\n\n\nNow goes the weight matrix\n\n# Making weight matrix\nWeightVector &lt;- matrix(\n  c(0.5, 1.0, 1.5),\n  nrow=3, byrow = TRUE\n)\nrownames(WeightVector) = c(\"ProteinX\", \"ProteinY\", \"ProteinZ\")\ncolnames(WeightVector) = c(\"Weight\")\nWeightVector\n\n         Weight\nProteinX    0.5\nProteinY    1.0\nProteinZ    1.5\n\n\nNow, multiply them.\n\n# Multiplying Matrices\nTotalConc = ProteinMatrix %*% WeightVector\ncolnames(TotalConc) &lt;- \"Total_Protein_Conc\"\nprint(TotalConc)\n\n        Total_Protein_Conc\nSample1                8.5\nSample2               15.5\n\n\n\n\nProteinMatTranspose = t(ProteinMatrix)\nProteinMatTranspose\n\n         Sample1 Sample2\nProteinX       5       7\nProteinY       3       6\nProteinZ       2       4\n\n\n\n\nI &lt;- diag(3)\nIdentitycheck = ProteinMatrix %*% I\ncolnames(Identitycheck) &lt;- c(\"ProteinX\", \"ProteinY\", \"ProteinZ\")\nIdentitycheck\n\n        ProteinX ProteinY ProteinZ\nSample1        5        3        2\nSample2        7        6        4\n\n\n\n\nrowSums(ProteinMatrix)\n\nSample1 Sample2 \n     10      17 \n\n\n\n\ncolSums(ProteinMatrix)\n\nProteinX ProteinY ProteinZ \n      12        9        6 \n\n\n\n\nheatmap(ProteinMatrix, scale = \"none\", col = heat.colors(10))\n\n\n\n\n\n\nMultiplying the protein levels by the weight vector shows how much each protein contributes in a sample. The result shows total protein concentration per sample.\nThe result shows that sample S2 has the highest protein burden.\nThe identity matrix represents no protein interactions or measurement biases. It is a simple matrix calculation.\nNew calculation:\n\n\n# changing the weight of ProteinZ to 3.0\nnewweightvector = matrix(\n  c(0.5, 1.0, 3.0),\n  nrow=3, byrow = TRUE\n)\nrownames(WeightVector) = c(\"ProteinX\", \"ProteinY\", \"ProteinZ\")\ncolnames(WeightVector) = c(\"Weight\")\nnewTotalconc = ProteinMatrix %*% newweightvector\ncolnames(newTotalconc) &lt;- \"Total_Protein_Conc\"\nnewTotalconc\n\n        Total_Protein_Conc\nSample1               11.5\nSample2               21.5\n\n\nStill, S2 has more protein burden.\nBonus:\n\nHeatmap reveals PX is most abundant across all samples."
  },
  {
    "objectID": "ch/rbasics/solutions.html#task-2-gene-to-protein-translation",
    "href": "ch/rbasics/solutions.html#task-2-gene-to-protein-translation",
    "title": "HW solutions",
    "section": "",
    "text": "# making  Gene Expression matrix\nGeneExpression &lt;- matrix(\n  c(10, 8, 5,\n    15, 12, 10),\n  nrow = 2, byrow = TRUE\n)\nrownames(GeneExpression) &lt;- c(\"Sample1\", \"Sample2\")\ncolnames(GeneExpression) &lt;- c(\"GeneA\", \"GeneB\", \"GeneC\")\nGeneExpression\n\n        GeneA GeneB GeneC\nSample1    10     8     5\nSample2    15    12    10\n\n\nTranslation efficiency:\n\n# making Translation Matrix\nTranslationMatrix &lt;- matrix(\n  c(1.5, 0 , 0,\n  0, 1.2, 0,\n  0, 0, 1.8),\nnrow = 3, byrow = TRUE\n)\n\nrownames(TranslationMatrix) &lt;- c(\"GeneA\", \"GeneB\", \"GeneC\")\ncolnames(TranslationMatrix) &lt;- c(\"protA\", \"protB\", \"protC\")\nTranslationMatrix\n\n      protA protB protC\nGeneA   1.5   0.0   0.0\nGeneB   0.0   1.2   0.0\nGeneC   0.0   0.0   1.8\n\n\n\n\n# computing Protein matrix\nProtein_matrix &lt;- GeneExpression %*% TranslationMatrix\ncolnames(Protein_matrix) &lt;- c(\"total_protA\", \"total_protB\", \"total_protC\")\nprint(Protein_matrix)\n\n        total_protA total_protB total_protC\nSample1        15.0         9.6           9\nSample2        22.5        14.4          18\n\n\n\n\n# Transpose of GeneExpression matrix\nGeneExpression_Transpose &lt;- t(GeneExpression)\nGeneExpression_Transpose\n\n      Sample1 Sample2\nGeneA      10      15\nGeneB       8      12\nGeneC       5      10\n\n\nThe new matrix represnts a matrix where the rows and columns of GeneExpression matrix have been interchanged.\n\n\n# Creating Identity matrix\nI &lt;- diag(3)\nI\n\n     [,1] [,2] [,3]\n[1,]    1    0    0\n[2,]    0    1    0\n[3,]    0    0    1\n\n\nNow, multiply:\n\nProduct_matrix = TranslationMatrix %*%  I \nProduct_matrix\n\n      [,1] [,2] [,3]\nGeneA  1.5  0.0  0.0\nGeneB  0.0  1.2  0.0\nGeneC  0.0  0.0  1.8\n\n\nThe product is identical to TranslationMatrix\n\n\n# making submatrix A\nA = matrix(\n  c(10, 8,\n    15, 12), nrow=2, byrow = TRUE\n)\nrownames(A) = c(\"sample1\", \"sample2\")\ncolnames(A) = c(\"GeneA\", \"GeneB\")\n\nA\n\n        GeneA GeneB\nsample1    10     8\nsample2    15    12\n\n# finding inverse of A\n#inv_A &lt;- solve(A)\n#inv_A\n\nThe inverse matrix could not be calculated since A is a singular matrix. So, A * A^-1 is also not possible.\n\n\n\nMARplot\n\n\n\n# generating MARplot-style scatter plot\nplot(GeneExpression, Protein_matrix, type=\"p\", main=\"Protein level vs. Gene Expression level\")\nlabels &lt;- \"Sample-Gene\"\ntext(GeneExpression, Protein_matrix, labels = labels, pos=3)\n\n\n\n# generating a heatmap\nheatmap(Protein_matrix, main= \"Heatmap of Protein Level\", Rowv = TRUE, Colv = TRUE, labRow= rownames(Protein_matrix), labCol= c(\"ProteinA\", \"ProteinB\", \"ProteinC\"), col=topo.colors(256) )\n\n\n\n\n\n\nHeatmap of Expression:\n\n\n\nheatmap(GeneExpression, col = terrain.colors(10), scale = \"column\")\n\n\n\n\n\n\nMatrix multiplication allows each gene in both samples to be multiplied to their respective translation efficiency. So, the product shows how successfully each gene is translated”)\nThe diagonal TranslationMatrix make sense biologically because they show translation efficiency of each gene and there is no other interaction between them. Although there could be interaction in real-world scenarios.\nIf Sample2 has higher protein levels even with similar gene expression, it means that more mRNAs are translated to proteins compared to Sample1”\nThe upward trend in MARplot may indicate an increase in translation efficacy and downward trend may indicate a decline in translation efficacy”\nClustering in the heatmap may suggest which samples are most similar to each other based on their prot."
  },
  {
    "objectID": "ch/rbasics/solutions.html#task-3-animal-breeding-bull-ranking-by-economic-traits",
    "href": "ch/rbasics/solutions.html#task-3-animal-breeding-bull-ranking-by-economic-traits",
    "title": "HW solutions",
    "section": "",
    "text": "# Define Bull EBVs\nBullEBVs &lt;- matrix(c(\n  400, 1.2, 0.8,\n  500, 1.5, 0.6\n), nrow = 2, byrow = TRUE)\n\nrownames(BullEBVs) &lt;- c(\"Bull1\", \"Bull2\")\ncolnames(BullEBVs) &lt;- c(\"Milk_yield\", \"Growth_rate\", \"Fertility\")\nBullEBVs\n\n      Milk_yield Growth_rate Fertility\nBull1        400         1.2       0.8\nBull2        500         1.5       0.6\n\n# Define Economic Weights\nEconomicWeights &lt;- matrix(c(0.002, 50, 100), ncol = 1)\nrownames(EconomicWeights) &lt;- colnames(BullEBVs)\ncolnames(EconomicWeights) &lt;- c(\"Weight\")\nEconomicWeights\n\n            Weight\nMilk_yield   2e-03\nGrowth_rate  5e+01\nFertility    1e+02\n\n\n\n\nTotalValue &lt;- BullEBVs %*% EconomicWeights\ncolnames(TotalValue) &lt;- c(\"Merit\")\nTotalValue\n\n      Merit\nBull1 140.8\nBull2 136.0\n\n\nInterpretation\nBull1: (400 × 0.002) + (1.2 × 50) + (0.8 × 100) = 140.8\nBull2: (500 × 0.002) + (1.5 × 50) + (0.6 × 100) = 136.0\nBull1 is more valuable economically.\nBiological Interpretation\nEconomic weights convert genetic merit (EBVs, Estimated Breeding Values) into economic merit. Traits with higher financial importance have a larger impact, regardless of absolute EBV values.\n\n\nI3 &lt;- diag(3)\nrownames(I3) &lt;- colnames(BullEBVs)\ncolnames(I3) &lt;- colnames(BullEBVs)\nI3\n\n            Milk_yield Growth_rate Fertility\nMilk_yield           1           0         0\nGrowth_rate          0           1         0\nFertility            0           0         1\n\nBullEBVs_identity &lt;- BullEBVs %*% I3\nBullEBVs_identity\n\n      Milk_yield Growth_rate Fertility\nBull1        400         1.2       0.8\nBull2        500         1.5       0.6\n\n\nInterpretation\nMultiplying by identity matrix returns the original matrix. It confirms that EBV structure is preserved.\n\n\nBullEBVs_noMilk &lt;- BullEBVs[, -1]\nEconomicWeights_noMilk &lt;- EconomicWeights[2:3, , drop = FALSE]\n\nTotalValue_noMilk &lt;- BullEBVs_noMilk %*% EconomicWeights_noMilk\ncolnames(TotalValue_noMilk) &lt;- c(\"New_Merit\")\nTotalValue_noMilk\n\n      New_Merit\nBull1       140\nBull2       135\n\n\nInterpretation\nBull1: (1.2 × 50) + (0.8 × 100) = 140\nBull2: (1.5 × 50) + (0.6 × 100) = 135\nBull1 still ranks higher, but by a smaller margin.\n\n\nbarplot(\n  TotalValue,\n  beside = TRUE,\n  names.arg = rownames(BullEBVs),\n  col = c(\"skyblue\", \"orange\"),\n  main = \"Total Economic Value of Bulls\",\n  ylab = \"Total Value\"\n)\n\n\n\n\n\n\nheatmap(\n  BullEBVs,\n  Rowv = NA,\n  Colv = NA,\n  scale = \"none\",\n  col = heat.colors(256),\n  main = \"Heatmap of Bull EBVs\"\n)\n\n\n\n\n\n\nHow do economic weights affect trait importance?\n\nTraits with higher weights contribute more to the total economic value. This makes them more influential in ranking and selection.\n\nWhy might you ignore milk yield?\n\nMilk yield may be excluded in systems focusing on fertility, growth, or when it is no longer a limiting factor. Environmental or economic contexts may also shift trait priorities.\n\nWhat is the value of heatmaps?\n\nHeatmaps visually compare EBVs across bulls and traits.They help detect patterns, outliers, and clusters easily in multivariate data.\n\nCan this method be extended to more bulls and traits?\n\nYes. This method scales to any number of bulls or traits. Just ensure the EBVs matrix and economic weights are dimensionally compatible."
  },
  {
    "objectID": "ch/rbasics/solutions.html#task-4-plant-breeding-trait-contributions-from-parental-lines",
    "href": "ch/rbasics/solutions.html#task-4-plant-breeding-trait-contributions-from-parental-lines",
    "title": "HW solutions",
    "section": "",
    "text": "Parent trait values (normalized 1–10)\n\nParentTraits &lt;- matrix(c(\n  7, 5, 3,\n  6, 8, 4,\n  5, 6, 6\n), nrow = 3, byrow = TRUE)\n\nrownames(ParentTraits) &lt;- c(\"P1\", \"P2\", \"P3\")\ncolnames(ParentTraits) &lt;- c(\"Drought_resistance\", \"Yield\", \"Maturation_time\")\nParentTraits\n\n   Drought_resistance Yield Maturation_time\nP1                  7     5               3\nP2                  6     8               4\nP3                  5     6               6\n\n# Define Hybrid Weights\nHybridWeights &lt;- matrix(c(0.5, 0.3, 0.2), nrow = 1)\ncolnames(HybridWeights) &lt;- colnames(ParentTraits)\nrownames(HybridWeights) &lt;- c(\"Weight\")\nHybridWeights\n\n       Drought_resistance Yield Maturation_time\nWeight                0.5   0.3             0.2\n\n\n\n\nHybridTraits &lt;- HybridWeights %*% ParentTraits\nrownames(HybridTraits) &lt;- c(\"Contribution\")\ncolnames(HybridTraits) &lt;- rownames(ParentTraits)\nHybridTraits\n\n              P1  P2  P3\nContribution 6.3 6.1 3.9\n\n\nInterpretation\nHybridTraits = (0.5 × P1) + (0.3 × P2) + (0.2 × P3)\nDrought_resistance = (0.5 × 7) + (0.3 × 6) + (0.2 × 5) = 6.3\nYield = (0.5 × 5) + (0.3 × 8) + (0.2 × 6) = 6.1\nMaturation_time = (0.5 × 3) + (0.3 × 4) + (0.2 × 6) = 3.9\nThe hybrid is moderately strong in drought resistance and yield, and has a relatively shorter maturation time.\nBiological Meaning of Unequal Contribution\nWhen one parent contributes more to a trait, it suggests that the trait’s heritable strength comes disproportionately from that parent. Breeders can use this knowledge to amplify desirable traits using the best parent.\n\n\nI3 &lt;- diag(3)\nParentTraits_identity &lt;- ParentTraits %*% I3\ncolnames(ParentTraits_identity) &lt;- colnames(ParentTraits)\nParentTraits_identity\n\n   Drought_resistance Yield Maturation_time\nP1                  7     5               3\nP2                  6     8               4\nP3                  5     6               6\n\n\nInterpretation\nMultiplying by identity matrix returns the original matrix. This operation verifies structural consistency and dimensionality.\n\n\nParentTraits_T1T2 &lt;- ParentTraits[, 1:2]\nParentTraits_T1T2\n\n   Drought_resistance Yield\nP1                  7     5\nP2                  6     8\nP3                  5     6\n\nHybridTraits_T1T2 &lt;- HybridWeights %*% ParentTraits_T1T2\nHybridTraits_T1T2\n\n       Drought_resistance Yield\nWeight                6.3   6.1\n\n\nInterpretation\nDrought_resistance = (0.5 × 7) + (0.3 × 6) + (0.2 × 5) = 6.3\nYield = (0.5 × 5) + (0.3 × 8) + (0.2 × 6) = 6.1\nRemoving a trait (T3) changes the trait profile. Hybrid selection may now favor traits that remain.\n\n\nheatmap(\n  ParentTraits,\n  Rowv = NA,\n  Colv = NA,\n  scale = \"none\",\n  col = heat.colors(256),\n  main = \"Heatmap of Parent Traits\"\n)\n\n\n\n\n\n\nbarplot(\n  HybridTraits,\n  beside = TRUE,\n  names.arg = colnames(ParentTraits),\n  col = c(\"#66c2a5\", \"#fc8d62\", \"#8da0cb\"),\n  main = \"Hybrid Trait Profile\",\n  ylab = \"Trait Value\"\n)\n\n\n\n\n\n\n\nHow does the weighting of parents affect the hybrid’s performance?\nStronger weights mean more genetic contribution. Traits from highly weighted parents dominate the hybrid profile.\n\n\nWhat does the identity matrix represent here?\nIt represents a neutral transformation. It confirms data integrity when used in matrix multiplication.\n\n\nIf you used equal weights (⅓ for each), how would the hybrid traits change?\nTraits would reflect an even mix, potentially leading to balanced but less specialized performance.\n\n\nWhat real-world limitations does this simplified model ignore?\n\nNon-additive genetic effects (dominance, epistasis)\nEnvironmental interactions\nTrait heritability and correlations\nBreeding feasibility and cost"
  },
  {
    "objectID": "ch/rbasics/solutions.html#task-5-managing-tasks-using-lists",
    "href": "ch/rbasics/solutions.html#task-5-managing-tasks-using-lists",
    "title": "HW solutions",
    "section": "",
    "text": "TaskList &lt;- list(\n  Task1 = list(\n    M = ProteinMatrix\n  ),\n  Task2 = list(\n    M = GeneExpression,\n    W = TranslationEfficiency\n  ),\n  Task3 = list(\n    M = BullTraits,\n    W = EconomicWeights\n  ),\n  Task4 = list(\n    M = ParentTraits,\n    W = HybridWeights\n  )\n)\n\n\n\nTaskList$Task2$M\n\n        GeneA GeneB GeneC\nSample1    10     8     5\nSample2    15    12    10\n\nTaskList$Task2$M %*% TaskList$Task2$W\n\n        Translate_efficiency\nSample1                 17.3\nSample2                 28.2\n\n\n\nUsing lists helps manage and operate on structured data across tasks."
  },
  {
    "objectID": "ch/rbasics/solutions.html#animal-breeding-economic-ranking-of-bulls-by-traits",
    "href": "ch/rbasics/solutions.html#animal-breeding-economic-ranking-of-bulls-by-traits",
    "title": "HW solutions",
    "section": "",
    "text": "# making a matrix of Estimated Breeding Values (EBVs) of 2 bulls\nBullEBVs &lt;- matrix(\n  c(400, 1.2, 0.8,\n    500, 1.5, 0.6), nrow = 2, byrow = TRUE\n)\n\nrownames(BullEBVs) &lt;- c(\"Bull1\", \"Bull2\")\ncolnames(BullEBVs) = c(\"Trait1 = Milk yield (liters/year)\", \"Trait2 = Growth rate (kg/day)\", \"Trait3 = Fertility (calving interval adjustment)\")\n\n# making a matrix of economic weights\nEconomicWeights = matrix(\n  c(0.002, 50, 100), nrow=3, byrow=TRUE\n)\n\nTotalValue = BullEBVs %*% EconomicWeights\nprint(TotalValue)\n\n       [,1]\nBull1 140.8\nBull2 136.0\n\nprint(\"Total value for bull1 is 140.8 and for bull2 is 136\")\n\n[1] \"Total value for bull1 is 140.8 and for bull2 is 136\"\n\nprint(\"Bull1 is more valuable economically\")\n\n[1] \"Bull1 is more valuable economically\"\n\n# what multiplying by the economic weights means biologically\nprint(\"In this case, we multiply the Estimated Breeding Values (EBVs) of each trait by corresponding Economic weights. This helps to understand the economic relevance of each trait.\" )\n\n[1] \"In this case, we multiply the Estimated Breeding Values (EBVs) of each trait by corresponding Economic weights. This helps to understand the economic relevance of each trait.\"\n\n# making 3×3 identity matrix\nI &lt;- diag(3)\nIdentityproduct = BullEBVs %*% I\nprint(Identityproduct)\n\n      [,1] [,2] [,3]\nBull1  400  1.2  0.8\nBull2  500  1.5  0.6\n\nprint(\"Multiplying I and BullEBVs returns a matrix identical to BullEBVs\")\n\n[1] \"Multiplying I and BullEBVs returns a matrix identical to BullEBVs\"\n\nprint(\"The Identity Matrix serves a control. It seems as the comparison of BullEBVs matrix with itself\")\n\n[1] \"The Identity Matrix serves a control. It seems as the comparison of BullEBVs matrix with itself\"\n\n# Subsetting the BullEBVs matrix by removing Trait1 (milk yield)\nBullsubset = BullEBVs[, 2:3]\nprint(Bullsubset)\n\n      Trait2 = Growth rate (kg/day)\nBull1                           1.2\nBull2                           1.5\n      Trait3 = Fertility (calving interval adjustment)\nBull1                                              0.8\nBull2                                              0.6\n\nEconomicweightsub = EconomicWeights[2:3,]\nprint(Economicweightsub)\n\n[1]  50 100\n\nNewTotalValues = Bullsubset %*% Economicweightsub\nprint(NewTotalValues)\n\n      [,1]\nBull1  140\nBull2  135\n\nprint(\"The ranking does not change. Bull1 is still more valuable\")\n\n[1] \"The ranking does not change. Bull1 is still more valuable\"\n\n## Visualization Tasks\n\n# creating a barplot\nTotalvalueT = t(TotalValue)\nbarplot(TotalvalueT, main=\"Total value for each bull\", ylab= \"weighted values\", col=c(\"lightblue\"))\n\n\n\n# creating a heatmap\nheatmap(BullEBVs, Rowv=TRUE, Colv=TRUE, labRow= rownames(BullEBVs), labCol= colnames(BullEBVs), col=topo.colors(256), scale=\"none\", main=\"Heatmap of EBVs\")\n\n\n\n# Interpretation Questions\n\nprint(\"1. Economic weights reflect the economic relevance of each trait, that is, which trait is important economically\")\n\n[1] \"1. Economic weights reflect the economic relevance of each trait, that is, which trait is important economically\"\n\nprint(\"2. Milk yield is ignored in some breeding programs because the main goal of breeding programs is to produce greater number of genetically superior offsprings\")\n\n[1] \"2. Milk yield is ignored in some breeding programs because the main goal of breeding programs is to produce greater number of genetically superior offsprings\"\n\nprint(\"Heatmaps help to visualize patterns and clusters in multivariate trait data\")\n\n[1] \"Heatmaps help to visualize patterns and clusters in multivariate trait data\"\n\nprint(\"Yes, this method be extended to more bulls and more traits\")\n\n[1] \"Yes, this method be extended to more bulls and more traits\""
  },
  {
    "objectID": "ch/rbasics/solutions.html#plant-breeding-trait-contributions-from-parental-lines",
    "href": "ch/rbasics/solutions.html#plant-breeding-trait-contributions-from-parental-lines",
    "title": "HW solutions",
    "section": "",
    "text": "# making parent traits matrix\nParentTraits = matrix(\n  c(7, 5, 3,\n    6, 8, 4,\n    5, 6, 6), nrow=3, byrow= TRUE\n)\nrownames(ParentTraits) = c(\"P1\", \"P2\", \"P3\")\ncolnames(ParentTraits) = c(\"T1 Drought resistance\", \"T2 Yield\", \"T3 Maturation time\")\nprint(ParentTraits)\n\n   T1 Drought resistance T2 Yield T3 Maturation time\nP1                     7        5                  3\nP2                     6        8                  4\nP3                     5        6                  6\n\n# making HybridWeights matrix\nHybridWeights = matrix(\n  c(0.5, 0.3, 0.2), nrow=3, byrow= TRUE\n)\nprint(\"HybridWeights:\")\n\n[1] \"HybridWeights:\"\n\nprint(HybridWeights)\n\n     [,1]\n[1,]  0.5\n[2,]  0.3\n[3,]  0.2\n\n# Transpose of HybridWeights\nHybridWeightsTranspose = t(HybridWeights)\nprint(\"HybridWeightsTranspose:\")\n\n[1] \"HybridWeightsTranspose:\"\n\nprint(HybridWeightsTranspose)\n\n     [,1] [,2] [,3]\n[1,]  0.5  0.3  0.2\n\n# computing Hybrid traits matrix\nHybridTraits =  HybridWeightsTranspose %*% ParentTraits\nprint(\"The HybridTraits matrix is:\")\n\n[1] \"The HybridTraits matrix is:\"\n\nprint(HybridTraits)\n\n     T1 Drought resistance T2 Yield T3 Maturation time\n[1,]                   6.3      6.1                3.9\n\n# Explaining what it means biologically when one parent contributes more to a particular trait\nprint(\"A parent contributing more to a particular trait than others makes it more desirable and more likely to be selected for plant breeding\")\n\n[1] \"A parent contributing more to a particular trait than others makes it more desirable and more likely to be selected for plant breeding\"\n\n# making identity matrix and multiplying with ParentTraits \nI = diag(3)\nprint(I)\n\n     [,1] [,2] [,3]\n[1,]    1    0    0\n[2,]    0    1    0\n[3,]    0    0    1\n\nProduct = I %*% ParentTraits\nprint(Product)\n\n     T1 Drought resistance T2 Yield T3 Maturation time\n[1,]                     7        5                  3\n[2,]                     6        8                  4\n[3,]                     5        6                  6\n\nprint(\"Observation:\")\n\n[1] \"Observation:\"\n\nprint(\" I × ParentTraits is identical to ParentTraits matrix\")\n\n[1] \" I × ParentTraits is identical to ParentTraits matrix\"\n\nprint(\"I × ParentTraits represents the original matrix and therefore no transformation or change\")\n\n[1] \"I × ParentTraits represents the original matrix and therefore no transformation or change\"\n\n# subsetting\nparentsub = ParentTraits[, 1:2]\nprint(\"Subset matrix of ParentTraits\")\n\n[1] \"Subset matrix of ParentTraits\"\n\nprint(parentsub)\n\n   T1 Drought resistance T2 Yield\nP1                     7        5\nP2                     6        8\nP3                     5        6\n\nnewhybridtraits = HybridWeightsTranspose %*% parentsub\nprint(\"recalculated hybrid traits is\")\n\n[1] \"recalculated hybrid traits is\"\n\nprint(newhybridtraits)\n\n     T1 Drought resistance T2 Yield\n[1,]                   6.3      6.1\n\nprint(\"Removing a trait does not provide insight about the maturation time of the three parent plants. The new matrix has one less column but the values of other two traits is unchanged.\")\n\n[1] \"Removing a trait does not provide insight about the maturation time of the three parent plants. The new matrix has one less column but the values of other two traits is unchanged.\"\n\n## Visulaization tasks\n\n# A heatmap of ParentTraits matrix\nheatmap(ParentTraits, Rowv=TRUE, Colv=TRUE, labRow= rownames(ParentTraits), labCol= colnames(ParentTraits), col=heat.colors(256), scale=\"none\", main=\"Heatmap of Three Traits of Three Parents\")\n\n\n\n# A barplot of HybridTraits\nhybridtraitsvec = c(T1=6.3, T2=6.1, T3=3.9)\n\n\nbarplot(hybridtraitsvec, main=\"Hybrid values of each trait\", ylab=\"weighted Values of each trait\", col=c(\"lightblue\", \"lightgreen\", \"lightyellow\"))\n\n\n\n## Interpretation Questions\n\nprint(\"The parent traits with more weight might affect hybrid’s performance more.\")\n\n[1] \"The parent traits with more weight might affect hybrid’s performance more.\"\n\nprint(\"I think the identity matrix serves as a control which is used to compare the matrix with itself\")\n\n[1] \"I think the identity matrix serves as a control which is used to compare the matrix with itself\"\n\nequal_weights = matrix(c(0.3, 0.3, 0.3), nrow=1, byrow=TRUE)\nchange_in_hybrid_traits = equal_weights %*% ParentTraits\nprint(\"The change in hybrid weights will be\")\n\n[1] \"The change in hybrid weights will be\"\n\nprint(change_in_hybrid_traits)\n\n     T1 Drought resistance T2 Yield T3 Maturation time\n[1,]                   5.4      5.7                3.9\n\nprint(\"I think this simple model ignores the influence of various abiotic and biotic factors such as environmental condition, diseases etc.\")\n\n[1] \"I think this simple model ignores the influence of various abiotic and biotic factors such as environmental condition, diseases etc.\""
  },
  {
    "objectID": "ch/rbasics/solutions.html#list",
    "href": "ch/rbasics/solutions.html#list",
    "title": "HW solutions",
    "section": "",
    "text": "# Making a MasterList\nbioList = list(\nProteinConc = list(ProteinMatrix, WeightVector),\nProteinMap = list(GeneExpression, TranslationMatrix),\nPlant = list(ParentTraits, HybridWeights),\nAnimal = list(BullEBVs, EconomicWeights)\n)\n\nprint(bioList)\n\n$ProteinConc\n$ProteinConc[[1]]\n        ProteinX ProteinY ProteinZ\nSample1        5        3        2\nSample2        7        6        4\n\n$ProteinConc[[2]]\n         Weight\nProteinX    0.5\nProteinY    1.0\nProteinZ    1.5\n\n\n$ProteinMap\n$ProteinMap[[1]]\n        GeneA GeneB GeneC\nSample1    10     8     5\nSample2    15    12    10\n\n$ProteinMap[[2]]\n      [,1] [,2] [,3]\nGeneA  1.5  0.0  0.0\nGeneB  0.0  1.2  0.0\nGeneC  0.0  0.0  1.8\n\n\n$Plant\n$Plant[[1]]\n   T1 Drought resistance T2 Yield T3 Maturation time\nP1                     7        5                  3\nP2                     6        8                  4\nP3                     5        6                  6\n\n$Plant[[2]]\n     [,1]\n[1,]  0.5\n[2,]  0.3\n[3,]  0.2\n\n\n$Animal\n$Animal[[1]]\n      Trait1 = Milk yield (liters/year) Trait2 = Growth rate (kg/day)\nBull1                               400                           1.2\nBull2                               500                           1.5\n      Trait3 = Fertility (calving interval adjustment)\nBull1                                              0.8\nBull2                                              0.6\n\n$Animal[[2]]\n      [,1]\n[1,] 2e-03\n[2,] 5e+01\n[3,] 1e+02\n\n# Task1\nprint(\"List of top level components:\")\n\n[1] \"List of top level components:\"\n\nprint(\"1. ProteinConc 2. ProteinMap 3. Plant 4. Animal\")\n\n[1] \"1. ProteinConc 2. ProteinMap 3. Plant 4. Animal\"\n\nprint(\"List of nested components:\")\n\n[1] \"List of nested components:\"\n\nprint(\"1. ProteinMatrix 2. WeightVector 3. GeneExpression 4. TranslationMatrix 5. ParentTraits 6. HybridWeights 7. BullEBVs 8.EconomicWeights\")\n\n[1] \"1. ProteinMatrix 2. WeightVector 3. GeneExpression 4. TranslationMatrix 5. ParentTraits 6. HybridWeights 7. BullEBVs 8.EconomicWeights\"\n\n# Task 2\nbioList[[2]][[1]]\n\n        GeneA GeneB GeneC\nSample1    10     8     5\nSample2    15    12    10\n\nbioList[[2]][[2]]\n\n      [,1] [,2] [,3]\nGeneA  1.5  0.0  0.0\nGeneB  0.0  1.2  0.0\nGeneC  0.0  0.0  1.8\n\nbioList[[4]][[1]]\n\n      Trait1 = Milk yield (liters/year) Trait2 = Growth rate (kg/day)\nBull1                               400                           1.2\nBull2                               500                           1.5\n      Trait3 = Fertility (calving interval adjustment)\nBull1                                              0.8\nBull2                                              0.6\n\nbioList[[4]][[2]]\n\n      [,1]\n[1,] 2e-03\n[2,] 5e+01\n[3,] 1e+02\n\nmatrix_of_plant_entry = bioList[[3]][[1]]\nprint(matrix_of_plant_entry)\n\n   T1 Drought resistance T2 Yield T3 Maturation time\nP1                     7        5                  3\nP2                     6        8                  4\nP3                     5        6                  6\n\nweight_for_protein_conc = bioList[[1]][[2]]\nprint(weight_for_protein_conc)\n\n         Weight\nProteinX    0.5\nProteinY    1.0\nProteinZ    1.5\n\n# Task 3\nWeighted_gene_expression_score = bioList[[1]][[1]] %*% bioList[[1]][[2]]\nprint(Weighted_gene_expression_score)\n\n        Weight\nSample1    8.5\nSample2   15.5\n\nContribution_of_transcripts_to_each_protein = bioList[[2]][[1]] %*% bioList[[2]][[2]]\nprint(Contribution_of_transcripts_to_each_protein)\n\n        [,1] [,2] [,3]\nSample1 15.0  9.6    9\nSample2 22.5 14.4   18\n\nHybrid_trait_values = t(bioList[[3]][[2]]) %*% bioList[[3]][[1]] \nprint(Hybrid_trait_values)\n\n     T1 Drought resistance T2 Yield T3 Maturation time\n[1,]                   6.3      6.1                3.9\n\nBull_total_economic_value = bioList[[4]][[1]] %*% bioList[[4]][[2]]\nprint(Bull_total_economic_value)\n\n       [,1]\nBull1 140.8\nBull2 136.0\n\n# Task 4\n\nsubset_BullEBVs = bioList[[4]][[1]][, 2:3]\nprint(subset_BullEBVs)\n\n      Trait2 = Growth rate (kg/day)\nBull1                           1.2\nBull2                           1.5\n      Trait3 = Fertility (calving interval adjustment)\nBull1                                              0.8\nBull2                                              0.6\n\nEcoweightsub = bioList[[4]][[2]][2:3, ]\nprint(Ecoweightsub)\n\n[1]  50 100\n\nRecalculated_total_value = subset_BullEBVs %*% Ecoweightsub\nprint(Recalculated_total_value)\n\n      [,1]\nBull1  140\nBull2  135\n\n## Visualization Tasks\n# Creating barplot showing the result of weighted trait aggregation for the Plant hybrid\nbarplot(Hybrid_trait_values, main=\"weighted trait aggregation for the Plant hybrid\", ylab=\"weighted Values of each trait\", col=c(\"salmon\"))\n\n\n\n# Creating barplot showing the total breeding values for each bull\nbarplot(t(Bull_total_economic_value), main=\"Comparison of Total values of Bulls\", ylab=\"weighted Values of each trait\", col=c(\"lightblue\"))\n\n\n\n# Creating heatmap\nheatmap(bioList[[4]][[1]], Rowv=TRUE, Colv=TRUE, labRow= rownames(bioList[[4]][[1]]), labCol= colnames(bioList[[4]][[1]]), col=heat.colors(256), scale= \"column\", main=\"Heatmap of Bull EBVs\")\n\n\n\n## Interpretation Questions\nprint(\"Structuring data using a list help to logically organise different datatypes such as matrix, vector and list itself. Since each component is differently named, they can be easily accessed.\")\n\n[1] \"Structuring data using a list help to logically organise different datatypes such as matrix, vector and list itself. Since each component is differently named, they can be easily accessed.\"\n\nprint(\"Nested lists require multiple levels of indexing where there is a higher chance of making mistakes with the indices such as using the wrong number of brackets or the wrong index number\")\n\n[1] \"Nested lists require multiple levels of indexing where there is a higher chance of making mistakes with the indices such as using the wrong number of brackets or the wrong index number\"\n\nprint(\"Yes, this structure could be scaled for real datasets with many samples or traits\")\n\n[1] \"Yes, this structure could be scaled for real datasets with many samples or traits\"\n\nprint(\"How would you loop over all elements in bioList to apply the same function? Not sure\")\n\n[1] \"How would you loop over all elements in bioList to apply the same function? Not sure\"\n\nprint(\"How can this list structure be useful for building automated bioinformatics pipelines? Not sure\")\n\n[1] \"How can this list structure be useful for building automated bioinformatics pipelines? Not sure\""
  },
  {
    "objectID": "ch/rbasics/solutions.html#task-5-list",
    "href": "ch/rbasics/solutions.html#task-5-list",
    "title": "HW solutions",
    "section": "",
    "text": "# Making a MasterList\nbioList = list(\nProteinConc = list(ProteinMatrix, WeightVector),\nProteinMap = list(GeneExpression, TranslationMatrix),\nPlant = list(ParentTraits, HybridWeights),\nAnimal = list(BullEBVs, EconomicWeights)\n)\n\nprint(bioList)\n\n$ProteinConc\n$ProteinConc[[1]]\n        ProteinX ProteinY ProteinZ\nSample1        5        3        2\nSample2        7        6        4\n\n$ProteinConc[[2]]\n         Weight\nProteinX    0.5\nProteinY    1.0\nProteinZ    1.5\n\n\n$ProteinMap\n$ProteinMap[[1]]\n        GeneA GeneB GeneC\nSample1    10     8     5\nSample2    15    12    10\n\n$ProteinMap[[2]]\n      [,1] [,2] [,3]\nGeneA  1.5  0.0  0.0\nGeneB  0.0  1.2  0.0\nGeneC  0.0  0.0  1.8\n\n\n$Plant\n$Plant[[1]]\n   T1 Drought resistance T2 Yield T3 Maturation time\nP1                     7        5                  3\nP2                     6        8                  4\nP3                     5        6                  6\n\n$Plant[[2]]\n     [,1]\n[1,]  0.5\n[2,]  0.3\n[3,]  0.2\n\n\n$Animal\n$Animal[[1]]\n      Trait1 = Milk yield (liters/year) Trait2 = Growth rate (kg/day)\nBull1                               400                           1.2\nBull2                               500                           1.5\n      Trait3 = Fertility (calving interval adjustment)\nBull1                                              0.8\nBull2                                              0.6\n\n$Animal[[2]]\n      [,1]\n[1,] 2e-03\n[2,] 5e+01\n[3,] 1e+02\n\n# Task1\nprint(\"List of top level components:\")\n\n[1] \"List of top level components:\"\n\nprint(\"1. ProteinConc 2. ProteinMap 3. Plant 4. Animal\")\n\n[1] \"1. ProteinConc 2. ProteinMap 3. Plant 4. Animal\"\n\nprint(\"List of nested components:\")\n\n[1] \"List of nested components:\"\n\nprint(\"1. ProteinMatrix 2. WeightVector 3. GeneExpression 4. TranslationMatrix 5. ParentTraits 6. HybridWeights 7. BullEBVs 8.EconomicWeights\")\n\n[1] \"1. ProteinMatrix 2. WeightVector 3. GeneExpression 4. TranslationMatrix 5. ParentTraits 6. HybridWeights 7. BullEBVs 8.EconomicWeights\"\n\n# Task 2\nbioList[[2]][[1]]\n\n        GeneA GeneB GeneC\nSample1    10     8     5\nSample2    15    12    10\n\nbioList[[2]][[2]]\n\n      [,1] [,2] [,3]\nGeneA  1.5  0.0  0.0\nGeneB  0.0  1.2  0.0\nGeneC  0.0  0.0  1.8\n\nbioList[[4]][[1]]\n\n      Trait1 = Milk yield (liters/year) Trait2 = Growth rate (kg/day)\nBull1                               400                           1.2\nBull2                               500                           1.5\n      Trait3 = Fertility (calving interval adjustment)\nBull1                                              0.8\nBull2                                              0.6\n\nbioList[[4]][[2]]\n\n      [,1]\n[1,] 2e-03\n[2,] 5e+01\n[3,] 1e+02\n\nmatrix_of_plant_entry = bioList[[3]][[1]]\nprint(matrix_of_plant_entry)\n\n   T1 Drought resistance T2 Yield T3 Maturation time\nP1                     7        5                  3\nP2                     6        8                  4\nP3                     5        6                  6\n\nweight_for_protein_conc = bioList[[1]][[2]]\nprint(weight_for_protein_conc)\n\n         Weight\nProteinX    0.5\nProteinY    1.0\nProteinZ    1.5\n\n# Task 3\nWeighted_gene_expression_score = bioList[[1]][[1]] %*% bioList[[1]][[2]]\nprint(Weighted_gene_expression_score)\n\n        Weight\nSample1    8.5\nSample2   15.5\n\nContribution_of_transcripts_to_each_protein = bioList[[2]][[1]] %*% bioList[[2]][[2]]\nprint(Contribution_of_transcripts_to_each_protein)\n\n        [,1] [,2] [,3]\nSample1 15.0  9.6    9\nSample2 22.5 14.4   18\n\nHybrid_trait_values = t(bioList[[3]][[2]]) %*% bioList[[3]][[1]] \nprint(Hybrid_trait_values)\n\n     T1 Drought resistance T2 Yield T3 Maturation time\n[1,]                   6.3      6.1                3.9\n\nBull_total_economic_value = bioList[[4]][[1]] %*% bioList[[4]][[2]]\nprint(Bull_total_economic_value)\n\n       [,1]\nBull1 140.8\nBull2 136.0\n\n# Task 4\n\nsubset_BullEBVs = bioList[[4]][[1]][, 2:3]\nprint(subset_BullEBVs)\n\n      Trait2 = Growth rate (kg/day)\nBull1                           1.2\nBull2                           1.5\n      Trait3 = Fertility (calving interval adjustment)\nBull1                                              0.8\nBull2                                              0.6\n\nEcoweightsub = bioList[[4]][[2]][2:3, ]\nprint(Ecoweightsub)\n\n[1]  50 100\n\nRecalculated_total_value = subset_BullEBVs %*% Ecoweightsub\nprint(Recalculated_total_value)\n\n      [,1]\nBull1  140\nBull2  135\n\n## Visualization Tasks\n# Creating barplot showing the result of weighted trait aggregation for the Plant hybrid\nbarplot(Hybrid_trait_values, main=\"weighted trait aggregation for the Plant hybrid\", ylab=\"weighted Values of each trait\", col=c(\"salmon\"))\n\n\n\n# Creating barplot showing the total breeding values for each bull\nbarplot(t(Bull_total_economic_value), main=\"Comparison of Total values of Bulls\", ylab=\"weighted Values of each trait\", col=c(\"lightblue\"))\n\n\n\n# Creating heatmap\nheatmap(bioList[[4]][[1]], Rowv=TRUE, Colv=TRUE, labRow= rownames(bioList[[4]][[1]]), labCol= colnames(bioList[[4]][[1]]), col=heat.colors(256), scale= \"column\", main=\"Heatmap of Bull EBVs\")\n\n\n\n## Interpretation Questions\nprint(\"Structuring data using a list help to logically organise different datatypes such as matrix, vector and list itself. Since each component is differently named, they can be easily accessed.\")\n\n[1] \"Structuring data using a list help to logically organise different datatypes such as matrix, vector and list itself. Since each component is differently named, they can be easily accessed.\"\n\nprint(\"Nested lists require multiple levels of indexing where there is a higher chance of making mistakes with the indices such as using the wrong number of brackets or the wrong index number\")\n\n[1] \"Nested lists require multiple levels of indexing where there is a higher chance of making mistakes with the indices such as using the wrong number of brackets or the wrong index number\"\n\nprint(\"Yes, this structure could be scaled for real datasets with many samples or traits\")\n\n[1] \"Yes, this structure could be scaled for real datasets with many samples or traits\"\n\nprint(\"How would you loop over all elements in bioList to apply the same function? Not sure\")\n\n[1] \"How would you loop over all elements in bioList to apply the same function? Not sure\"\n\nprint(\"How can this list structure be useful for building automated bioinformatics pipelines? Not sure\")\n\n[1] \"How can this list structure be useful for building automated bioinformatics pipelines? Not sure\""
  },
  {
    "objectID": "ch/rbasics/solutions.html#task-5-lists",
    "href": "ch/rbasics/solutions.html#task-5-lists",
    "title": "HW solutions",
    "section": "",
    "text": "# Making a MasterList\nbioList = list(\nProteinConc = list(ProteinMatrix, WeightVector),\nProteinMap = list(GeneExpression, TranslationMatrix),\nPlant = list(ParentTraits, HybridWeights),\nAnimal = list(BullEBVs, EconomicWeights)\n)\n\nprint(bioList)\n\n$ProteinConc\n$ProteinConc[[1]]\n        ProteinX ProteinY ProteinZ\nSample1        5        3        2\nSample2        7        6        4\n\n$ProteinConc[[2]]\n         Weight\nProteinX    0.5\nProteinY    1.0\nProteinZ    1.5\n\n\n$ProteinMap\n$ProteinMap[[1]]\n        GeneA GeneB GeneC\nSample1    10     8     5\nSample2    15    12    10\n\n$ProteinMap[[2]]\n      [,1] [,2] [,3]\nGeneA  1.5  0.0  0.0\nGeneB  0.0  1.2  0.0\nGeneC  0.0  0.0  1.8\n\n\n$Plant\n$Plant[[1]]\n   T1 Drought resistance T2 Yield T3 Maturation time\nP1                     7        5                  3\nP2                     6        8                  4\nP3                     5        6                  6\n\n$Plant[[2]]\n     [,1]\n[1,]  0.5\n[2,]  0.3\n[3,]  0.2\n\n\n$Animal\n$Animal[[1]]\n      Milk_yield Growth_rate Fertility\nBull1        400         1.2       0.8\nBull2        500         1.5       0.6\n\n$Animal[[2]]\n      [,1]\n[1,] 2e-03\n[2,] 5e+01\n[3,] 1e+02\n\n# Task1\nprint(\"List of top level components:\")\n\n[1] \"List of top level components:\"\n\nprint(\"1. ProteinConc 2. ProteinMap 3. Plant 4. Animal\")\n\n[1] \"1. ProteinConc 2. ProteinMap 3. Plant 4. Animal\"\n\nprint(\"List of nested components:\")\n\n[1] \"List of nested components:\"\n\nprint(\"1. ProteinMatrix 2. WeightVector 3. GeneExpression 4. TranslationMatrix 5. ParentTraits 6. HybridWeights 7. BullEBVs 8.EconomicWeights\")\n\n[1] \"1. ProteinMatrix 2. WeightVector 3. GeneExpression 4. TranslationMatrix 5. ParentTraits 6. HybridWeights 7. BullEBVs 8.EconomicWeights\"\n\n# Task 2\nbioList[[2]][[1]]\n\n        GeneA GeneB GeneC\nSample1    10     8     5\nSample2    15    12    10\n\nbioList[[2]][[2]]\n\n      [,1] [,2] [,3]\nGeneA  1.5  0.0  0.0\nGeneB  0.0  1.2  0.0\nGeneC  0.0  0.0  1.8\n\nbioList[[4]][[1]]\n\n      Milk_yield Growth_rate Fertility\nBull1        400         1.2       0.8\nBull2        500         1.5       0.6\n\nbioList[[4]][[2]]\n\n      [,1]\n[1,] 2e-03\n[2,] 5e+01\n[3,] 1e+02\n\nmatrix_of_plant_entry = bioList[[3]][[1]]\nprint(matrix_of_plant_entry)\n\n   T1 Drought resistance T2 Yield T3 Maturation time\nP1                     7        5                  3\nP2                     6        8                  4\nP3                     5        6                  6\n\nweight_for_protein_conc = bioList[[1]][[2]]\nprint(weight_for_protein_conc)\n\n         Weight\nProteinX    0.5\nProteinY    1.0\nProteinZ    1.5\n\n# Task 3\nWeighted_gene_expression_score = bioList[[1]][[1]] %*% bioList[[1]][[2]]\nprint(Weighted_gene_expression_score)\n\n        Weight\nSample1    8.5\nSample2   15.5\n\nContribution_of_transcripts_to_each_protein = bioList[[2]][[1]] %*% bioList[[2]][[2]]\nprint(Contribution_of_transcripts_to_each_protein)\n\n        [,1] [,2] [,3]\nSample1 15.0  9.6    9\nSample2 22.5 14.4   18\n\nHybrid_trait_values = t(bioList[[3]][[2]]) %*% bioList[[3]][[1]] \nprint(Hybrid_trait_values)\n\n     T1 Drought resistance T2 Yield T3 Maturation time\n[1,]                   6.3      6.1                3.9\n\nBull_total_economic_value = bioList[[4]][[1]] %*% bioList[[4]][[2]]\nprint(Bull_total_economic_value)\n\n       [,1]\nBull1 140.8\nBull2 136.0\n\n# Task 4\n\nsubset_BullEBVs = bioList[[4]][[1]][, 2:3]\nprint(subset_BullEBVs)\n\n      Growth_rate Fertility\nBull1         1.2       0.8\nBull2         1.5       0.6\n\nEcoweightsub = bioList[[4]][[2]][2:3, ]\nprint(Ecoweightsub)\n\n[1]  50 100\n\nRecalculated_total_value = subset_BullEBVs %*% Ecoweightsub\nprint(Recalculated_total_value)\n\n      [,1]\nBull1  140\nBull2  135\n\n## Visualization Tasks\n# Creating barplot showing the result of weighted trait aggregation for the Plant hybrid\nbarplot(Hybrid_trait_values, main=\"weighted trait aggregation for the Plant hybrid\", ylab=\"weighted Values of each trait\", col=c(\"salmon\"))\n\n\n\n# Creating barplot showing the total breeding values for each bull\nbarplot(t(Bull_total_economic_value), main=\"Comparison of Total values of Bulls\", ylab=\"weighted Values of each trait\", col=c(\"lightblue\"))\n\n\n\n# Creating heatmap\nheatmap(bioList[[4]][[1]], Rowv=TRUE, Colv=TRUE, labRow= rownames(bioList[[4]][[1]]), labCol= colnames(bioList[[4]][[1]]), col=heat.colors(256), scale= \"column\", main=\"Heatmap of Bull EBVs\")\n\n\n\n## Interpretation Questions\nprint(\"Structuring data using a list help to logically organise different datatypes such as matrix, vector and list itself. Since each component is differently named, they can be easily accessed.\")\n\n[1] \"Structuring data using a list help to logically organise different datatypes such as matrix, vector and list itself. Since each component is differently named, they can be easily accessed.\"\n\nprint(\"Nested lists require multiple levels of indexing where there is a higher chance of making mistakes with the indices such as using the wrong number of brackets or the wrong index number\")\n\n[1] \"Nested lists require multiple levels of indexing where there is a higher chance of making mistakes with the indices such as using the wrong number of brackets or the wrong index number\"\n\nprint(\"Yes, this structure could be scaled for real datasets with many samples or traits\")\n\n[1] \"Yes, this structure could be scaled for real datasets with many samples or traits\"\n\nprint(\"How would you loop over all elements in bioList to apply the same function? Not sure\")\n\n[1] \"How would you loop over all elements in bioList to apply the same function? Not sure\"\n\nprint(\"How can this list structure be useful for building automated bioinformatics pipelines? Not sure\")\n\n[1] \"How can this list structure be useful for building automated bioinformatics pipelines? Not sure\""
  },
  {
    "objectID": "ch/rbasics/solutions.html#task-1-protein-quantification-in-biological-samples",
    "href": "ch/rbasics/solutions.html#task-1-protein-quantification-in-biological-samples",
    "title": "HW solutions",
    "section": "",
    "text": "We measured the concentration (in µg/µL) of three proteins (P1, P2, P3) in four samples (S1–S4):\n\n\n# Making Protein Matrix\nProteinMatrix &lt;- matrix(\n  c(5, 3, 2,\n    7, 6, 4),\n  nrow = 2, byrow = TRUE\n)\nrownames(ProteinMatrix) = c(\"Sample1\", \"Sample2\")\ncolnames(ProteinMatrix) = c(\"ProteinX\", \"ProteinY\", \"ProteinZ\")\nProteinMatrix\n\n        ProteinX ProteinY ProteinZ\nSample1        5        3        2\nSample2        7        6        4\n\n\nNow goes the weight matrix\n\n# Making weight matrix\nWeightVector &lt;- matrix(\n  c(0.5, 1.0, 1.5),\n  nrow=3, byrow = TRUE\n)\nrownames(WeightVector) = c(\"ProteinX\", \"ProteinY\", \"ProteinZ\")\ncolnames(WeightVector) = c(\"Weight\")\nWeightVector\n\n         Weight\nProteinX    0.5\nProteinY    1.0\nProteinZ    1.5\n\n\nNow, multiply them.\n\n# Multiplying Matrices\nTotalConc = ProteinMatrix %*% WeightVector\ncolnames(TotalConc) &lt;- \"Total_Protein_Conc\"\nprint(TotalConc)\n\n        Total_Protein_Conc\nSample1                8.5\nSample2               15.5\n\n\n\n\nProteinMatTranspose = t(ProteinMatrix)\nProteinMatTranspose\n\n         Sample1 Sample2\nProteinX       5       7\nProteinY       3       6\nProteinZ       2       4\n\n\n\n\nI &lt;- diag(3)\nIdentitycheck = ProteinMatrix %*% I\ncolnames(Identitycheck) &lt;- c(\"ProteinX\", \"ProteinY\", \"ProteinZ\")\nIdentitycheck\n\n        ProteinX ProteinY ProteinZ\nSample1        5        3        2\nSample2        7        6        4\n\n\n\n\nrowSums(ProteinMatrix)\n\nSample1 Sample2 \n     10      17 \n\n\n\n\ncolSums(ProteinMatrix)\n\nProteinX ProteinY ProteinZ \n      12        9        6 \n\n\n\n\nheatmap(ProteinMatrix, scale = \"none\", col = heat.colors(10))\n\n\n\n\n\n\nMultiplying the protein levels by the weight vector shows how much each protein contributes in a sample. The result shows total protein concentration per sample.\nThe result shows that sample S2 has the highest protein burden.\nThe identity matrix represents no protein interactions or measurement biases. It is a simple matrix calculation.\nNew calculation:\n\n\n# changing the weight of ProteinZ to 3.0\nnewweightvector = matrix(\n  c(0.5, 1.0, 3.0),\n  nrow=3, byrow = TRUE\n)\nrownames(WeightVector) = c(\"ProteinX\", \"ProteinY\", \"ProteinZ\")\ncolnames(WeightVector) = c(\"Weight\")\nnewTotalconc = ProteinMatrix %*% newweightvector\ncolnames(newTotalconc) &lt;- \"Total_Protein_Conc\"\nnewTotalconc\n\n        Total_Protein_Conc\nSample1               11.5\nSample2               21.5\n\n\nStill, S2 has more protein burden.\nBonus:\n\nHeatmap reveals PX is most abundant across all samples."
  },
  {
    "objectID": "ch/rbasics/solutions.html#task-5-managing-matrices-and-weight-vectors-using-lists-in-r",
    "href": "ch/rbasics/solutions.html#task-5-managing-matrices-and-weight-vectors-using-lists-in-r",
    "title": "HW solutions",
    "section": "",
    "text": "Now that we’ve explored trait-based decisions using matrices, it’s time to organize our work using R’s list structure. Lists help bundle related objects like matrices and weight vectors, keeping the analysis modular and scalable.\n\n\n# Assuming previous matrices and weights are already defined:\n\n# Making a MasterList\nbioList = list(\n  ProteinConc = list(matrix = ProteinMatrix, weights = WeightVector),\n  ProteinMap  = list(matrix = GeneExpression, weights = TranslationMatrix),\n  Animal = list(matrix = BullEBVs, weights = EconomicWeights),\n  Plant = list(matrix = ParentTraits, weights = HybridWeights)\n)\n\nprint(bioList)\n\n$ProteinConc\n$ProteinConc$matrix\n        ProteinX ProteinY ProteinZ\nSample1        5        3        2\nSample2        7        6        4\n\n$ProteinConc$weights\n         Weight\nProteinX    0.5\nProteinY    1.0\nProteinZ    1.5\n\n\n$ProteinMap\n$ProteinMap$matrix\n        GeneA GeneB GeneC\nSample1    10     8     5\nSample2    15    12    10\n\n$ProteinMap$weights\n      protA protB protC\nGeneA   1.5   0.0   0.0\nGeneB   0.0   1.2   0.0\nGeneC   0.0   0.0   1.8\n\n\n$Animal\n$Animal$matrix\n      Milk_yield Growth_rate Fertility\nBull1        400         1.2       0.8\nBull2        500         1.5       0.6\n\n$Animal$weights\n            Weight\nMilk_yield   2e-03\nGrowth_rate  5e+01\nFertility    1e+02\n\n\n$Plant\n$Plant$matrix\n   Drought_resistance Yield Maturation_time\nP1                  7     5               3\nP2                  6     8               4\nP3                  5     6               6\n\n$Plant$weights\n       Drought_resistance Yield Maturation_time\nWeight                0.5   0.3             0.2\n\n\n\n\nnames(bioList)               # Top-level list names\n\n[1] \"ProteinConc\" \"ProteinMap\"  \"Animal\"      \"Plant\"      \n\nlengths(bioList)             # Number of components in each sublist\n\nProteinConc  ProteinMap      Animal       Plant \n          2           2           2           2 \n\n\nInterpretation\nEach top-level entry (e.g., ProteinConc, Plant) contains two components:\n\nA matrix (e.g., ProteinMatrix)\nA corresponding weight vector or matrix\n\n\n# Access the trait matrix for Plant\nbioList$Plant[[1]]\n\n   Drought_resistance Yield Maturation_time\nP1                  7     5               3\nP2                  6     8               4\nP3                  5     6               6\n\n#or\nbioList$Plant$matrix\n\n   Drought_resistance Yield Maturation_time\nP1                  7     5               3\nP2                  6     8               4\nP3                  5     6               6\n\n# Access the weight vector for ProteinConc\nbioList$ProteinConc[[2]]\n\n         Weight\nProteinX    0.5\nProteinY    1.0\nProteinZ    1.5\n\n#or\nbioList$ProteinConc$weights\n\n         Weight\nProteinX    0.5\nProteinY    1.0\nProteinZ    1.5\n\n\nInterpretation\nUse double brackets [[ ]] to extract unnamed list elements by position. But we named our list, so they are easily extractable using the $ notation.\n\n\n# Protein concentration score\nbioList$ProteinConc$matrix %*% bioList$ProteinConc$weights\n\n        Weight\nSample1    8.5\nSample2   15.5\n\n# Gene → Protein contribution\nbioList$ProteinMap$matrix %*% bioList$ProteinMap$weights\n\n        protA protB protC\nSample1  15.0   9.6     9\nSample2  22.5  14.4    18\n\n# Bull economic value\nbioList$Animal$matrix %*% bioList$Animal$weights\n\n      Weight\nBull1  140.8\nBull2  136.0\n\n# Hybrid trait value\nbioList$Plant$weights %*% bioList$Plant$matrix\n\n       Drought_resistance Yield Maturation_time\nWeight                6.3   6.1             3.9\n\n\n\n\n# Remove last trait from ParentTraits\nParentSubset &lt;- bioList$Plant$matrix[, 1:2]\nNewWeights &lt;- matrix(c(0.6, 0.4), nrow = 2)\n\n# Recalculated hybrid score\nSubsetHybridScore &lt;- ParentSubset %*% NewWeights\nSubsetHybridScore\n\n   [,1]\nP1  6.2\nP2  6.8\nP3  5.4\n\n\nInterpretation\nDropping a trait and reweighting highlights its influence in trait aggregation and selection.\n\n\n\nheatmap(\n  bioList$ProteinMap$matrix,\n  scale = \"none\",\n  col = heat.colors(256),\n  main = \"Gene Expression Heatmap\",\n  xlab = \"Proteins\",\n  ylab = \"Genes\"\n)\n\n\n\n\n\n\n\nbarplot(\n  bioList$Plant$weights %*% bioList$Plant$matrix,\n  beside = TRUE,\n  main = \"Hybrid Trait Contributions\",\n  col = \"#66c2a5\",\n  ylab = \"Score\"\n)\n\n\n\n\n\n\nbarplot(\n  bioList$Animal$matrix %*% bioList$Animal$weights,\n  beside = TRUE,\n  main = \"Bull EBVs (Economic Values)\",\n  col = \"#fc8d62\",\n  ylab = \"Score\"\n)\n\n\n\n\n\n\nWhy use a list structure?\n\nKeeps each dataset and its weights together. Facilitates automated workflows and reuse.\n\nWhat’s tricky about [[ ]] access?\n\nYou must remember the order ([[1]] = matrix, [[2]] = weights). No names means you can’t use $matrix, only positional access.\nLoop across all list entries\nWeighted scores for all entries lapply(bioList, function(x) x[[2]] %*% x[[1]])\n\nHow does this help in large-scale pipelines?\n\nYou can use this format with lapply(), purrr::map(), or in targets pipelines for reproducibility and modular processing."
  },
  {
    "objectID": "ch/rbasics/firststeps.html#homework-factors-subsetting-and-biological-insight",
    "href": "ch/rbasics/firststeps.html#homework-factors-subsetting-and-biological-insight",
    "title": "Basic R",
    "section": "🏡 Homework: Factors, Subsetting, and Biological Insight",
    "text": "🏡 Homework: Factors, Subsetting, and Biological Insight\n\n(Factor vs Character) Explain the difference between a character vector and a factor in R. Why would mutation_status be a factor and not just a character vector?\n(Factor Level Order) You observed the following bacterial species in gut microbiome samples:\n\n\nspecies &lt;- c(\"Lactobacillus\", \"Bacteroides\", \"Escherichia\", \"Bacteroides\", \"Lactobacillus\")\nspecies_factor &lt;- factor(species, levels = c(\"Bacteroides\", \"Escherichia\", \"Lactobacillus\"))\n\nWhat will levels(species_factor) return? Why?\n\nGiven the factor:\n\n\ndisease_severity &lt;- factor(c(\"Mild\", \"Severe\", \"Moderate\"), levels = c(\"Mild\", \"Moderate\", \"Severe\", \"Critical\"), ordered = TRUE)\n\nWhat will be the result of disease_severity[1] &lt; disease_severity[2] and why?\n\nYou computed:\n\n\nprop &lt;- prop.table(table(species_factor))\n\nHow do you extract the proportion of “Escherichia” samples from prop? Is prop$Escherichia valid?\n\nInterpret what this query returns:\n\n\ngene_df[gene_df$expression &gt; 7 & gene_df$mutation == \"No\", ]\n\nWhat type of genes does it select?\n\nYou have:\n\n\nsamples &lt;- c(\"WT\", \"KO\", \"WT\", \"KO\", \"WT\")\nexpression &lt;- c(5.2, 8.1, 4.3, 9.0, 5.7)\n\nMake a dataframe using these 2 vectors first. Then,\n\nCreate a factor group_factor for the samples.\nUse tapply() to calculate mean expression per group.\n\n\n\n\n\n\n\nNote\n\n\n\nUse ?tapply() to see how to use it.\nHint: You need to provide things for X, INDEX, FUN. You have X, INDEX in this small dataframe. The FUN should be applied thinking of what you are trying to do. You are trying to get the mean or average, right?\n\n\n\nPlot a barplot of average expression for each group.\n\n\nUse the gene_df example. Subset the data to find genes with:\n\n\nexpression &gt; 8\npathway is either “Cell Cycle” or “Signaling”\n\n\nCreate an ordered factor for the disease stages: c(\"Stage I\", \"Stage III\", \"Stage II\", \"Stage IV\", \"Stage I\"). Then plot the number of patients per stage using barplot(). Confirm that \"Stage III\" &gt; \"Stage I\" is logical in your factor.\nSuppose gene_data has a column type with values “Oncogene”, “Tumor Suppressor”, and “Housekeeping”.\n\n\nSubset all “Oncogene” rows where expression &gt; 8.\nChange the reference level of the factor type to “Housekeeping”\n\n\nSimulate expression data for 3 tissues (see the code chunk below): We are going to use rnorm() function to generate random values from a normal distribution for this purpose. The example values inside the rnorm() function means we want:\n\n\n30 values in total,\naverage or mean value = 8,\nstandard deviation of expression is 2.\n\nYou can play with the numbers to make your own values.\nrep() function is to replicate things (many times). In this example, we have rep(c(\"brain\", \"liver\", \"kidney\"), each = 10). We will be having 10x “brains”, followed by 10x “liver”, followed by 10x “kidney”. So, if you have changed your values inside the rnorm() function, make this value meaningful for you. Now we have 3 things, each=10. So, 3*10=30 is matching with the total value inside rnorm() function. Got it?\n\nset.seed(42) #just for reproducibility. Not completely needed\ngene_expr &lt;- rnorm(30, mean = 8, sd = 2)\ntissue &lt;- rep(c(\"brain\", \"liver\", \"kidney\"), each = 10)\ntissue_factor &lt;- factor(tissue, levels = c(\"liver\", \"brain\", \"kidney\"))\n\n\nMake a boxplot showing expression per tissue.\nWhich tissue shows the most variable gene expression? (Use tapply() + sd())\n\n\n\n\n\n\n\nNote\n\n\n\nHint: Variability is an expression of measuring standard deviation (sd) just by squaring it. So, var = sd^2. Well, do you see how to use sd inside tapply() function? Use ?tapply() to know how to use it.\n\n\nUse these questions as a self-check – reflect on why each step works before moving on to the next level (question).\nPush your .Rmd file and share by Friday 10PM BD Time."
  },
  {
    "objectID": "ch/rbasics/firststeps.html#summary-of-the-lesson",
    "href": "ch/rbasics/firststeps.html#summary-of-the-lesson",
    "title": "Basic R",
    "section": "Summary of the Lesson",
    "text": "Summary of the Lesson\nIn this lesson, we covered:\n\n\nFactor Variables: Essential for categorical data in biology (genotypes, treatments, etc.)\n\n\nCreation, levels, ordering, and visualization\n\n\n\nSubsetting Techniques: Critical for data extraction and analysis\n\n\nVector and data frame subsetting with various methods\nUsing row names effectively for biological identifiers\n\n\n\nMatrix Operations: Fundamental for expression data\n\n\nCreation, manipulation, and biological applications\nCalculating fold changes and other common operations\n\n\n\nMissing Values: Practical approaches for real-world biological data\n\n\nIdentification and appropriate replacement methods\n\n\n\nData Transformation: Making data suitable for statistical analysis\n\n\nLog, square root, and z-score transformations\nOutlier identification and handling\n\n\n\nLogical Operations: For data filtering and decision making\n\n\n\nConditions, combinations, and applications\nThese skills form the foundation for the more advanced visualization techniques we’ll cover in future lessons.\n\n\n\n\nList: Fundamental for many biological data and packages’ output.\n\n\nProperties, accessing, and applications\n\n\nWe will know more about conditionals, R packages to handle data and visualization in a better and efficient way."
  },
  {
    "objectID": "ch/rbasics/firststeps.html#conditionals",
    "href": "ch/rbasics/firststeps.html#conditionals",
    "title": "Basic R",
    "section": "Conditionals",
    "text": "Conditionals\n\nif-else statement\n\n# if-else statement\ngene_value &lt;- 6.8\n\nif(gene_value &gt; 10) {\n  print(\"High expression\")\n} else if(gene_value &gt; 5) {\n  print(\"Medium expression\")\n} else {\n  print(\"Low expression\")\n}\n\n[1] \"Medium expression\"\n\n\nVisualize it using the image below.\n\n\n\n\nelseif statement for vectors\nelseif is binary in nature. So, we can categorize only 2 things using elseif. See this example:\n\nexpression_values &lt;- c(12.5, 4.3, 8.1, 2.2)\nlabels &lt;- ifelse(expression_values &gt; 5, \"Upregulated\", \"Downregulated\")\nlabels\n\n[1] \"Upregulated\"   \"Downregulated\" \"Upregulated\"   \"Downregulated\"\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nelseif has 3 things inside the parentheses, right? The first one is the condition, the second one is the category we define if the condition is met, and the third thing is the other remaining category we want to assign if the condition is not met. So, it’s usage is perfect to say if a gene/transcript is upregulated or downregulated (binary classification).\n\n\nIf we still want to categorize more than 2 categories using elseif, we need to use it in a nested way. See this example:\n\n# ifelse() for vectors\nexpression_levels &lt;- c(2.5, 5.8, 7.2, 3.1, 6.9)\nexpression_category &lt;- ifelse(expression_levels &gt; 6, \n                             \"High\", \n                             ifelse(expression_levels &gt; 4, \"Medium\", \"Low\"))\nexpression_category\n\n[1] \"Low\"    \"Medium\" \"High\"   \"Low\"    \"High\"  \n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nYou remember the general structure of elseif loop, right? the second thing after the first , is the assigned category if the condition is met. So, we assigned it as High here in this example. But then after the second , there is a second elseif loop instead of a category. The second loop makes 2 more binary categories Medium and Low, and our task of assigning 3 categories is achieved.\n\n\ndplyr package has a function named case-when() to help us use as many categories we want. The same task would be achieved like this:\n\n# Requires dplyr package\n#install.packages(\"dplyr\") #decomment if you need to install the package\nlibrary(dplyr)\nexpression_levels &lt;- c(2.5, 5.8, 7.2, 3.1, 6.9)\nlabels &lt;- case_when(\n  expression_levels &gt; 6 ~ \"High\",\n  expression_levels &gt; 4 ~ \"Medium\",\n  TRUE ~ \"Low\"  # Default case\n)\nlabels\n\n[1] \"Low\"    \"Medium\" \"High\"   \"Low\"    \"High\"  \n\n\n\n\n\n\n\n\nNote\n\n\n\nDo you see the point how you would use the elseif loop if you wanted to write a function to make 4 or 5 categories? If not, pause and re-think. You need to see the point. But anyway, categorizing more than 2 is better using if else statement\n\n\n\nfor loop\n\ngenes &lt;- c(\"BRCA1\", \"TP53\", \"MYC\", \"CDC2\", \"MBP\")\nexpr &lt;- c(8.2, 5.4, 11.0, 5.4, 13.0)\n\nfor (i in 1:length(genes)) {\n  status &lt;- if (expr[i] &gt; 10) \"High\" else if (expr[i] &gt; 6) \"Moderate\" else \"Low\"\n  cat(genes[i], \"has\", status, \"expression\\n\")\n}\n\nBRCA1 has Moderate expression\nTP53 has Low expression\nMYC has High expression\nCDC2 has Low expression\nMBP has High expression\n\n\nIn-class Task:\n\nMake a data frame using genes and expr.\nAdd/flag the categories High, Moderate and Low you get using the for loop in a new column named expression_level or similar.\n\n\n# Step 1: Vectors\ngenes &lt;- c(\"BRCA1\", \"TP53\", \"MYC\", \"CDC2\", \"MBP\")\nexpr &lt;- c(8.2, 5.4, 11.0, 5.4, 13.0)\n\n# Step 2: Create a data frame\ngene_df &lt;- data.frame(gene = genes, expression = expr)\n\n# Step 3: Add an empty column for expression level\ngene_df$expression_level &lt;- NA\n\n# Step 4: Use for loop to fill in the expression_level column\nfor (i in 1:nrow(gene_df)) {\n  gene_df$expression_level[i] &lt;- if (gene_df$expression[i] &gt; 10) {\n    \"High\"\n  } else if (gene_df$expression[i] &gt; 6) {\n    \"Moderate\"\n  } else {\n    \"Low\"\n  }\n}\n\n# View the final data frame\nprint(gene_df)\n\n   gene expression expression_level\n1 BRCA1        8.2         Moderate\n2  TP53        5.4              Low\n3   MYC       11.0             High\n4  CDC2        5.4              Low\n5   MBP       13.0             High\n\n\n\nwhile loop\nContext: You are preparing biological samples (e.g., blood, DNA extracts) for analysis. You have a set of samples labeled Sample 1 to Sample 5. You want to check each one in order and confirm that it’s ready for analysis. Use a while loop to process the samples sequentially.\n\ni &lt;- 1\nwhile (i &lt;= 5) {\n  cat(\"Sample\", i, \"is ready for analysis\\n\")\n  i &lt;- i + 1\n}\n\nSample 1 is ready for analysis\nSample 2 is ready for analysis\nSample 3 is ready for analysis\nSample 4 is ready for analysis\nSample 5 is ready for analysis\n\n\n\nnext and break\n\nContext: You are screening biological samples (e.g., tissue or blood) in a quality control process. Some samples are good, some are suboptimal (not contaminated but poor quality), and some are contaminated (must be flagged and stop further processing). Use next to skip suboptimal samples and break to immediately stop when a contaminated sample is found.\n\nsamples &lt;- c(\"good\", \"bad\", \"good\", \"contaminated\")\n\nfor (s in samples) {\n  if (s == \"contaminated\") {\n    print(\"Stop! Contaminated sample.\")\n    break\n  }\n  if (s == \"bad\") next\n  print(paste(\"Processing\", s))\n}\n\n[1] \"Processing good\"\n[1] \"Processing good\"\n[1] \"Stop! Contaminated sample.\""
  },
  {
    "objectID": "ch/rbasics/firststeps.html#writing-functions-in-r",
    "href": "ch/rbasics/firststeps.html#writing-functions-in-r",
    "title": "Basic R",
    "section": "Writing Functions in R",
    "text": "Writing Functions in R\nFlag gene expression\n\nflag_expression &lt;- function(value) {\n  if (value &gt; 10) {\n    return(\"High\")\n  } else if (value &gt; 5) {\n    return(\"Moderate\")\n  } else {\n    return(\"Low\")\n  }\n}\n\nflag_expression(8.3)\n\n[1] \"Moderate\"\n\n\nApply to a vector\n\nexpr_values &lt;- c(12.2, 4.4, 7.5)\nsapply(expr_values, flag_expression)\n\n[1] \"High\"     \"Low\"      \"Moderate\"\n\n\nFunction with multiple arguments\n\ngene_status &lt;- function(gene, expression, threshold = 6) {\n  label &lt;- ifelse(expression &gt; threshold, \"Up\", \"Down\")\n  return(paste(gene, \"is\", label, \"regulated\"))\n}\n\ngene_status(\"TP53\", 8.1)\n\n[1] \"TP53 is Up regulated\"\n\n\nReturn a list\n\ncalc_stats &lt;- function(values) {\n  return(list(mean = mean(values), sd = sd(values)))\n}\n\ncalc_stats(c(4.2, 5.5, 7.8))\n\n$mean\n[1] 5.833333\n\n$sd\n[1] 1.823001"
  },
  {
    "objectID": "ch/rbasics/firststeps.html#homeworks-factors-subsetting-and-biological-insight",
    "href": "ch/rbasics/firststeps.html#homeworks-factors-subsetting-and-biological-insight",
    "title": "Basic R",
    "section": "🏡 Homeworks: Factors, Subsetting, and Biological Insight",
    "text": "🏡 Homeworks: Factors, Subsetting, and Biological Insight\n\n(Factor vs Character) Explain the difference between a character vector and a factor in R. Why would mutation_status be a factor and not just a character vector?\n(Factor Level Order) You observed the following bacterial species in gut microbiome samples:\n\n\nspecies &lt;- c(\"Lactobacillus\", \"Bacteroides\", \"Escherichia\", \"Bacteroides\", \"Lactobacillus\")\nspecies_factor &lt;- factor(species, levels = c(\"Bacteroides\", \"Escherichia\", \"Lactobacillus\"))\n\nWhat will levels(species_factor) return? Why?\n\nGiven the factor:\n\n\ndisease_severity &lt;- factor(c(\"Mild\", \"Severe\", \"Moderate\"), levels = c(\"Mild\", \"Moderate\", \"Severe\", \"Critical\"), ordered = TRUE)\n\nWhat will be the result of disease_severity[1] &lt; disease_severity[2] and why?\n\nYou computed:\n\n\nprop &lt;- prop.table(table(species_factor))\n\nHow do you extract the proportion of “Escherichia” samples from prop? Is prop$Escherichia valid?\n\nInterpret what this query returns:\n\n\ngene_df[gene_df$expression &gt; 7 & gene_df$mutation == \"No\", ]\n\nWhat type of genes does it select?\n\nYou have:\n\n\nsamples &lt;- c(\"WT\", \"KO\", \"WT\", \"KO\", \"WT\")\nexpression &lt;- c(5.2, 8.1, 4.3, 9.0, 5.7)\n\nMake a dataframe using these 2 vectors first. Then,\n\nCreate a factor group_factor for the samples.\nUse tapply() to calculate mean expression per group.\n\n\n\n\n\n\n\nNote\n\n\n\nUse ?tapply() to see how to use it.\nHint: You need to provide things for X, INDEX, FUN. You have X, INDEX in this small dataframe. The FUN should be applied thinking of what you are trying to do. You are trying to get the mean or average, right?\n\n\n\nPlot a barplot of average expression for each group.\n\n\nUse the gene_df example. Subset the data to find genes with:\n\n\nexpression &gt; 8\npathway is either “Cell Cycle” or “Signaling”\n\n\nCreate an ordered factor for the disease stages: c(\"Stage I\", \"Stage III\", \"Stage II\", \"Stage IV\", \"Stage I\"). Then plot the number of patients per stage using barplot(). Confirm that \"Stage III\" &gt; \"Stage I\" is logical in your factor.\nSuppose gene_data has a column type with values “Oncogene”, “Tumor Suppressor”, and “Housekeeping”.\n\n\nSubset all “Oncogene” rows where expression &gt; 8.\nChange the reference level of the factor type to “Housekeeping”\n\n\nSimulate expression data for 3 tissues (see the code chunk below): We are going to use rnorm() function to generate random values from a normal distribution for this purpose. The example values inside the rnorm() function means we want:\n\n\n30 values in total,\naverage or mean value = 8,\nstandard deviation of expression is 2.\n\nYou can play with the numbers to make your own values.\nrep() function is to replicate things (many times). In this example, we have rep(c(\"brain\", \"liver\", \"kidney\"), each = 10). We will be having 10x “brains”, followed by 10x “liver”, followed by 10x “kidney”. So, if you have changed your values inside the rnorm() function, make this value meaningful for you. Now we have 3 things, each=10. So, 3*10=30 is matching with the total value inside rnorm() function. Got it?\n\nset.seed(42) #just for reproducibility. Not completely needed\ngene_expr &lt;- rnorm(30, mean = 8, sd = 2)\ntissue &lt;- rep(c(\"brain\", \"liver\", \"kidney\"), each = 10)\ntissue_factor &lt;- factor(tissue, levels = c(\"liver\", \"brain\", \"kidney\"))\n\n\nMake a boxplot showing expression per tissue.\nWhich tissue shows the most variable gene expression? (Use tapply() + sd())\n\n\n\n\n\n\n\nNote\n\n\n\nHint: Variability is an expression of measuring standard deviation (sd) just by squaring it. So, var = sd^2. Well, do you see how to use sd inside tapply() function? Use ?tapply() to know how to use it.\n\n\nUse these questions as a self-check – reflect on why each step works before moving on to the next level (question).\nPush your .Rmd file and share by Friday 10PM BD Time."
  },
  {
    "objectID": "ch/rbasics/solutions.html#homework-solutions-factors-subsetting-and-biological-insight",
    "href": "ch/rbasics/solutions.html#homework-solutions-factors-subsetting-and-biological-insight",
    "title": "HW solutions",
    "section": "",
    "text": "Character vs Factor\nA character vector simply holds string values, but a factor is a categorical variable with fixed levels, used especially in modeling.\nFor mutation_status, a factor ensures consistent categories (e.g., \"Yes\" or \"No\") and helps control level order and statistical reference groups.\nFactor Levels\n\n\nspecies &lt;- c(\"Lactobacillus\", \"Bacteroides\", \"Escherichia\", \"Bacteroides\", \"Lactobacillus\")\nspecies_factor &lt;- factor(species, levels = c(\"Bacteroides\", \"Escherichia\", \"Lactobacillus\"))\nlevels(species_factor)\n\n[1] \"Bacteroides\"   \"Escherichia\"   \"Lactobacillus\"\n\n\nBecause we defined the level order explicitly, R maintains that order regardless of data input.\n\nOrdered Factor Comparison\n\n\ndisease_severity &lt;- factor(c(\"Mild\", \"Severe\", \"Moderate\"), levels = c(\"Mild\", \"Moderate\", \"Severe\", \"Critical\"), ordered = TRUE)\ndisease_severity[1] &lt; disease_severity[2]\n\n[1] TRUE\n\n# TRUE\n\n“Mild” is less severe than “Severe” based on the defined order.\n\nProportion Extraction\n\n\nprop &lt;- prop.table(table(species_factor))\nprop[\"Escherichia\"]\n\nEscherichia \n        0.2 \n\n\nprop$Escherichia won’t work — named numeric vectors require bracket-based access.\n\nSubsetting by Conditions\n\n\ngene_df &lt;- data.frame(\n  gene_id = c(\"BRCA1\", \"TP53\", \"MYC\", \"EGFR\", \"GAPDH\"),\n  expression = c(8.2, 6.1, 9.5, 7.0, 10.0),\n  mutation = factor(c(\"Yes\", \"No\", \"Yes\", \"No\", \"No\")),\n  pathway = c(\"DNA Repair\", \"Apoptosis\", \"Cell Cycle\", \"Signaling\", \"Metabolism\")\n)\nrownames(gene_df) &lt;- gene_df$gene_id #name the rows by the gene IDs\ngene_df &lt;- gene_df[, -1] #remove the first column which is not needed anymore\n#gene_df\ngene_df[gene_df$expression &gt; 7 & gene_df$mutation == \"No\", ]\n\n      expression mutation    pathway\nGAPDH         10       No Metabolism\n\n\nReturns genes with high expression (&gt;7) and no mutation — potentially highly active but wild-type genes.\n\nGroup-wise Expression Summary\n\nThe given vectors are:\n\nsamples &lt;- c(\"WT\", \"KO\", \"WT\", \"KO\", \"WT\")\nexpression &lt;- c(5.2, 8.1, 4.3, 9.0, 5.7)\n\nThe solution would be:\n\ngroup_factor &lt;- factor(samples)\n\n# Mean expression\ntapply(expression, group_factor, mean) ## KO: 8.55, WT: 5.07\n\n      KO       WT \n8.550000 5.066667 \n\n# Plot\nbarplot(tapply(expression, group_factor, mean), \n        col = c(\"skyblue\", \"salmon\"),\n        ylab = \"Mean Expression\",\n        main = \"Group-wise Expression\")\n\n\n\n\n\nGene Subsetting\n\n\ngene_df[gene_df$expression &gt; 8 & \n        gene_df$pathway %in% c(\"Cell Cycle\", \"Signaling\"), ]\n\n    expression mutation    pathway\nMYC        9.5      Yes Cell Cycle\n\n\nIt filters for genes highly expressed and involved in key biological pathways.\n\nDisease Stage Visualization\n\n\nstages &lt;- c(\"Stage I\", \"Stage III\", \"Stage II\", \"Stage IV\", \"Stage I\")\ndisease_stage &lt;- factor(stages, \n                        levels = c(\"Stage I\", \"Stage II\", \"Stage III\", \"Stage IV\"), \n                        ordered = TRUE)\n\nbarplot(table(disease_stage), \n        col = \"lightgreen\", \n        main = \"Patient Count by Disease Stage\",\n        ylab = \"Count\")\n\n\n\n\nLet’s do the severity order check:\n\n# Comparison\ndisease_stage[2] &gt; disease_stage[1]  # TRUE\n\n[1] TRUE\n\n\nSo, “Stage III” is more sever than “Stage I”.\n\nOncogene Subsetting and Releveling\n\n\n# Define a small gene dataset\ngene_data &lt;- data.frame(\n  gene = c(\"TP53\", \"BRCA1\", \"MYC\", \"GAPDH\", \"EGFR\"),\n  expression = c(9.1, 7.3, 10.5, 5.2, 8.6),\n  type = factor(c(\"Tumor Suppressor\", \"Oncogene\", \"Oncogene\", \"Housekeeping\", \"Oncogene\"))\n)\n\n# Subset: Oncogene rows with expression &gt; 8\ngene_data[gene_data$type == \"Oncogene\" & gene_data$expression &gt; 8, ]\n\n  gene expression     type\n3  MYC       10.5 Oncogene\n5 EGFR        8.6 Oncogene\n\n\nLet’s relevel now, “Housekeeping” is the reference:\n\n# Relevel: make \"Housekeeping\" the reference level\ngene_data$type &lt;- relevel(gene_data$type, ref = \"Housekeeping\")\n\n# Check the new levels\nlevels(gene_data$type)\n\n[1] \"Housekeeping\"     \"Oncogene\"         \"Tumor Suppressor\"\n\n\n\nSimulated Expression by Tissue\n\n\nset.seed(42)\ngene_expr &lt;- rnorm(45, mean = 8, sd = 2)\ntissue &lt;- rep(c(\"brain\", \"liver\", \"kidney\"), each = 15)\ntissue_factor &lt;- factor(tissue, levels = c(\"liver\", \"brain\", \"kidney\"))\n\nboxplot(gene_expr ~ tissue_factor, \n        col = c(\"orange\", \"skyblue\", \"lightgreen\"), \n        main = \"Expression by Tissue\",\n        ylab = \"Expression Level\")\n\n\n\n\nLet’s calculate variability per tissue type now:\n\n# Variability\ntapply(gene_expr, tissue_factor, sd)\n\n   liver    brain   kidney \n2.713940 2.050487 1.993668 \n\n# Returns standard deviation per tissue group"
  }
]